L 1 "..\..\..\..\Library\StdDriver\src\retarget.c"
N/**************************************************************************//**
N * @file     retarget.c
N * @version  V3.00
N * $Revision: 15 $
N * $Date: 15/11/04 9:32a $
N * @brief    M051 Series Debug Port and Semihost Setting Source File
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060044
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 17 "..\..\..\..\Library\StdDriver\src\retarget.c" 2
N#include "M051Series.h"
L 1 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 1
N/**************************************************************************//**
N * @file     M051Series.h
N * @version  V3.0
N * $Revision: 80 $
N * $Date: 15/08/10 9:27a $
N * @brief    M051 Series Peripheral Access Layer Header File
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of M051 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N  */
N
N#ifndef __M051Series_H__
N#define __M051Series_H__
N
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
Ntypedef enum IRQn
N{
N    /******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
N    NonMaskableInt_IRQn       = -14,      /*!< 2 Non Maskable Interrupt                             */
N    HardFault_IRQn            = -13,      /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
N    SVCall_IRQn               = -5,       /*!< 11 Cortex-M0 SV Call Interrupt                       */
N    PendSV_IRQn               = -2,       /*!< 14 Cortex-M0 Pend SV Interrupt                       */
N    SysTick_IRQn              = -1,       /*!< 15 Cortex-M0 System Tick Interrupt                   */
N
N    /******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
N    BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */
N    WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
N    EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                      */
N    EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                      */
N    GPIO_P0P1_IRQn            = 4,        /*!< GPIO_P0P1 Interrupt                                  */
N    GPIO_P2P3P4_IRQn          = 5,        /*!< GPIO_P2P3P4 Interrupt                                */
N    PWMA_IRQn                 = 6,        /*!< PWMA Interrupt                                       */
N    PWMB_IRQn                 = 7,        /*!< PWMB Interrupt                                       */
N    TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
N    TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
N    TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
N    TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
N    UART0_IRQn                = 12,       /*!< UART0 Interrupt                                      */
N    UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
N    SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
N    SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                       */
N    I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
N    I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
N    ACMP01_IRQn               = 25,       /*!< ACMP0/1 Interrupt                                    */
N    ACMP23_IRQn               = 26,       /*!< ACMP2/3 Interrupt                                    */
N    PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
N    ADC_IRQn                  = 29        /*!< ADC Interrupt                                        */
N
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
N#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
N#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
N
N
N#include "core_cm0.h"                   /*!< Cortex-M0 processor and core peripherals             */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.01
N * @date     13. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 116 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMINSTR_H */
L 117 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\..\..\..\Library\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMFUNC_H */
L 118 "..\..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
L 96 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "system_M051Series.h"          /*!< M051Series System                                    */
L 1 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\system_M051Series.h" 1
N/**************************************************************************//**
N * @file     system_M051Series.h
N * @version  V3.00
N * $Revision: 10 $
N * $Date: 14/07/11 2:20p $
N * @brief    M051 Series System Setting Header File
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYSTEM_M051Series_H__
N#define __SYSTEM_M051Series_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef DEBUG_PORT
N# define DEBUG_PORT      UART0       /*!< Select Debug Port which is used for retarget.c to output debug message to UART */
N#endif
N
N/**
N *
N * @details    This is used to enable PLL to speed up booting at startup. Remove it will cause system using
N *             default clock source (External crystal or internal 22.1184MHz IRC).
N *             Enable this option will cause system booting in 50MHz(By XTAL) or 50.1918MHz(By IRC22M) according to
N *             user configuration setting in CONFIG0
N *
N */
N//#define INIT_SYSCLK_AT_BOOTING
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N#define __HXT       (12000000UL)    /*!< External Crystal Clock Frequency     */
N#define __LIRC      (10000UL)       /*!< Internal 10K RC Oscillator Frequency */
N#define __HIRC      (22118400UL)    /*!< Internal 22M RC Oscillator Frequency */
N#define __HSI       (50000000UL)    /*!< PLL default output is 48MHz@12M X'tal */
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
Nextern uint32_t CyclesPerUs;        /*!< Cycles per micro second              */
Nextern uint32_t PllClock;           /*!< PLL Output Clock Frequency           */
N
N#if USE_ASSERT
S/**
S * @brief      Assert Function
S *
S * @param[in]  expr  Expression to be evaluated
S *
S * @return     None
S *
S * @details    If the expression is false, an error message will be printed out
S *             from debug port (UART0 or UART1).
S */
S#define ASSERT_PARAM(expr)  { if (!(expr)) { AssertError((uint8_t*)__FILE__, __LINE__); } }
S
Svoid AssertError(uint8_t* file, uint32_t line);
N#else
N#define ASSERT_PARAM(expr)
N#endif
N
N#define assert_param(expr)  ASSERT_PARAM(expr)
N
N
N/**
N * @brief    System Initialization
N *
N * @param    None
N *
N * @return   None
N *
N * @details  The necessary initialization of system.
N */
Nextern void SystemInit(void);
N
N
N/**
N * @brief    Update the Variable SystemCoreClock
N *
N * @param    None
N *
N * @return   None
N *
N * @details  This function is used to update the variable SystemCoreClock
N *           and must be called whenever the core clock is changed.
N */
Nextern void SystemCoreClockUpdate(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
N/* Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved. */
L 97 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N/**
N * Initialize the system clock
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system
N *         Initialize the PLL and update the SystemFrequency variable
N */
Nextern void SystemInit(void);
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N/** @addtogroup REGISTER Control Register
N
N  @{
N
N*/
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/** @addtogroup ACMP Analog Comparator Controller(ACMP)
N  Memory Mapped Structure for ACMP Controller
N  @{
N
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var ACMP_T::CR
N * Offset: 0x00,0x04  ACMP Comparator Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ACMPEN    |Comparator Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |Note: Comparator output needs to wait 2 us stable time after ACMPEN is set.
N * |[1]     |ACMPIE    |Comparator Interrupt Enable
N * |        |          |0 = Interrupt function Disabled.
N * |        |          |1 = Interrupt function Enabled.
N * |[2]     |HYSEN     |Comparator Hysteresis Enable
N * |        |          |0 = Hysteresis function Disabled.
N * |        |          |1 = Hysteresis function Enabled.
N * |[4]     |NEGSEL    |Comparator negative input selection
N * |        |          |0 = The ACMP0/2_N pin is selected as the source of negative comparator input.
N * |        |          |1 = The internal band-gap reference voltage is selected as the source of negative comparator input.
N * |[6]     |ACMPOINV  |Comparator output inverse select
N * |        |          |0 = The comparator output inverse function Disabled.
N * |        |          |1 = The comparator output inverse function Enabled.
N * @var ACMP_T::SR
N * Offset: 0x08  ACMP Comparator Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ACMPF0/2  |Comparator Flag 0/2
N * |        |          |This bit is set by hardware whenever the comparator output changes state. This will cause an interrupt if ACMPIE is set to 1.
N * |        |          |Write 1 to clear this bit to zero.
N * |[1]     |ACMPF1/3  |Comparator Flag 1/3
N * |        |          |This bit is set by hardware whenever the comparator output changes state. This will cause an interrupt if ACMPIE is set to 1.
N * |        |          |Write 1 to clear this bit to zero.
N * |[2]     |ACMPO0/2  |Comparator 0/2 Output
N * |        |          |Synchronized to the APB clock to allow reading by software. Cleared when the comparator is disabled (ACMP_CR0/2[0] = 0).
N * |[3]     |ACMPO1/3  |Comparator 1/3 Output
N * |        |          |Synchronized to the APB clock to allow reading by software. Cleared when the comparator is disabled (ACMP_CR1/3[0] = 0).
N */
N
N    __IO uint32_t CR[2];         /* Offset: 0x00,0x04  ACMP Comparator Control Register                              */
X    volatile uint32_t CR[2];          
N    __IO uint32_t SR;            /* Offset: 0x08  ACMP Comparator Status Register                                    */
X    volatile uint32_t SR;             
N
N} ACMP_T;
N
N
N
N/** @addtogroup ACMP_CONST ACMP Bit Field Definition
N  Constant Definitions for ACMP Controller
N  @{
N */
N
N/* ACMP_CR Bit Field Definitions */
N#define ACMP_CR_ACMPOINV_Pos   6                                 /*!< ACMP_T::CR: ACMPOINV Position */
N#define ACMP_CR_ACMPOINV_Msk   (1ul << ACMP_CR_ACMPOINV_Pos)     /*!< ACMP_T::CR: ACMPOINV Mask */
N
N#define ACMP_CR_NEGSEL_Pos     4                                 /*!< ACMP_T::CR: NEGSEL Position */
N#define ACMP_CR_NEGSEL_Msk     (1ul << ACMP_CR_NEGSEL_Pos)       /*!< ACMP_T::CR: NEGSEL Mask */
N
N#define ACMP_CR_HYSEN_Pos      2                                 /*!< ACMP_T::CR: HYSEN Position */
N#define ACMP_CR_HYSEN_Msk      (1ul << ACMP_CR_HYSEN_Pos)        /*!< ACMP_T::CR: HYSEN Mask */
N
N#define ACMP_CR_ACMPIE_Pos     1                                 /*!< ACMP_T::CR: ACMPIE Position */
N#define ACMP_CR_ACMPIE_Msk     (1ul << ACMP_CR_ACMPIE_Pos)       /*!< ACMP_T::CR: ACMPIE Mask */
N
N#define ACMP_CR_ACMPEN_Pos     0                                 /*!< ACMP_T::CR: ACMPEN Position */
N#define ACMP_CR_ACMPEN_Msk     (1ul << ACMP_CR_ACMPEN_Pos)       /*!< ACMP_T::CR: ACMPEN Mask */
N
N/* ACMP_SR01 Bit Field Definitions */
N#define ACMP_SR_ACMPO1_Pos   3                                   /*!< ACMP_T::SR: ACMPO1 Position */
N#define ACMP_SR_ACMPO1_Msk   (1ul << ACMP_SR_ACMPO1_Pos)         /*!< ACMP_T::SR: ACMPO1 Mask */
N
N#define ACMP_SR_ACMPO0_Pos   2                                   /*!< ACMP_T::SR: ACMPO0 Position */
N#define ACMP_SR_ACMPO0_Msk   (1ul << ACMP_SR_ACMPO0_Pos)         /*!< ACMP_T::SR: ACMPO0 Mask */
N
N#define ACMP_SR_ACMPF1_Pos   1                                   /*!< ACMP_T::SR: ACMPF1 Position */
N#define ACMP_SR_ACMPF1_Msk   (1ul << ACMP_SR_ACMPF1_Pos)         /*!< ACMP_T::SR: ACMPF1 Mask */
N
N#define ACMP_SR_ACMPF0_Pos   0                                   /*!< ACMP_T::SR: ACMPF0 Position */
N#define ACMP_SR_ACMPF0_Msk   (1ul << ACMP_SR_ACMPF0_Pos)         /*!< ACMP_T::SR: ACMPF0 Mask */
N
N/* ACMP_SR23 Bit Field Definitions */
N#define ACMP_SR_ACMPO3_Pos   3                                   /*!< ACMP_T::SR: ACMPO3 Position */
N#define ACMP_SR_ACMPO3_Msk   (1ul << ACMP_SR_ACMPO3_Pos)         /*!< ACMP_T::SR: ACMPO3 Mask */
N
N#define ACMP_SR_ACMPO2_Pos   2                                   /*!< ACMP_T::SR: ACMPO2 Position */
N#define ACMP_SR_ACMPO2_Msk   (1ul << ACMP_SR_ACMPO2_Pos)         /*!< ACMP_T::SR: ACMPO2 Mask */
N
N#define ACMP_SR_ACMPF3_Pos   1                                   /*!< ACMP_T::SR: ACMPF3 Position */
N#define ACMP_SR_ACMPF3_Msk   (1ul << ACMP_SR_ACMPF3_Pos)         /*!< ACMP_T::SR: ACMPF3 Mask */
N
N#define ACMP_SR_ACMPF2_Pos   0                                   /*!< ACMP_T::SR: ACMPF2 Position */
N#define ACMP_SR_ACMPF2_Msk   (1ul << ACMP_SR_ACMPF2_Pos)         /*!< ACMP_T::SR: ACMPF2 Mask */
N/**@}*/ /* ACMP_CONST */
N/**@}*/ /* ACMP */
N
N
N/*----------------------------- ADC Controller -------------------------------*/
N/** @addtogroup ADC Analog to Digital Converter(ADC)
N  Memory Mapped Structure for ADC Controller
N  @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var ADC_T::ADDR
N * Offset: 0x00-0x1C  A/D Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |RSLT      |A/D Conversion Result
N * |        |          |This field contains 12 bits conversion result.
N * |[16]    |OVERRUN   |Over Run Flag
N * |        |          |1 = Data in RSLT[11:0] is overwrite.
N * |        |          |0 = Data in RSLT[11:0] is recent conversion result.
N * |        |          |If converted data in RSLT[11:0] has not been read before new conversion result is
N * |        |          |loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after
N * |        |          |ADDR register is read.
N * |[17]    |VALID     |Valid Flag
N * |        |          |1 = Data in RSLT[11:0] bits is valid.
N * |        |          |0 = Data in RSLT[11:0] bits is not valid.
N * |        |          |This bit is set to 1 when corresponding channel analog input conversion is completed
N * |        |          |and cleared by hardware after ADDR register is read.
N * @var ADC_T::ADCR
N * Offset: 0x20  A/D Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ADEN      |A/D Converter Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |        |          |Before starting A/D conversion function, this bit should be set to 1. Clear it to 0 to
N * |        |          |disable A/D converter analog circuit for saving power consumption.
N * |[1]     |ADIE      |A/D Interrupt Enable
N * |        |          |1 = Enable A/D interrupt function
N * |        |          |0 = Disable A/D interrupt function
N * |        |          |A/D conversion end interrupt request is generated if ADIE bit is set to 1.
N * |[3:2]   |ADMD      |A/D Converter Operation Mode
N * |        |          |00 = Single conversion
N * |        |          |01 = Burst conversion
N * |        |          |10 = Single-cycle scan
N * |        |          |11 = Continuous scan
N * |        |          |When changing the operation mode, software should disable ADST bit firstly.
N * |        |          |Note: In Burst Mode, the A/D result data always at Data Register 0.
N * |[5:4]   |TRGS      |Hardware Trigger Source
N * |        |          |00 = A/D conversion is started by external STADC pin.
N * |        |          |Others = Reserved
N * |        |          |Software should disable TRGE and ADST before change TRGS.
N * |        |          |In hardware trigger mode, the ADST bit is set by the external trigger from STADC.
N * |[7:6]   |TRGCOND   |External Trigger Condition
N * |        |          |These two bits decide external pin STADC trigger event is level or edge. The signal
N * |        |          |must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and
N * |        |          |low state.
N * |        |          |00 = Low level
N * |        |          |01 = High level
N * |        |          |10 = Falling edge
N * |        |          |11 = Rising edge
N * |[8]     |TRGE      |External Trigger Enable
N * |        |          |Enable or disable triggering of A/D conversion by external STADC pin.
N * |        |          |1= Enable
N * |        |          |0= Disable
N * |[10]    |DIFFEN    |A/D Differential Input Mode Enable
N * |        |          |1 = A/D is in differential analog input mode
N * |        |          |0 = A/D is in single-end analog input mode
N * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus
N * |        |          |The Vplus of differential input paired channel 0 is from ADC0 pin; Vminus is from ADC1 pin.
N * |        |          |The Vplus of differential input paired channel 1 is from ADC2 pin; Vminus is from ADC3 pin.
N * |        |          |The Vplus of differential input paired channel 2 is from ADC4 pin; Vminus is from ADC5 pin.
N * |        |          |The Vplus of differential input paired channel 3 is from ADC6 pin; Vminus is from ADC7 pin.
N * |        |          |In differential input mode, only one of the two corresponding channels needs to be
N * |        |          |enabled in ADCHER. The conversion result will be placed to the corresponding data
N * |        |          |register of the enabled channel. If both channels of a differential input paired channel
N * |        |          |are enabled, the ADC will convert it twice in scan mode. And then write the conversion
N * |        |          |result to the two corresponding data registers.
N * |[11]    |ADST      |A/D Conversion Start
N * |        |          |1 = Conversion start.
N * |        |          |0 = Conversion stopped and A/D converter enter idle state.
N * |        |          |ADST bit can be controlled by two sources: software write and external pin STADC.
N * |        |          |ADST is cleared to 0 by hardware automatically at the ends of single mode and single-
N * |        |          |cycle scan mode on specified channels. In continuous scan mode, A/D conversion is
N * |        |          |continuously performed sequentially until this bit is cleared to 0 or chip reset.
N * @var ADC_T::ADCHER
N * Offset: 0x24  A/D Channel Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CHEN0     |Analog Input Channel 0 Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |        |          |This channel is the default enabled channel if CHEN0~7 are set as 0s.
N * |[1]     |CHEN1     |Analog Input Channel 1 Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |[2]     |CHEN2     |Analog Input Channel 2 Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |[3]     |CHEN3     |Analog Input Channel 3 Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |[4]     |CHEN4     |Analog Input Channel 4 Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |[5]     |CHEN5     |Analog Input Channel 5 Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |[6]     |CHEN6     |Analog Input Channel 6 Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |[7]     |CHEN7     |Analog Input Channel 7 Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |[9:8]   |PRESEL    |Analog Input Channel 7 select
N * |        |          |00: External analog input
N * |        |          |01: Internal bandgap voltage
N * |        |          |1x: Reserved
N * @var ADC_T::ADCMPR
N * Offset: 0x28,0x2C  A/D Compare Register 0 & 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CMPEN     |Compare Enable
N * |        |          |1 = Enable compare.
N * |        |          |0 = Disable compare.
N * |        |          |Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion
N * |        |          |result when converted data is loaded into ADDR register.
N * |[1]     |CMPIE     |Compare Interrupt Enable
N * |        |          |1 = Enable compare function interrupt.
N * |        |          |0 = Disable compare function interrupt.
N * |        |          |If the compare function is enabled and the compare condition matches the settings
N * |        |          |of CMPCOND and CMPMATCNT, CMPF0 bit will be asserted. If CMPIE is set to
N * |        |          |1, a compare interrupt request is generated.
N * |[2]     |CMPCOND   |Compare Condition
N * |        |          |1= Set the compare condition as that when a 12-bit A/D conversion result is
N * |        |          |greater or equal to the 12-bit CMPD(ADCMPR0[27:16]), the internal match
N * |        |          |counter will increase one.
N * |        |          |0= Set the compare condition as that when a 12-bit A/D conversion result is less
N * |        |          |than the 12-bit CMPD(ADCMPR0[27:16]), the internal match counter will
N * |        |          |increase one.
N * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT +1), the
N * |        |          |CMPF0 bit will be set.
N * |[5:3]   |CMPCH     |Compare Channel Selection
N * |        |          |000 = Channel 0 conversion result is selected to be compared.
N * |        |          |001 = Channel 1 conversion result is selected to be compared.
N * |        |          |010 = Channel 2 conversion result is selected to be compared.
N * |        |          |011 = Channel 3 conversion result is selected to be compared.
N * |        |          |100 = Channel 4 conversion result is selected to be compared.
N * |        |          |101 = Channel 5 conversion result is selected to be compared.
N * |        |          |110 = Channel 6 conversion result is selected to be compared.
N * |        |          |111 = Channel 7 conversion result is selected to be compared.
N * |[11:8]  |CMPMATCNT |Compare Match Count
N * |        |          |When the specified A/D channel analog conversion result matches the compare
N * |        |          |condition defined by CMPCOND[2], the internal match counter will increase 1.
N * |        |          |When the internal counter reaches the value to (CMPMATCNT +1), the CMPF0 bit
N * |        |          |will be set.
N * |[27:16] |CMPD      |Comparison Data
N * |        |          |The 12 bits data is used to compare with conversion result of specified channel.
N * |        |          |Software can use it to monitor the external analog input pin voltage transition in
N * |        |          |scan mode without imposing a load on software.
N * @var ADC_T::ADSR
N * Offset: 0x30  ADC Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ADF       |A/D Conversion End Flag
N * |        |          |A status flag that indicates the end of A/D conversion.
N * |        |          |ADF is set to 1 at these two conditions:
N * |        |          |1.  When A/D conversion ends in single mode
N * |        |          |2.  When A/D conversion ends on all specified channels in scan mode.
N * |        |          |3.  When more than 4 samples in FIFO in Burst mode.
N * |        |          |This bit can be cleared by writing 1 to itself.
N * |[1]     |CMPF0     |Compare Flag
N * |        |          |When the selected channel A/D conversion result meets the setting conditions of
N * |        |          |ADCMPR0 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
N * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting
N * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting
N * |[2]     |CMPF1     |Compare Flag
N * |        |          |When the selected channel A/D conversion result meets the setting conditions of
N * |        |          |ADCMPR1 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
N * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting
N * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting
N * |[3]     |BUSY      |BUSY/IDLE
N * |        |          |1 = A/D converter is busy at conversion.
N * |        |          |0 = A/D converter is in idle state.
N * |        |          |This bit is mirror of as ADST bit in ADCR.
N * |        |          |It is read only.
N * |[6:4]   |CHANNEL   |Current Conversion Channel
N * |        |          |This filed reflects current conversion channel when BUSY=1. When BUSY=0, it
N * |        |          |shows the next channel will be converted.
N * |        |          |It is read only.
N * |[15:8]  |VALID     |Data Valid flag
N * |        |          |It is a mirror of VALID bit in ADDRx
N * |        |          |When ADC is in Burst Mode, and there is at least one valid conversion result in buffer,
N * |        |          |VALID[7:0] will all set to 1.
N * |[23:16] |OVERRUN   |Over Run flag
N * |        |          |It is a mirror to OVERRUN bit in ADDRx
N * |        |          |When ADC is in Burst Mode, and the buffer is overrun, OVERRUN[7:0] will all set to
N * |        |          |1.
N * @var ADC_T::ADTDCR
N * Offset: 0x30  ADC Trigger Delay Control Register(M05xxDN/DE Only)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |PTDT      |PWM Trigger Delay Time
N * |        |          |Set this field will delay ADC start conversion time after PWM trigger.
N * |        |          |PWM trigger delay time is (4 * PTDT) * system clock 
N */
N
N    __I  uint32_t ADDR[8];       /* Offset: 0x00-0x1C  A/D Data Register                                             */
X    volatile const  uint32_t ADDR[8];        
N    __IO uint32_t ADCR;          /* Offset: 0x20  A/D Control Register                                               */
X    volatile uint32_t ADCR;           
N    __IO uint32_t ADCHER;        /* Offset: 0x24  A/D Channel Enable Register                                        */
X    volatile uint32_t ADCHER;         
N    __IO uint32_t ADCMPR[2];     /* Offset: 0x28,0x2C  A/D Compare Register 0 & 1                                    */
X    volatile uint32_t ADCMPR[2];      
N    __IO uint32_t ADSR;          /* Offset: 0x30  ADC Status Register                                                */
X    volatile uint32_t ADSR;           
N    __I  uint32_t RESERVED[4];
X    volatile const  uint32_t RESERVED[4];
N    __IO uint32_t ADTDCR;        /* Offset: 0x44  ADC Trigger Delay Control Register(M05xxDN/DE Only)                */
X    volatile uint32_t ADTDCR;         
N} ADC_T;
N
N
N
N
N/** @addtogroup ADC_CONST ADC Bit Field Definition
N  Constant Definitions for ADC Controller
N  @{
N */
N/* ADDR Bit Field Definitions */
N#define ADC_ADDR_VALID_Pos      17                                /*!< ADC_T::ADDR: VALID Position */
N#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC_T::ADDR: VALID Mask */
N
N#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC_T::ADDR: OVERRUN Position */
N#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC_T::ADDR: OVERRUN Mask */
N
N#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC_T::ADDR: RSLT Position */
N#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC_T::ADDR: RSLT Mask */
N
N/* ADCR Bit Field Definitions */
N#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC_T::ADCR: DMOF Position */
N#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC_T::ADCR: DMOF Mask */
N
N#define ADC_ADCR_ADST_Pos       11                                /*!< ADC_T::ADCR: ADST Position */
N#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC_T::ADCR: ADST Mask */
N
N#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC_T::ADCR: DIFFEN Position */
N#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC_T::ADCR: DIFFEN Mask */
N
N#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC_T::ADCR: TRGEN Position */
N#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC_T::ADCR: TRGEN Mask */
N
N#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC_T::ADCR: TRGCOND Position */
N#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC_T::ADCR: TRGCOND Mask */
N
N#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC_T::ADCR: TRGS Position */
N#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC_T::ADCR: TRGS Mask */
N
N#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC_T::ADCR: ADMD Position */
N#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC_T::ADCR: ADMD Mask */
N
N#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC_T::ADCR: ADIE Position */
N#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC_T::ADCR: ADIE Mask */
N
N#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC_T::ADCR: ADEN Position */
N#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC_T::ADCR: ADEN Mask */
N
N/* ADCHER Bit Field Definitions */
N#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC_T::ADCHER: PRESEL Position */
N#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC_T::ADCHER: PRESEL Mask */
N
N#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC_T::ADCHER: CHEN Position */
N#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC_T::ADCHER: CHEN Mask */
N
N/* ADCMPR Bit Field Definitions */
N#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC_T::ADCMPR: CMPD Position */
N#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC_T::ADCMPR: CMPD Mask */
N
N#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC_T::ADCMPR: CMPMATCNT Position */
N#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC_T::ADCMPR: CMPMATCNT Mask */
N
N#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC_T::ADCMPR: CMPCH Position */
N#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC_T::ADCMPR: CMPCH Mask */
N
N#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC_T::ADCMPR: CMPCOND Position */
N#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC_T::ADCMPR: CMPCOND Mask */
N
N#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC_T::ADCMPR: CMPIE Position */
N#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC_T::ADCMPR: CMPIE Mask */
N
N#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC_T::ADCMPR: CMPEN Position */
N#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC_T::ADCMPR: CMPEN Mask */
N
N/* ADSR Bit Field Definitions */
N#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC_T::ADSR: OVERRUN Position */
N#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC_T::ADSR: OVERRUN Mask */
N
N#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC_T::ADSR: VALID Position */
N#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC_T::ADSR: VALID Mask */
N
N#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC_T::ADSR: CHANNEL Position */
N#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC_T::ADSR: CHANNEL Mask */
N
N#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC_T::ADSR: BUSY Position */
N#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC_T::ADSR: BUSY Mask */
N
N#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC_T::ADSR: CMPF1 Position */
N#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC_T::ADSR: CMPF1 Mask */
N
N#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC_T::ADSR: CMPF0 Position */
N#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC_T::ADSR: CMPF0 Mask */
N
N#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC_T::ADSR: ADF Position */
N#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC_T::ADSR: ADF Mask */
N
N/* ADTDCR Bit Field Definitions */
N#define ADC_ADTDCR_PTDT_Pos        0                                     /*!< ADC_T::ADTDCR: PTDT Position */
N#define ADC_ADTDCR_PTDT_Msk        (0xFFul << ADC_ADTDCR_PTDT_Pos)       /*!< ADC_T::ADTDCR: PTDT Mask */
N/**@}*/ /* ADC_CONST */
N/**@}*/ /* ADC */
N
N
N/*---------------------------- Clock Controller ------------------------------*/
N
N/** @addtogroup CLK System Clock Controller(CLK)
N  Memory Mapped Structure for System Clock Controller
N  @{
N */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var CLK_T::PWRCON
N * Offset: 0x00  System Power Down Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field       |Descriptions
N * | :----: | :----:     | :---- |
N * |[0]     |XTL12M_EN   |External 4~24 MHz High Speed Crystal Enable (HXT) Control (Write Protect)
N * |        |            |The bit default value is set by flash controller user configuration register CFOSC (CONFIG0[26:24]).
N * |        |            |When the default clock source is from external 4~24 MHz high speed crystal, this bit is set to 1 automatically.
N * |        |            |0 = External 4~24 MHz high speed crystal oscillator (HXT) Disabled.
N * |        |            |1 = External 4~24 MHz high speed crystal oscillator (HXT) Enabled.
N * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register.    
N * |[2]     |OSC22M_EN   |Internal 22.1184 MHz High Speed Oscillator (HIRC) Enable Control (Write Protect)
N * |        |            |0 = Internal 22.1184 MHz high speed oscillator (HIRC) Disabled.
N * |        |            |1 = Internal 22.1184 MHz high speed oscillator (HIRC) Enabled.
N * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register. 
N * |[3]     |OSC10K_EN   |Internal 10 KHz Low Speed Oscillator (LIRC) Enable Control (Write Protect)
N * |        |            |0 = Internal 10 kHz low speed oscillator (LIRC) Disabled.
N * |        |            |1 = Internal 10 kHz low speed oscillator (LIRC) Enabled.
N * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[4]     |PD_WU_DLY   |Wake-up Delay Counter Enable Control (Write Protect)
N * |        |            |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
N * |        |            |The delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high speed crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high speed oscillator.
N * |        |            |0 = Clock cycles delay Disabled.
N * |        |            |1 = Clock cycles delay Enabled.
N * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[5]     |PD_WU_INT_EN|Power-Down Mode Wake-Up Interrupt Enable Control (Write Protect)
N * |        |            |0 = Power-down mode wake-up interrupt Disabled.
N * |        |            |1 = Power-down mode wake-up interrupt Enabled.
N * |        |            |Note1: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.
N * |        |            |Note2: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[6]     |PD_WU_STS   |Power-Down Mode Wake-Up Interrupt Status
N * |        |            |Set by "Power-down wake-up event", it indicates that resume from Power-down mode.
N * |        |            |The flag is set if the GPIO, UART, WDT, ACMP or BOD wake-up occurred.
N * |        |            |Write 1 to clear the bit to 0.
N * |        |            |Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1. 
N * |[7]     |PWR_DOWN_EN|System Power-Down Enable Bit (Write Protect)
N * |        |            |When this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depends on the PD_WAIT_CPU bit
N * |        |            |(a) If the PD_WAIT_CPU is 0, then the chip enters Power-down mode immediately after the PWR_DOWN_EN bit set.
N * |        |            |(b) if the PD_WAIT_CPU is 1, then the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode (recommend)
N * |        |            |When chip wakes up from Power-down mode, this bit is cleared by hardware.
N * |        |            |User needs to set this bit again for next Power-down.
N * |        |            |In Power-down mode, external 4~24 MHz high speed crystal oscillator and the internal 22.1184 MHz high speed oscillator will be disabled in this mode, but the internal 10 kHz low speed oscillator are not controlled by Power-down mode.
N * |        |            |In Power- down mode, the PLL and system clock are disabled, and ignored the clock source selection.
N * |        |            |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from the internal 10 kHz low speed oscillator.
N * |        |            |0 = Chip operating normally or chip in Idle mode because of WFI command.
N * |        |            |1 = Chip enters Power-down mode instantly or waits CPU sleep command WFI.
N * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[8]     |PD_WAIT_CPU |Power-down Entry Condition Control (Write Protect)
N * |        |            |0 = Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1.
N * |        |            |1 = Chip enters Power- down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1 and CPU run WFI instruction.
N * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * @var CLK_T::AHBCLK
N * Offset: 0x04  AHB Devices Clock Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control
N * |        |          |0 = Flash ISP peripheral clock Disabled.
N * |        |          |1 = Flash ISP peripheral clock Enabled.
N * |[3]     |EBI_EN    |EBI Controller Clock Enable Control
N * |        |          |0 = EBI peripherial clock Disabled.
N * |        |          |1 = EBI peripherial clock Enabled.
N * |[4]     |HDIV_EN   |Divider Controller Clock Enable Control 
N * |        |          |0 = Divider controller peripherial clock Disabled.
N * |        |          |1 = Divider controller peripherial clock Enabled.
N * @var CLK_T::APBCLK
N * Offset: 0x08  APB Devices Clock Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WDT_EN    |Watchdog Timer Clock Enable Control (Write Protect)
N * |        |          |0 = Watchdog Timer clock Disabled.
N * |        |          |1 = Watchdog Timer clock Enabled.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
N * |        |          |0 = Timer0 clock Disabled.
N * |        |          |1 = Timer0 clock Enabled.
N * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
N * |        |          |0 = Timer1 clock Disabled.
N * |        |          |1 = Timer1 clock Enabled.
N * |[4]     |TMR2_EN   |Timer2 Clock Enable Control
N * |        |          |0 = Timer2 clock Disabled.
N * |        |          |1 = Timer2 clock Enabled.
N * |[5]     |TMR3_EN   |Timer3 Clock Enable Control
N * |        |          |0 = Timer3 clock Disabled.
N * |        |          |1 = Timer3 clock Enabled.
N * |[6]     |FDIV_EN   |Frequency Divider Output Clock Enable Control
N * |        |          |0 = FDIV clock Disabled.
N * |        |          |1 = FDIV clock Enabled.
N * |[8]     |I2C0_EN   |I2C0 Clock Enable Control
N * |        |          |0 = I2C0 clock Disabled.
N * |        |          |1 = I2C0 clock Enabled.
N * |[8]     |I2C1_EN   |I2C1 Clock Enable Control
N * |        |          |0 = I2C1 clock Disabled.
N * |        |          |1 = I2C1 clock Enabled. 
N * |[12]    |SPI0_EN   |SPI0 Clock Enable Control
N * |        |          |0 = SPI0 clock Disabled.
N * |        |          |1 = SPI0 clock Enabled.
N * |[13]    |SPI1_EN   |SPI1 Clock Enable Control
N * |        |          |0 = SPI1 clock Disabled.
N * |        |          |1 = SPI1 clock Enabled.
N * |[16]    |UART0_EN  |UART0 Clock Enable Control
N * |        |          |0 = UART0 clock Disabled.
N * |        |          |1 = UART0 clock Enabled.
N * |[17]    |UART1_EN  |UART1 Clock Enable Control
N * |        |          |0 = UART1 clock Disabled.
N * |        |          |1 = UART1 clock Enabled.
N * |[20]    |PWM01_EN  |PWM_01 Clock Enable Control
N * |        |          |0 = PWM01 clock Disabled.
N * |        |          |1 = PWM01 clock Enabled.
N * |[21]    |PWM23_EN  |PWM_23 Clock Enable Control
N * |        |          |0 = PWM23 clock Disabled.
N * |        |          |1 = PWM23 clock Enabled.
N * |[22]    |PWM45_EN  |PWM_45 Clock Enable Control
N * |        |          |0 = PWM45 clock Disabled.
N * |        |          |1 = PWM45 clock Enabled.
N * |[23]    |PWM67_EN  |PWM_67 Clock Enable Control
N * |        |          |0 = PWM67 clock Disabled.
N * |        |          |1 = PWM67 clock Enabled.
N * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control
N * |        |          |0 = ADC clock Disabled.
N * |        |          |1 = ADC clock Enabled.
N * |[30]    |ACMP01_EN |Analog Comparator 0/1 Clock Enable Control
N * |        |          |0 = Analog Comparator 0/1 clock Disabled.
N * |        |          |1 = Analog Comparator 0/1 clock Enabled. 
N * |[31]    |ACMP23_EN |Analog Comparator 2/3 Clock Enable Control
N * |        |          |0 = Analog Comparator 2/3 clock Disabled.
N * |        |          |1 = Analog Comparator 2/3 clock Enabled.
N * @var CLK_T::CLKSTATUS
N * Offset: 0x0C  Clock Status Monitor Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field      |Descriptions
N * | :----: | :----:    | :---- |
N * |[0]     |XTL12M_STB|External 4~24 MHz High Speed Crystal (HXT) Clock Source Stable Flag (Read Only)
N * |        |           |0 = External 4~24 MHz high speed crystal clock (HXT) is not stable or disabled.
N * |        |           |1 = External 4~24 MHz high speed crystal clock (HXT) is stable.
N * |[2]     |PLL_STB    |Internal PLL Clock Source Stable Flag (Read Only)
N * |        |           |0 = Internal PLL clock is not stable or disabled.
N * |        |           |1 = Internal PLL clock is stable.
N * |[3]     |OSC10K_STB|Internal 10 KHz Low Speed Oscillator (LIRC) Clock Source Stable Flag (Read Only)
N * |        |           |0 = Internal 10 kHz low speed oscillator clock (LIRC) is not stable or disabled.
N * |        |           |1 = Internal 10 kHz low speed oscillator clock (LIRC) is stable.
N * |[4]     |OSC22M_STB|Internal 22.1184 MHz High Speed Oscillator (HIRC) Clock Source Stable Flag (Read Only)
N * |        |           |0 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is not stable or disabled.
N * |        |           |1 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is stable.
N * |[7]     |CLK_SW_FAIL|Clock switch fail flag
N * |        |           |0 = Clock switching success.
N * |        |           |1 = Clock switching failure. 
N * |        |           |Note1: 
N * |        |           |This bit is updated when software switches system clock source. 
N * |        |           |If switch target clock is stable, this bit will be set to 0. 
N * |        |           |If switch target clock is not stable, this bit will be set to 1.
N * |        |           |Note2: On M05xxBN, software can write 1 to clear the bit to 0.
N * |        |           |Note3: 
N * |        |           |On M05xxDN/DE, this bit is read only. 
N * |        |           |After selected clock source is stable, hardware will switch system clock to selected clock automatically, and CLK_SW_FAIL will be cleared automatically by hardware. 
N * @var CLK_T::CLKSEL0
N * Offset: 0x10  Clock Source Select Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |HCLK_S    |HCLK Clock Source Selection (Write Protect)
N * |        |          |000 = Clock source is from HXT.
N * |        |          |010 = Clock source is from PLL.
N * |        |          |011 = Clock source is from LIRC.
N * |        |          |111 = Clock source is from HIRC.
N * |        |          |Others = Reserved.
N * |        |          |Note1: Before clock switching, the related clock sources (both pre-select and new-select) must be turn-on and stable.
N * |        |          |Note2: The 3-bit default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset. Therefore the default value is either 000b or 111b.
N * |        |          |Note3: These bits are write protected bit. Refer to the REGWRPROT register.
N * |[5:3]   |STCLK_S   |Cortex-M0 SysTick Clock Source Selection from Reference Clock (Write Protect)
N * |        |          |If SYST_CSR[2] = 1, SysTick clock source is from HCLK.
N * |        |          |If SYST_CSR[2] = 0, SysTick clock source is defined by below settings.
N * |        |          |000 = Clock source is from HXT.
N * |        |          |010 = Clock source is from HXT/2
N * |        |          |011 = Clock source is from HCLK/2.
N * |        |          |111 = Clock source is from HIRC/2.
N * |        |          |Others = Reserved.
N * |        |          |Note1: This bit is write protected bit. Refer to the REGWRPROT register.
N * |        |          |Note2: If the SysTick clock source is not from HCLK (i.e. SYST_CSR[2] = 0), SysTick clock source must less than or equal to HCLK/2.
N * @var CLK_T::CLKSEL1
N * Offset: 0x14  Clock Source Select Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |WDT_S     |Watchdog Timer Clock Source Selection (Write Protect)
N * |        |          |10 = Clock source is from HCLK/2048 clock.
N * |        |          |11 = Clock source is from LIRC.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register. 
N * |[3:2]   |ADC_S     |ADC Peripheral Clock Source Selection
N * |        |          |00 = Clock source is from HXT.
N * |        |          |01 = Clock source is from PLL.
N * |        |          |10 = Clock source is from HCLK.
N * |        |          |11 = Clock source is from HIRC.
N * |[4]     |SPI0_S    |SPI0 clock Source Selection
N * |        |          |0 = Clock source is from PLL.
N * |        |          |1 = Clock source is from HCLK.
N * |[5]     |SPI1_S    |SPI1 clock Source Selection
N * |        |          |0 = Clock source is from PLL.
N * |        |          |1 = Clock source is from HCLK. 
N * |[10:8]  |TMR0_S    |TIMER0 Clock Source Selection
N * |        |          |000 = Clock source is from HXT.
N * |        |          |010 = Clock source is from HCLK.
N * |        |          |011 = Clock source is from external trigger T0.
N * |        |          |101 = Clock source is from LIRC.
N * |        |          |111 = Clock source is from HIRC.
N * |[14:12] |TMR1_S    |TIMER1 Clock Source Selection
N * |        |          |000 = Clock source is from HXT.
N * |        |          |010 = Clock source is from HCLK.
N * |        |          |011 = Clock source is from external trigger T1.
N * |        |          |101 = Clock source is from LIRC.
N * |        |          |111 = Clock source is from HIRC.
N * |[18:16] |TMR2_S    |TIMER2 Clock Source Selection
N * |        |          |000 = Clock source is from HXT.
N * |        |          |010 = Clock source is from HCLK.
N * |        |          |011 = Clock source is from external trigger T2.
N * |        |          |101 = Clock source is from LIRC.
N * |        |          |111 = Clock source is from HIRC.
N * |[22:20] |TMR3_S    |TIMER3 Clock Source Selection
N * |        |          |000 = Clock source is from HXT.
N * |        |          |010 = Clock source is from HCLK.
N * |        |          |011 = Clock source is from external trigger T3.
N * |        |          |101 = Clock source is from LIRC.
N * |        |          |111 = Clock source is from HIRC.
N * |[25:24] |UART_S    |UART Clock Source Selection
N * |        |          |00 = Clock source is from HXT.
N * |        |          |01 = Clock source is from PLL.
N * |        |          |11 = Clock source is from HIRC.
N * |[29:28] |PWM01_S   |PWM0 and PWM1 Clock Source Selection
N * |        |          |PWM0 and PWM1 use the same clock source; both of them use the same prescaler.
N * |        |          |00 = Clock source is from HXT.
N * |        |          |01 = Clock source is from LIRC.
N * |        |          |10 = Clock source is from HCLK.
N * |        |          |11 = Clock source is from HIRC.
N * |[31:30] |PWM23_S   |PWM2 and PWM3 Clock Source Selection
N * |        |          |PWM2 and PWM3 use the same clock source; both of them use the same prescaler.
N * |        |          |00 = Clock source is from HXT.
N * |        |          |01 = Clock source is from LIRC.
N * |        |          |10 = Clock source is from HCLK.
N * |        |          |11 = Clock source is from HIRC.
N * @var CLK_T::CLKDIV
N * Offset: 0x18  Clock Divider Number Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |HCLK_N    |HCLK Clock Divide Number from HCLK Clock Source
N * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1).
N * |[11:8]  |UART_N    |UART Clock Divide Number from UART Clock Source
N * |        |          |UART clock frequency = (UART clock source frequency ) / (UART_N + 1).
N * |[23:16] |ADC_N     |ADC peripheral Clock Divide Number from ADC peripheral Clock Source
N * |        |          |ADC peripheral clock frequency = (ADC peripheral clock source frequency ) / (ADC_N + 1).
N * @var CLK_T::CLKSEL2
N * Offset: 0x1C  Clock Source Select Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Select
N * |        |          |00 = clock source from HXT.
N * |        |          |10 = clock source from LIRC. 
N * |        |          |10 = clock source from HCLK.
N * |        |          |11 = clock source from HIRC.
N * |[5:4]   |PWM45_S   |PWM4 and PWM5 Clock Source Selection
N * |        |          |PWM4 and PWM5 use the same clock source; both of them use the same prescaler.
N * |        |          |00 = Clock source is from HXT.
N * |        |          |01 = Clock source is from LIRC.
N * |        |          |10 = Clock source is from HCLK.
N * |        |          |11 = Clock source is from HIRC.
N * |[7:6]   |PWM67_S   |PWM6 and PWM7 Clock Source Selection
N * |        |          |PWM6 and PWM7 use the same clock source; both of them use the same prescaler.
N * |        |          |00 = Clock source is from HXT.
N * |        |          |01 = Clock source is from LIRC.
N * |        |          |10 = Clock source is from HCLK.
N * |        |          |11 = Clock source is from HIRC.
N * |[17:16] |WWDT_S    |Window Watchdog Timer Clock Source Selection
N * |        |          |10 = Clock source is from HCLK/2048 clock.
N * |        |          |11 = Clock source is from LIRC. 
N * @var CLK_T::PLLCON
N * Offset: 0x20  PLL Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:0]   |FB_DV     |PLL Feedback Divider Control Bits
N * |        |          |Refer to the formulas below the table.
N * |[13:9]  |IN_DV     |PLL Input Divider Control Bits
N * |        |          |Refer to the formulas below the table.
N * |[15:14] |OUT_DV    |PLL Output Divider Control Bits
N * |        |          |Refer to the formulas below the table.
N * |[16]    |PD        |Power-Down Mode
N * |        |          |If the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode too.
N * |        |          |0 = PLL is in Normal mode.
N * |        |          |1 = PLL is in Power-down mode (default).
N * |[17]    |BP        |PLL Bypass Control
N * |        |          |0 = PLL is in Normal mode (default).
N * |        |          |1 = PLL clock output is same as PLL source clock input.
N * |[18]    |OE        |PLL OE (FOUT Enable)Control
N * |        |          |0 = PLL FOUT Enabled.
N * |        |          |1 = PLL FOUT is fixed low.
N * |[19]    |PLL_SRC   |PLL Source Clock Selection
N * |        |          |0 = PLL source clock from HXT.
N * |        |          |1 = PLL source clock from HIRC.
N * @var CLK_T::FRQDIV
N * Offset: 0x24  Frequency Divider Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
N * |        |          |The formula of output frequency is Fout = Fin/2(N+1).
N * |        |          |Fin is the input clock frequency.
N * |        |          |Fout is the frequency of divider output clock.
N * |        |          |N is the 4-bit value of FSEL[3:0].
N * |[4]     |DIVIDER_EN|Frequency Divider Enable Bit
N * |        |          |0 = Frequency Divider function Disabled.
N * |        |          |1 = Frequency Divider function Enabled.
N * |[5]     |DIVIDER1  |Frequency Divider One Enable Bit
N * |        |          |0 = Divider output frequency is depended on FSEL value.
N * |        |          |1 = Divider output frequency is the same as input clock frequency.
N */
N
N    __IO uint32_t PWRCON;        /* Offset: 0x00  System Power Down Control Register                                 */
X    volatile uint32_t PWRCON;         
N    __IO uint32_t AHBCLK;        /* Offset: 0x04  AHB Devices Clock Enable Control Register                          */
X    volatile uint32_t AHBCLK;         
N    __IO uint32_t APBCLK;        /* Offset: 0x08  APB Devices Clock Enable Control Register                          */
X    volatile uint32_t APBCLK;         
N    __IO uint32_t CLKSTATUS;     /* Offset: 0x0C  Clock Status Monitor Register                                      */
X    volatile uint32_t CLKSTATUS;      
N    __IO uint32_t CLKSEL0;       /* Offset: 0x10  Clock Source Select Control Register 0                             */
X    volatile uint32_t CLKSEL0;        
N    __IO uint32_t CLKSEL1;       /* Offset: 0x14  Clock Source Select Control Register 1                             */
X    volatile uint32_t CLKSEL1;        
N    __IO uint32_t CLKDIV;        /* Offset: 0x18  Clock Divider Number Register                                      */
X    volatile uint32_t CLKDIV;         
N    __IO uint32_t CLKSEL2;       /* Offset: 0x1C  Clock Source Select Control Register 2                             */
X    volatile uint32_t CLKSEL2;        
N    __IO uint32_t PLLCON;        /* Offset: 0x20  PLL Control Register                                               */
X    volatile uint32_t PLLCON;         
N    __IO uint32_t FRQDIV;        /* Offset: 0x24  Frequency Divider Control Register                                 */
X    volatile uint32_t FRQDIV;         
N
N} CLK_T;
N
N
N
N/** @addtogroup CLK_CONST CLK Bit Field Definition
N  Constant Definitions for CLK Controller
N  @{
N */
N
N/* CLK PWRCON Bit Field Definitions */
N#define CLK_PWRCON_PD_WAIT_CPU_Pos           8                                    /*!< CLK_T::PWRCON: PD_WAIT_CPU Position */
N#define CLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << CLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< CLK_T::PWRCON: PD_WAIT_CPU Mask */
N
N#define CLK_PWRCON_PWR_DOWN_EN_Pos           7                                    /*!< CLK_T::PWRCON: PWR_DOWN_EN Position */
N#define CLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << CLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< CLK_T::PWRCON: PWR_DOWN_EN Mask */
N
N#define CLK_PWRCON_PD_WU_STS_Pos             6                                    /*!< CLK_T::PWRCON: PD_WU_STS Position */
N#define CLK_PWRCON_PD_WU_STS_Msk             (1ul << CLK_PWRCON_PD_WU_STS_Pos)    /*!< CLK_T::PWRCON: PD_WU_STS Mask */
N
N#define CLK_PWRCON_PD_WU_INT_EN_Pos          5                                    /*!< CLK_T::PWRCON: PD_WU_INT_EN Position */
N#define CLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << CLK_PWRCON_PD_WU_INT_EN_Pos) /*!< CLK_T::PWRCON: PD_WU_INT_EN Mask */
N
N#define CLK_PWRCON_PD_WU_DLY_Pos             4                                    /*!< CLK_T::PWRCON: PD_WU_DLY Position */
N#define CLK_PWRCON_PD_WU_DLY_Msk             (1ul << CLK_PWRCON_PD_WU_DLY_Pos)    /*!< CLK_T::PWRCON: PD_WU_DLY Mask */
N
N#define CLK_PWRCON_OSC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: OSC10K_EN Position */
N#define CLK_PWRCON_OSC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)    /*!< CLK_T::PWRCON: OSC10K_EN Mask */
N#define CLK_PWRCON_IRC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: OSC10K_EN Position */
N#define CLK_PWRCON_IRC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)    /*!< CLK_T::PWRCON: OSC10K_EN Mask */
N
N#define CLK_PWRCON_OSC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: OSC22M_EN Position */
N#define CLK_PWRCON_OSC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)    /*!< CLK_T::PWRCON: OSC22M_EN Mask */
N#define CLK_PWRCON_IRC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: OSC22M_EN Position */
N#define CLK_PWRCON_IRC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)    /*!< CLK_T::PWRCON: OSC22M_EN Mask */
N
N#define CLK_PWRCON_XTL12M_EN_Pos             0                                    /*!< CLK_T::PWRCON: XTL12M_EN Position */
N#define CLK_PWRCON_XTL12M_EN_Msk             (1ul << CLK_PWRCON_XTL12M_EN_Pos)    /*!< CLK_T::PWRCON: XTL12M_EN Mask */
N
N/* CLK AHBCLK Bit Field Definitions */
N#define CLK_AHBCLK_HDIV_EN_Pos               4                                    /*!< CLK_T::AHBCLK: HDIV_EN Position */
N#define CLK_AHBCLK_HDIV_EN_Msk               (1ul << CLK_AHBCLK_HDIV_EN_Pos)      /*!< CLK_T::AHBCLK: HDIV_EN Mask */
N
N#define CLK_AHBCLK_EBI_EN_Pos                3                                    /*!< CLK_T::AHBCLK: EBI_EN Position */
N#define CLK_AHBCLK_EBI_EN_Msk                (1ul << CLK_AHBCLK_EBI_EN_Pos)       /*!< CLK_T::AHBCLK: EBI_EN Mask */
N
N#define CLK_AHBCLK_ISP_EN_Pos                2                                    /*!< CLK_T::AHBCLK: ISP_EN Position */
N#define CLK_AHBCLK_ISP_EN_Msk                (1ul << CLK_AHBCLK_ISP_EN_Pos)       /*!< CLK_T::AHBCLK: ISP_EN Mask */
N
N/* CLK APBCLK Bit Field Definitions */
N#define CLK_APBCLK_ACMP23_EN_Pos             31                                   /*!< CLK_T::APBCLK: ACMP23_EN Position */
N#define CLK_APBCLK_ACMP23_EN_Msk             (1ul << CLK_APBCLK_ACMP23_EN_Pos)    /*!< CLK_T::APBCLK: ACMP23_EN Mask */
N
N#define CLK_APBCLK_ACMP01_EN_Pos             30                                   /*!< CLK_T::APBCLK: ACMP01_EN Position */
N#define CLK_APBCLK_ACMP01_EN_Msk             (1ul << CLK_APBCLK_ACMP01_EN_Pos)    /*!< CLK_T::APBCLK: ACMP01_EN Mask */
N
N#define CLK_APBCLK_ADC_EN_Pos                28                                   /*!< CLK_T::APBCLK: ADC_EN Position */
N#define CLK_APBCLK_ADC_EN_Msk                (1ul << CLK_APBCLK_ADC_EN_Pos)       /*!< CLK_T::APBCLK: ADC_EN Mask */
N
N#define CLK_APBCLK_PWM67_EN_Pos              23                                   /*!< CLK_T::APBCLK: PWM67_EN Position */
N#define CLK_APBCLK_PWM67_EN_Msk              (1ul << CLK_APBCLK_PWM67_EN_Pos)     /*!< CLK_T::APBCLK: PWM67_EN Mask */
N
N#define CLK_APBCLK_PWM45_EN_Pos              22                                   /*!< CLK_T::APBCLK: PWM45_EN Position */
N#define CLK_APBCLK_PWM45_EN_Msk              (1ul << CLK_APBCLK_PWM45_EN_Pos)     /*!< CLK_T::APBCLK: PWM45_EN Mask */
N
N#define CLK_APBCLK_PWM23_EN_Pos              21                                   /*!< CLK_T::APBCLK: PWM23_EN Position */
N#define CLK_APBCLK_PWM23_EN_Msk              (1ul << CLK_APBCLK_PWM23_EN_Pos)     /*!< CLK_T::APBCLK: PWM23_EN Mask */
N
N#define CLK_APBCLK_PWM01_EN_Pos              20                                   /*!< CLK_T::APBCLK: PWM01_EN Position */
N#define CLK_APBCLK_PWM01_EN_Msk              (1ul << CLK_APBCLK_PWM01_EN_Pos)     /*!< CLK_T::APBCLK: PWM01_EN Mask */
N
N#define CLK_APBCLK_UART1_EN_Pos              17                                   /*!< CLK_T::APBCLK: UART1_EN Position */
N#define CLK_APBCLK_UART1_EN_Msk              (1ul << CLK_APBCLK_UART1_EN_Pos)     /*!< CLK_T::APBCLK: UART1_EN Mask */
N
N#define CLK_APBCLK_UART0_EN_Pos              16                                   /*!< CLK_T::APBCLK: UART0_EN Position */
N#define CLK_APBCLK_UART0_EN_Msk              (1ul << CLK_APBCLK_UART0_EN_Pos)     /*!< CLK_T::APBCLK: UART0_EN Mask */
N
N#define CLK_APBCLK_SPI1_EN_Pos               13                                   /*!< CLK_T::APBCLK: SPI1_EN Position */
N#define CLK_APBCLK_SPI1_EN_Msk               (1ul << CLK_APBCLK_SPI1_EN_Pos)      /*!< CLK_T::APBCLK: SPI1_EN Mask */
N
N#define CLK_APBCLK_SPI0_EN_Pos               12                                   /*!< CLK_T::APBCLK: SPI0_EN Position */
N#define CLK_APBCLK_SPI0_EN_Msk               (1ul << CLK_APBCLK_SPI0_EN_Pos)      /*!< CLK_T::APBCLK: SPI0_EN Mask */
N
N#define CLK_APBCLK_I2C1_EN_Pos               9                                    /*!< CLK_T::APBCLK: I2C1_EN Position */
N#define CLK_APBCLK_I2C1_EN_Msk               (1ul << CLK_APBCLK_I2C1_EN_Pos)      /*!< CLK_T::APBCLK: I2C1_EN Mask */
N
N#define CLK_APBCLK_I2C0_EN_Pos               8                                    /*!< CLK_T::APBCLK: I2C0_EN Position */
N#define CLK_APBCLK_I2C0_EN_Msk               (1ul << CLK_APBCLK_I2C0_EN_Pos)      /*!< CLK_T::APBCLK: I2C0_EN Mask */
N#define CLK_APBCLK_I2C_EN_Pos                8                                    /*!< CLK_T::APBCLK: I2C_EN Position */
N#define CLK_APBCLK_I2C_EN_Msk                (1ul << CLK_APBCLK_I2C_EN_Pos)       /*!< CLK_T::APBCLK: I2C_EN Mask */
N
N#define CLK_APBCLK_FDIV_EN_Pos               6                                    /*!< CLK_T::APBCLK: FDIV_EN Position */
N#define CLK_APBCLK_FDIV_EN_Msk               (1ul << CLK_APBCLK_FDIV_EN_Pos)      /*!< CLK_T::APBCLK: FDIV_EN Mask */
N
N#define CLK_APBCLK_TMR3_EN_Pos               5                                    /*!< CLK_T::APBCLK: TMR3_EN Position */
N#define CLK_APBCLK_TMR3_EN_Msk               (1ul << CLK_APBCLK_TMR3_EN_Pos)      /*!< CLK_T::APBCLK: TMR3_EN Mask */
N
N#define CLK_APBCLK_TMR2_EN_Pos               4                                    /*!< CLK_T::APBCLK: TMR2_EN Position */
N#define CLK_APBCLK_TMR2_EN_Msk               (1ul << CLK_APBCLK_TMR2_EN_Pos)      /*!< CLK_T::APBCLK: TMR2_EN Mask */
N
N#define CLK_APBCLK_TMR1_EN_Pos               3                                    /*!< CLK_T::APBCLK: TMR1_EN Position */
N#define CLK_APBCLK_TMR1_EN_Msk               (1ul << CLK_APBCLK_TMR1_EN_Pos)      /*!< CLK_T::APBCLK: TMR1_EN Mask */
N
N#define CLK_APBCLK_TMR0_EN_Pos               2                                    /*!< CLK_T::APBCLK: TMR0_EN Position */
N#define CLK_APBCLK_TMR0_EN_Msk               (1ul << CLK_APBCLK_TMR0_EN_Pos)      /*!< CLK_T::APBCLK: TMR0_EN Mask */
N
N#define CLK_APBCLK_WDT_EN_Pos                0                                    /*!< CLK_T::APBCLK: WDT_EN Position */
N#define CLK_APBCLK_WDT_EN_Msk                (1ul << CLK_APBCLK_WDT_EN_Pos)       /*!< CLK_T::APBCLK: WDT_EN Mask */
N
N/* CLK CLKSTATUS Bit Field Definitions */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                     /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Position */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << CLK_CLKSTATUS_CLK_SW_FAIL_Pos)/*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Mask */
N
N#define CLK_CLKSTATUS_OSC22M_STB_Pos         4                                    /*!< CLK_T::CLKSTATUS: OSC22M_STB Position */
N#define CLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)/*!< CLK_T::CLKSTATUS: OSC22M_STB Mask */
N#define CLK_CLKSTATUS_IRC22M_STB_Pos         4                                    /*!< CLK_T::CLKSTATUS: IRC22M_STB Position */
N#define CLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << CLK_CLKSTATUS_IRC22M_STB_Pos)/*!< CLK_T::CLKSTATUS: IRC22M_STB Mask */
N
N#define CLK_CLKSTATUS_OSC10K_STB_Pos         3                                    /*!< CLK_T::CLKSTATUS: OSC10K_STB Position */
N#define CLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)/*!< CLK_T::CLKSTATUS: OSC10K_STB Mask */
N#define CLK_CLKSTATUS_IRC10K_STB_Pos         3                                    /*!< CLK_T::CLKSTATUS: IRC10K_STB Position */
N#define CLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << CLK_CLKSTATUS_IRC10K_STB_Pos)/*!< CLK_T::CLKSTATUS: IRC10K_STB Mask */
N
N#define CLK_CLKSTATUS_PLL_STB_Pos            2                                    /*!< CLK_T::CLKSTATUS: PLL_STB Position */
N#define CLK_CLKSTATUS_PLL_STB_Msk            (1ul << CLK_CLKSTATUS_PLL_STB_Pos)   /*!< CLK_T::CLKSTATUS: PLL_STB Mask */
N
N#define CLK_CLKSTATUS_XTL12M_STB_Pos         0                                    /*!< CLK_T::CLKSTATUS: XTL12M_STB Position */
N#define CLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << CLK_CLKSTATUS_XTL12M_STB_Pos)/*!< CLK_T::CLKSTATUS: XTL12M_STB Mask */
N
N/* CLK CLKSEL0 Bit Field Definitions */
N#define CLK_CLKSEL0_STCLK_S_Pos              3                                    /*!< CLK_T::CLKSEL0: STCLK_S Position */
N#define CLK_CLKSEL0_STCLK_S_Msk              (7ul << CLK_CLKSEL0_STCLK_S_Pos)     /*!< CLK_T::CLKSEL0: STCLK_S Mask */
N
N#define CLK_CLKSEL0_HCLK_S_Pos               0                                    /*!< CLK_T::CLKSEL0: HCLK_S Position */
N#define CLK_CLKSEL0_HCLK_S_Msk               (7ul << CLK_CLKSEL0_HCLK_S_Pos)      /*!< CLK_T::CLKSEL0: HCLK_S Mask */
N
N/* CLK CLKSEL1 Bit Field Definitions */
N#define CLK_CLKSEL1_PWM23_S_Pos              30                                   /*!< CLK_T::CLKSEL1: PWM23_S Position */
N#define CLK_CLKSEL1_PWM23_S_Msk              (3ul << CLK_CLKSEL1_PWM23_S_Pos)     /*!< CLK_T::CLKSEL1: PWM23_S Mask */
N
N#define CLK_CLKSEL1_PWM01_S_Pos              28                                   /*!< CLK_T::CLKSEL1: PWM01_S Position */
N#define CLK_CLKSEL1_PWM01_S_Msk              (3ul << CLK_CLKSEL1_PWM01_S_Pos)     /*!< CLK_T::CLKSEL1: PWM01_S Mask */
N
N#define CLK_CLKSEL1_UART_S_Pos               24                                   /*!< CLK_T::CLKSEL1: UART_S Position */
N#define CLK_CLKSEL1_UART_S_Msk               (3ul << CLK_CLKSEL1_UART_S_Pos)      /*!< CLK_T::CLKSEL1: UART_S Mask */
N
N#define CLK_CLKSEL1_TMR3_S_Pos               20                                   /*!< CLK_T::CLKSEL1: TMR3_S Position */
N#define CLK_CLKSEL1_TMR3_S_Msk               (7ul << CLK_CLKSEL1_TMR3_S_Pos)      /*!< CLK_T::CLKSEL1: TMR3_S Mask */
N
N#define CLK_CLKSEL1_TMR2_S_Pos               16                                   /*!< CLK_T::CLKSEL1: TMR2_S Position */
N#define CLK_CLKSEL1_TMR2_S_Msk               (7ul << CLK_CLKSEL1_TMR2_S_Pos)      /*!< CLK_T::CLKSEL1: TMR2_S Mask */
N
N#define CLK_CLKSEL1_TMR1_S_Pos               12                                   /*!< CLK_T::CLKSEL1: TMR1_S Position */
N#define CLK_CLKSEL1_TMR1_S_Msk               (7ul << CLK_CLKSEL1_TMR1_S_Pos)      /*!< CLK_T::CLKSEL1: TMR1_S Mask */
N
N#define CLK_CLKSEL1_TMR0_S_Pos               8                                    /*!< CLK_T::CLKSEL1: TMR0_S Position */
N#define CLK_CLKSEL1_TMR0_S_Msk               (7ul << CLK_CLKSEL1_TMR0_S_Pos)      /*!< CLK_T::CLKSEL1: TMR0_S Mask */
N
N#define CLK_CLKSEL1_SPI1_S_Pos               5                                    /*!< CLK_T::CLKSEL1: SPI1_S Position */
N#define CLK_CLKSEL1_SPI1_S_Msk               (1ul << CLK_CLKSEL1_SPI1_S_Pos)      /*!< CLK_T::CLKSEL1: SPI1_S Mask */
N
N#define CLK_CLKSEL1_SPI0_S_Pos               4                                    /*!< CLK_T::CLKSEL1: SPI0_S Position */
N#define CLK_CLKSEL1_SPI0_S_Msk               (1ul << CLK_CLKSEL1_SPI0_S_Pos)      /*!< CLK_T::CLKSEL1: SPI0_S Mask */
N
N#define CLK_CLKSEL1_ADC_S_Pos                2                                    /*!< CLK_T::CLKSEL1: ADC_S Position */
N#define CLK_CLKSEL1_ADC_S_Msk                (3ul << CLK_CLKSEL1_ADC_S_Pos)       /*!< CLK_T::CLKSEL1: ADC_S Mask */
N
N#define CLK_CLKSEL1_WDT_S_Pos                0                                    /*!< CLK_T::CLKSEL1: WDT_S Position */
N#define CLK_CLKSEL1_WDT_S_Msk                (3ul << CLK_CLKSEL1_WDT_S_Pos)       /*!< CLK_T::CLKSEL1: WDT_S Mask */
N
N/* CLK CLKSEL2 Bit Field Definitions */
N#define CLK_CLKSEL2_WWDT_S_Pos               16                                   /*!< CLK_T::CLKSEL2: WWDT_S Position */
N#define CLK_CLKSEL2_WWDT_S_Msk               (3ul << CLK_CLKSEL2_WWDT_S_Pos)      /*!< CLK_T::CLKSEL2: WWDT_S Mask */
N
N#define CLK_CLKSEL2_PWM67_S_Pos              6                                    /*!< CLK_T::CLKSEL2: PWM67_S Position */
N#define CLK_CLKSEL2_PWM67_S_Msk              (3ul << CLK_CLKSEL2_PWM67_S_Pos)     /*!< CLK_T::CLKSEL2: PWM67_S Mask */
N
N#define CLK_CLKSEL2_PWM45_S_Pos              4                                    /*!< CLK_T::CLKSEL2: PWM45_S Position */
N#define CLK_CLKSEL2_PWM45_S_Msk              (3ul << CLK_CLKSEL2_PWM45_S_Pos)     /*!< CLK_T::CLKSEL2: PWM45_S Mask */
N
N#define CLK_CLKSEL2_FRQDIV_S_Pos             2                                    /*!< CLK_T::CLKSEL2: FRQDIV_S Position */
N#define CLK_CLKSEL2_FRQDIV_S_Msk             (3ul << CLK_CLKSEL2_FRQDIV_S_Pos)    /*!< CLK_T::CLKSEL2: FRQDIV_S Mask */
N
N/* CLK CLKDIV Bit Field Definitions */
N#define CLK_CLKDIV_ADC_N_Pos                 16                                   /*!< CLK_T::CLKDIV: ADC_N Position */
N#define CLK_CLKDIV_ADC_N_Msk                 (0xFFul << CLK_CLKDIV_ADC_N_Pos)     /*!< CLK_T::CLKDIV: ADC_N Mask */
N
N#define CLK_CLKDIV_UART_N_Pos                8                                    /*!< CLK_T::CLKDIV: UART_N Position */
N#define CLK_CLKDIV_UART_N_Msk                (0xFul << CLK_CLKDIV_UART_N_Pos)     /*!< CLK_T::CLKDIV: UART_N Mask */
N
N#define CLK_CLKDIV_HCLK_N_Pos                0                                    /*!< CLK_T::CLKDIV: HCLK_N Position */
N#define CLK_CLKDIV_HCLK_N_Msk                (0xFul << CLK_CLKDIV_HCLK_N_Pos)     /*!< CLK_T::CLKDIV: HCLK_N Mask */
N
N/* CLK PLLCON Bit Field Definitions */
N#define CLK_PLLCON_PLL_SRC_Pos               19                                      /*!< CLK_T::PLLCON: PLL_SRC Position */
N#define CLK_PLLCON_PLL_SRC_Msk               (1ul << CLK_PLLCON_PLL_SRC_Pos)      /*!< CLK_T::PLLCON: PLL_SRC Mask */
N
N#define CLK_PLLCON_OE_Pos                    18                                   /*!< CLK_T::PLLCON: OE Position */
N#define CLK_PLLCON_OE_Msk                    (1ul << CLK_PLLCON_OE_Pos)           /*!< CLK_T::PLLCON: OE Mask */
N
N#define CLK_PLLCON_BP_Pos                    17                                   /*!< CLK_T::PLLCON: BP Position */
N#define CLK_PLLCON_BP_Msk                    (1ul << CLK_PLLCON_BP_Pos)           /*!< CLK_T::PLLCON: BP Mask */
N
N#define CLK_PLLCON_PD_Pos                    16                                   /*!< CLK_T::PLLCON: PD Position */
N#define CLK_PLLCON_PD_Msk                    (1ul << CLK_PLLCON_PD_Pos)           /*!< CLK_T::PLLCON: PD Mask */
N
N#define CLK_PLLCON_OUT_DV_Pos                14                                   /*!< CLK_T::PLLCON: OUT_DV Position */
N#define CLK_PLLCON_OUT_DV_Msk                (3ul << CLK_PLLCON_OUT_DV_Pos)       /*!< CLK_T::PLLCON: OUT_DV Mask */
N
N#define CLK_PLLCON_IN_DV_Pos                 9                                    /*!< CLK_T::PLLCON: IN_DV Position */
N#define CLK_PLLCON_IN_DV_Msk                 (0x1Ful << CLK_PLLCON_IN_DV_Pos)     /*!< CLK_T::PLLCON: IN_DV Mask */
N
N#define CLK_PLLCON_FB_DV_Pos                 0                                    /*!< CLK_T::PLLCON: FB_DV Position */
N#define CLK_PLLCON_FB_DV_Msk                 (0x1FFul << CLK_PLLCON_FB_DV_Pos)    /*!< CLK_T::PLLCON: FB_DV Mask */
N
N/* CLK FRQDIV Bit Field Definitions */
N#define CLK_FRQDIV_DIVIDER1_Pos              5                                    /*!< CLK_T::FRQDIV: DIVIDER1 Position */
N#define CLK_FRQDIV_DIVIDER1_Msk              (1ul << CLK_FRQDIV_DIVIDER1_Pos)     /*!< CLK_T::FRQDIV: DIVIDER1 Mask */
N
N#define CLK_FRQDIV_DIVIDER_EN_Pos            4                                    /*!< CLK_T::FRQDIV: DIVIDER_EN Position */
N#define CLK_FRQDIV_DIVIDER_EN_Msk            (1ul << CLK_FRQDIV_DIVIDER_EN_Pos)   /*!< CLK_T::FRQDIV: DIVIDER_EN Mask */
N
N#define CLK_FRQDIV_FSEL_Pos                  0                                    /*!< CLK_T::FRQDIV: FSEL Position */
N#define CLK_FRQDIV_FSEL_Msk                  (0xFul << CLK_FRQDIV_FSEL_Pos)       /*!< CLK_T::FRQDIV: FSEL Mask */
N/**@}*/ /* CLK_CONST */
N/**@}*/ /* CLK */
N
N
N/*----------------------- External Bus Interface Controller ------------------*/
N/** @addtogroup EBI External Bus Interface(EBI)
N  Memory Mapped Structure for External Bus Interface Controller
N  @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var EBI_T::EBICON
N * Offset: 0x00  EBI Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ExtEN     |EBI Enable
N * |        |          |This bit is the functional enable bit for EBI.
N * |        |          |0 = EBI function is disabled
N * |        |          |1 = EBI function is enabled
N * |[1]     |ExtBW16   |EBI data width 16 bit
N * |        |          |This bit defines if the data bus is 8-bit or 16-bit.
N * |        |          |0 = EBI data width is 8 bit
N * |        |          |1 = EBI data width is 16 bit
N * |[10:8]  |MCLKDIV   |External Output Clock Divider
N * |        |          |The frequency of EBI output clock is controlled by MCLKDIV.
N * |        |          |000 = HCLK/1
N * |        |          |001 = HCLK/2
N * |        |          |010 = HCLK/4
N * |        |          |011 = HCLK/8
N * |        |          |100 = HCLK/16
N * |        |          |101 = HCKL/32
N * |        |          |11X = default
N * |        |          |Notice: Default value of output clock is HCLK/1
N * |[18:16] |ExttALE   |Expand Time of ALE
N * |        |          |The ALE width (tALE) to latch the address can be controlled by ExttALE.
N * |        |          |tALE = (ExttALE + 1) * MCLK
N * @var EBI_T::EXTIME
N * Offset: 0x04  EBI Timing Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:3]   |ExttACC   |EBI Data Access Time
N * |        |          |ExttACC define data access time (tACC).
N * |        |          |tACC = (ExttACC + 1) * MCLK
N * |[10:8]  |ExttAHD   |EBI Data Access Hold Time
N * |        |          |ExttAHD define data access hold time (tAHD).
N * |        |          |tAHD = (ExttAHD + 1) * MCLK
N * |[15:12] |ExtIW2X   |Idle State Cycle After Write
N * |        |          |When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not zero.
N * |        |          |Idle state cycle = (ExtIW2X * MCLK)
N * |[27:24] |ExtIR2R   |Idle State Cycle Between Read-Read
N * |        |          |When read action is finish and next action is going to read, idle state is inserted and nCS return
N * |        |          |to high if ExtIR2R is not zero.
N * |        |          |Idle state cycle = (ExtIR2R * MCLK)
N * @var EBI_T::EBICON2
N * Offset: 0x08   External Bus Interface General Control Register 2
N * ---------------------------------------------------------------------------------------------------
N */
N
N    __IO uint32_t EBICON;        /* Offset: 0x00  EBI Control Register                                               */
X    volatile uint32_t EBICON;         
N    __IO uint32_t EXTIME;        /* Offset: 0x04  EBI Timing Control Register                                        */
X    volatile uint32_t EXTIME;         
N    __IO uint32_t EBICON2;       /* Offset: 0x08   External Bus Interface General Control Register 2                 */
X    volatile uint32_t EBICON2;        
N
N} EBI_T;
N
N
N
N
N/** @addtogroup EBI_CONST EBI Bit Field Definition
N  Constant Definitions for EBI Controller
N  @{
N */
N/* EBI EBICON Bit Field Definitions */
N#define EBI_EBICON_ExttALE_Pos      16                                          /*!< EBI_T::EBICON: ExttALE Position */
N#define EBI_EBICON_ExttALE_Msk      (0x7ul << EBI_EBICON_ExttALE_Pos)           /*!< EBI_T::EBICON: ExttALE Mask */
N
N#define EBI_EBICON_MCLKDIV_Pos      8                                           /*!< EBI_T::EBICON: MCLKDIV Position */
N#define EBI_EBICON_MCLKDIV_Msk      (0x7ul << EBI_EBICON_MCLKDIV_Pos)           /*!< EBI_T::EBICON: MCLKDIV Mask */
N
N#define EBI_EBICON_ExtBW16_Pos      1                                           /*!< EBI_T::EBICON: ExtBW16 Position */
N#define EBI_EBICON_ExtBW16_Msk      (1ul << EBI_EBICON_ExtBW16_Pos)             /*!< EBI_T::EBICON: ExtBW16 Mask */
N
N#define EBI_EBICON_ExtEN_Pos        0                                           /*!< EBI_T::EBICON: ExtEN Position */
N#define EBI_EBICON_ExtEN_Msk        (1ul << EBI_EBICON_ExtEN_Pos)               /*!< EBI_T::EBICON: ExtEN Mask */
N
N/* EBI EXTIME Bit Field Definitions */
N#define EBI_EXTIME_ExtIR2R_Pos      24                                          /*!< EBI_T::EXTIME: ExtIR2R Position */
N#define EBI_EXTIME_ExtIR2R_Msk      (0xFul << EBI_EXTIME_ExtIR2R_Pos)           /*!< EBI_T::EXTIME: ExtIR2R Mask */
N
N#define EBI_EXTIME_ExtIW2X_Pos      12                                          /*!< EBI_T::EXTIME: ExtIW2X Position */
N#define EBI_EXTIME_ExtIW2X_Msk      (0xFul << EBI_EXTIME_ExtIW2X_Pos)           /*!< EBI_T::EXTIME: ExtIW2X Mask */
N
N#define EBI_EXTIME_ExttAHD_Pos      8                                           /*!< EBI_T::EXTIME: ExttAHD Position */
N#define EBI_EXTIME_ExttAHD_Msk      (0x7ul << EBI_EXTIME_ExttAHD_Pos)           /*!< EBI_T::EXTIME: ExttAHD Mask */
N
N#define EBI_EXTIME_ExttACC_Pos      3                                           /*!< EBI_T::EXTIME: ExttACC Position */
N#define EBI_EXTIME_ExttACC_Msk      (0x1Ful << EBI_EXTIME_ExttACC_Pos)          /*!< EBI_T::EXTIME: ExttACC Mask */
N
N/* EBI EBICON2 Bit Field Definitions */
N#define EBI_EBICON2_WAHD_OFF_Pos    2                                           /*!< EBI_T::EBICON2: WAHD_OFF Position */
N#define EBI_EBICON2_WAHD_OFF_Msk    (1ul << EBI_EBICON2_WAHD_OFF_Pos)           /*!< EBI_T::EBICON2: WAHD_OFF Mask */
N
N#define EBI_EBICON2_RAHD_OFF_Pos    1                                           /*!< EBI_T::EBICON2: RAHD_OFF Position */
N#define EBI_EBICON2_RAHD_OFF_Msk    (1ul << EBI_EBICON2_RAHD_OFF_Pos)           /*!< EBI_T::EBICON2: RAHD_OFF Mask */
N
N#define EBI_EBICON2_WBUFF_EN_Pos    0                                           /*!< EBI_T::EBICON2: WBUFF_EN Position */
N#define EBI_EBICON2_WBUFF_EN_Msk    (1ul << EBI_EBICON2_WBUFF_EN_Pos)           /*!< EBI_T::EBICON2: WBUFF_EN Mask */
N/**@}*/ /* EBI_CONST */
N/**@}*/ /* EBI */
N
N
N/*-------------------------- FLASH Memory Controller -------------------------*/
N
N/** @addtogroup FMC Flash Memory Controller(FMC)
N *
N * Memory Mapped Structure for Flash Memory Controller
N * @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var FMC_T::ISPCON
N * Offset: 0x00  ISP Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPEN     |ISP Enable
N * |        |          |This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function.
N * |        |          |1 = Enable ISP function
N * |        |          |0 = Disable ISP function
N * |[1]     |BS        |Boot Select
N * |        |          |This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM,
N * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check where
N * |        |          |MCU booted from. This bit is initiated with the inverted value of CBS in Config0 after power-
N * |        |          |on reset; It keeps the same value at other reset.
N * |        |          |1 = boot from LDROM
N * |        |          |0 = boot from APROM
N * |[3]     |APUEN     |APROM Update Enable (write-protected)
N * |        |          |1 = APROM can be updated when the chip runs in APROM
N * |        |          |0 = APROM can not be updated when the chip runs in APROM
N * |[4]     |CFGUEN    |Config Update Enable
N * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program
N * |        |          |code is running in APROM or LDROM.
N * |        |          |1 = Config update enable
N * |        |          |0 = Config update disable
N * |[5]     |LDUEN     |LDROM Update Enable
N * |        |          |LDROM update enable bit.
N * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
N * |        |          |0 = LDROM cannot be updated
N * |[6]     |ISPFF     |ISP Fail Flag
N * |        |          |(1) APROM writes to itself.
N * |        |          |(2) LDROM writes to itself.
N * |        |          |(3) CONFIG is erased/programmed when CFGUEN is set to 0
N * |        |          |(4) Destination address is illegal, such as over an available range.
N * |        |          |Write 1 to clear this bit.
N * @var FMC_T::ISPADR
N * Offset: 0x04  ISP Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPADR    |ISP Address
N * |        |          |NuMicro M051 series equips with a maximum 16kx32 embedded flash, it supports word program
N * |        |          |only. ISPARD[1:0] must be kept 2'b00 for ISP operation.
N * @var FMC_T::ISPDAT
N * Offset: 0x08  ISP Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPDAT    |ISP Data
N * |        |          |Write data to this register before ISP program operation
N * |        |          |Read data from this register after ISP read operation
N * @var FMC_T::ISPCMD
N * Offset: 0x0C  ISP Command Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |ISPCMD    |ISP Command
N * |        |          |ISP command table is shown below:
N * |        |          |0x00 = Read.
N * |        |          |0x21 = Program.
N * |        |          |0x22 = Page Erase.
N * @var FMC_T::ISPTRG
N * Offset: 0x10  IISP Trigger Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPGO     |ISP start trigger
N * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP
N * |        |          |operation is finish.
N * |        |          |1 = ISP is on going
N * |        |          |0 = ISP done
N * @var FMC_T::DFBADR
N * Offset: 0x14  Data Flash Base Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |DFBA      |Data Flash Base Address
N * |        |          |This register indicates data flash start address.
N * |        |          |It is a read only register.
N * |        |          |For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is fixed at
N * |        |          |0x01F000 by hardware internally.
N * @var FMC_T::FATCON
N * Offset: 0x18  Flash Access Time Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[4]     |LFOM      |Low Frequency Optimization Mode (write-protected)
N * |        |          |1 = Flash access always no wait state (zero wait state)
N * |        |          |0 = Insert wait state while Flash access discontinued address.
N * |        |          |Note: Set this bit only when HCLK <= 25MHz. If HCLK > 25MHz, CPU will fetch wrong
N * |        |          |code and cause fail result.
N * @var FMC_T::ISPSTA
N * Offset: 0x40  ISP Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPGO     |ISP Start Trigger (Read Only)
N * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware
N * |        |          |automatically when ISP operation is finished.
N * |        |          |1 = ISP operation progressed.
N * |        |          |0 = ISP operation finished.
N * |        |          |Note: This bit is the same as ISPTRG bit0
N * |[2:1]   |CBS       |Chip Boot Selection (Read Only)
N * |        |          |This is a mirror of CBS in Config0.
N * |[6]     |ISPFF     |ISP Fail Flag (Write-protection Bit)
N * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N * |        |          |(1) APROM writes to itself.
N * |        |          |(2) LDROM writes to itself.
N * |        |          |(3) CONFIG is erased/programmed when CFGUEN is set to 0
N * |        |          |(4) Destination address is illegal, such as over an available range.
N * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
N * |        |          |The current flash address space 0x0000_0000~0x0000_01FF is mapping to the address
N * |        |          |specified by the VECMAP * 512.
N */
N
N    __IO uint32_t ISPCON;        /* Offset: 0x00  ISP Control Register                                               */
X    volatile uint32_t ISPCON;         
N    __IO uint32_t ISPADR;        /* Offset: 0x04  ISP Address Register                                               */
X    volatile uint32_t ISPADR;         
N    __IO uint32_t ISPDAT;        /* Offset: 0x08  ISP Data Register                                                  */
X    volatile uint32_t ISPDAT;         
N    __IO uint32_t ISPCMD;        /* Offset: 0x0C  ISP Command Register                                               */
X    volatile uint32_t ISPCMD;         
N    __IO uint32_t ISPTRG;        /* Offset: 0x10  IISP Trigger Control Register                                      */
X    volatile uint32_t ISPTRG;         
N    __I  uint32_t DFBADR;        /* Offset: 0x14  Data Flash Base Address Register                                   */
X    volatile const  uint32_t DFBADR;         
N    __IO uint32_t FATCON;        /* Offset: 0x18  Flash Access Time Control Register                                 */
X    volatile uint32_t FATCON;         
N    __I  uint32_t RESERVED[9];   
X    volatile const  uint32_t RESERVED[9];   
N    __IO uint32_t ISPSTA;        /* Offset: 0x40  ISP Status Register                                                */
X    volatile uint32_t ISPSTA;         
N} FMC_T;
N
N
N
N/** @addtogroup FMC_CONST FMC Bit Field Definition
N  Constant Definitions for FMC Controller
N  @{
N */
N/* FMC ISPCON Bit Field Definitions */
N#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC_T::ISPCON: ISPFF Position */
N#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC_T::ISPCON: ISPFF Mask */
N
N#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC_T::ISPCON: LDUEN Position */
N#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC_T::ISPCON: LDUEN Mask */
N
N#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC_T::ISPCON: CFGUEN Position */
N#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC_T::ISPCON: CFGUEN Mask */
N
N#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC_T::ISPCON: APUEN Position */
N#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC_T::ISPCON: APUEN Mask */
N
N#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC_T::ISPCON: BS Position */
N#define FMC_ISPCON_BS_Msk                       (1ul << FMC_ISPCON_BS_Pos)              /*!< FMC_T::ISPCON: BS Mask */
N
N#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC_T::ISPCON: ISPEN Position */
N#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC_T::ISPCON: ISPEN Mask */
N
N
N/* FMC ISPCMD Bit Field Definitions */
N#define FMC_ISPCMD_FOEN_Pos                     5                                       /*!< FMC_T::ISPCMD: FOEN Position */
N#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)            /*!< FMC_T::ISPCMD: FOEN Mask */
N
N#define FMC_ISPCMD_FCEN_Pos                     4                                       /*!< FMC_T::ISPCMD: FCEN Position */
N#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)            /*!< FMC_T::ISPCMD: FCEN Mask */
N
N#define FMC_ISPCMD_FCTRL_Pos                    0                                       /*!< FMC_T::ISPCMD: FCTRL Position */
N#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)         /*!< FMC_T::ISPCMD: FCTRL Mask */
N
N/* FMC ISPTRG Bit Field Definitions */
N#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC_T::ISPTRG: ISPGO Position */
N#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC_T::ISPTRG: ISPGO Mask */
N
N/* FMC FATCON Bit Field Definitions */
N#define FMC_FATCON_LFOM_Pos                     4                                       /*!< FMC_T::FATCON: LFOM Position */
N#define FMC_FATCON_LFOM_Msk                     (1ul << FMC_FATCON_LFOM_Pos)            /*!< FMC_T::FATCON: LFOM Mask */
N
N/* FMC ISPSTA Bit Field Definitions */
N#define FMC_ISPSTA_ISPGO_Pos                    0                                       /*!< FMC_T::ISPSTA: ISPGO Position */
N#define FMC_ISPSTA_ISPGO_Msk                    (1ul << FMC_ISPSTA_ISPGO_Pos)           /*!< FMC_T::ISPSTA: ISPGO Mask */
N
N#define FMC_ISPSTA_CBS_Pos                      1                                       /*!< FMC_T::ISPSTA: CBS Position */
N#define FMC_ISPSTA_CBS_Msk                      (3ul << FMC_ISPSTA_CBS_Pos)             /*!< FMC_T::ISPSTA: CBS Mask */
N
N#define FMC_ISPSTA_ISPFF_Pos                    6                                       /*!< FMC_T::ISPSTA: ISPFF Position */
N#define FMC_ISPSTA_ISPFF_Msk                    (1ul << FMC_ISPSTA_ISPFF_Pos)           /*!< FMC_T::ISPSTA: ISPFF Mask */
N
N#define FMC_ISPSTA_VECMAP_Pos                   9                                       /*!< FMC_T::ISPSTA: VECMAP Position */
N#define FMC_ISPSTA_VECMAP_Msk                   (0xffful << FMC_ISPSTA_VECMAP_Pos)      /*!< FMC_T::ISPSTA: VECMAP Mask */
N/**@}*/ /* FMC_CONST */
N/**@}*/ /* FMC */
N
N
N/*--------------------- General Purpose Input and Output ---------------------*/
N/** @addtogroup GPIO General Purpose Input and Output(GPIO)
N  Memory Mapped Structure for General Purpose I/O
N  @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var GPIO_T::PMD
N * Offset: 0x00/0x40/0x80/0xC0/0x100  Port 0-4  I/O Mode Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2n+1:2n]|PMDn     |Determine each I/O mode of Px.n pins.
N * |        |          |00 = Px.n is in Input mode.
N * |        |          |01 = Px.n is in Push-pull Output mode.
N * |        |          |10 = Px.n is in Open-drain Output mode.
N * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N * |        |          |Note1: x = 0~4, n = 0~7.
N * |        |          |Note2: The default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip is powered on (only for M05xxBN).
N * |        |          |Note3: The initial value of this field is defined by CIOINI (CONFIG[10]) (only for M05xxDN/DE). 
N * |        |          |If CIOINI is set to 1, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on. 
N * |        |          |If CIOINI is set to 0, the default value is 0x0000_0000 and all pins will be input tri-state mode after chip powered on.        
N * @var GPIO_T::OFFD
N * Offset: 0x04/0x44/0x84/0xC4/0x104 Port 0-4 Digital Input Path Disable Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:16] |OFFD      |Port 0-4 Pin [n] Digital Input Path Disable Control
N * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. 
N * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N * |        |          |0 = Px.n digital input path Enabled.
N * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N * |        |          |Note: x = 0~4, n = 0~7.
N * @var GPIO_T::DOUT
N * Offset: 0x8/0x48/0x88/0xC8/0x108 Port 0-4 Data Output Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DOUT[n]   |Port 0-4 Pin [n] Output Value
N * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N * |        |          |Note: x = 0~4, n = 0~7.
N * @var GPIO_T::DMASK
N * Offset: 0x0C/0x4C/0x8C/0xCC/0x10C Port 0-4 Data Output Write Mask
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DMASK[n]  |Port 0-4 Pin [n] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding Px_DOUT[n] bit. When the DMASK[n] bit is set to 1, the corresponding Px_DOUT[n] bit is protected. 
N * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
N * |        |          |0 = Corresponding Px_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding Px_DOUT[n] bit protected.
N * |        |          |Note1: x = 0~4, n = 0~7.
N * |        |          |Note2: This function only protects the corresponding Px_DOUT[n] bit, and will not protect the corresponding Pxn_PDIO bit.
N * @var GPIO_T::PIN
N * Offset: 0x10/0x50/0x90/0xD0/0x110 Port 0-4 Pin Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PIN[n]    |Port 0-4 Pin [n] Pin Value
N * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N * |        |          |Note: x = 0~4, n = 0~7.
N * @var GPIO_T::DBEN
N * Offset: 0x14/0x54/0x94/0xD4/0x114 Port 0-4 De-bounce Enable
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |DBEN[n]   |Port 0-4 Pin [n] Input Signal De-bounce Enable Control
N * |        |          |DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].
N * |        |          |0 = Px.n de-bounce function Disabled.
N * |        |          |1 = Px.n de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note1: x = 0~4, n = 0~7.
N * |        |          |Note2: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.
N * @var GPIO_T::IMD
N * Offset: 0x18/0x58/0x98/0xD8/0x118 Port 0-4 Interrupt Mode Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |IMD[n]    |Port 0-4 Pin [n] Edge or Level Detection Interrupt Mode Control
N * |        |          |IMD[n] bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers Px_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: x = 0~4, n = 0~7.
N * @var GPIO_T::IEN
N * Offset: 0x1C/0x5C/0x9C/0xDC/0x11C Port 0-4 Interrupt Enable Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:16] |IR_EN[n]  |Port 0-4 Pin [n] Interrupt Enable by Input Rising Edge or Input Level High
N * |        |          |IR_EN[n] bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1 :
N * |        |          |If the interrupt is level trigger (IMD[n] is 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N * |        |          |If the interrupt is edge trigger (IMD[n] is 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N * |        |          |Note: x = 0~4, n = 0~7.
N * |[7:0]   |IF_EN[n]  |Port 0-4 Pin [n] Interrupt Enable by Input Falling Edge or Input Level Low
N * |        |          |IF_EN[n] bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1 :
N * |        |          |If the interrupt is level trigger (IMD[n] is 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N * |        |          |If the interrupt is edge trigger (IMD[n] is 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N * |        |          |Note: x = 0~4, n = 0~7.
N * @var GPIO_T::ISRC
N * Offset: 0x20/0x60/0xA0/0xE0/0x120 Port 0-4 Interrupt Trigger Source
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |ISRC[n]   |Port 0-4 Pin [n] Interrupt Source Flag
N * |        |          |Write :
N * |        |          |0 = No action.
N * |        |          |1 = Clear the corresponding pending interrupt.
N * |        |          |Read :
N * |        |          |0 = No interrupt at Px.n.
N * |        |          |1 = Px.n generates an interrupt.
N * |        |          |Note: x = 0~4, n = 0~7.
N */
N
N    __IO uint32_t PMD;           /* Offset: 0x00/0x40/0x80/0xC0/0x100 Port 0-4  I/O Mode Control                     */
X    volatile uint32_t PMD;            
N    __IO uint32_t OFFD;          /* Offset: 0x04/0x44/0x84/0xC4/0x104 Port 0-4 Digital Input Path Disable Control    */
X    volatile uint32_t OFFD;           
N    __IO uint32_t DOUT;          /* Offset: 0x08/0x48/0x88/0xC8/0x108 Port 0-4 Data Output Value                     */
X    volatile uint32_t DOUT;           
N    __IO uint32_t DMASK;         /* Offset: 0x0C/0x4C/0x8C/0xCC/0x10C Port 0-4 Data Output Write Mask                */
X    volatile uint32_t DMASK;          
N    __IO uint32_t PIN;           /* Offset: 0x10/0x50/0x90/0xD0/0x110 Port 0-4 Pin Value                             */
X    volatile uint32_t PIN;            
N    __IO uint32_t DBEN;          /* Offset: 0x14/0x54/0x94/0xD4/0x114 Port 0-4 De-bounce Enable                      */
X    volatile uint32_t DBEN;           
N    __IO uint32_t IMD;           /* Offset: 0x18/0x58/0x98/0xD8/0x118 Port 0-4 Interrupt Mode Control                */
X    volatile uint32_t IMD;            
N    __IO uint32_t IEN;           /* Offset: 0x1C/0x5C/0x9C/0xDC/0x11C Port 0-4 Interrupt Enable Control              */
X    volatile uint32_t IEN;            
N    __IO uint32_t ISRC;          /* Offset: 0x20/0x60/0xA0/0xE0/0x120 Port 0-4 Interrupt Trigger Source              */
X    volatile uint32_t ISRC;           
N
N} GPIO_T;
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var GPIO_DBNCECON_T::DBNCECON
N * Offset: 0x180 Interrupt De-bounce Cycle Control
N * ---------------------------------------------------------------------------------------------------    
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |DBCLKSEL  |De-bounce Sampling Cycle Selection
N * |        |          |0000 = Sample interrupt input once per 1 clocks.
N * |        |          |0001 = Sample interrupt input once per 2 clocks.
N * |        |          |0010 = Sample interrupt input once per 4 clocks.
N * |        |          |0011 = Sample interrupt input once per 8 clocks.
N * |        |          |0100 = Sample interrupt input once per 16 clocks.
N * |        |          |0101 = Sample interrupt input once per 32 clocks.
N * |        |          |0110 = Sample interrupt input once per 64 clocks.
N * |        |          |0111 = Sample interrupt input once per 128 clocks.
N * |        |          |1000 = Sample interrupt input once per 256 clocks.
N * |        |          |1001 = Sample interrupt input once per 2*256 clocks.
N * |        |          |1010 = Sample interrupt input once per 4*256 clocks.
N * |        |          |1011 = Sample interrupt input once per 8*256 clocks.
N * |        |          |1100 = Sample interrupt input once per 16*256 clocks.
N * |        |          |1101 = Sample interrupt input once per 32*256 clocks.
N * |        |          |1110 = Sample interrupt input once per 64*256 clocks.
N * |        |          |1111 = Sample interrupt input once per 128*256 clocks.
N * |[4]     |DBCLKSRC  |De-bounce Counter Clock Source Selection
N * |        |          |0 = De-bounce counter clock source is the HCLK.
N * |        |          |1 = De-bounce counter clock source is the 10 kHz internal low speed oscillator.
N * |[5]     |ICLK_ON   |Interrupt Clock On Mode
N * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding Px_IEN bit is set to 1.
N * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
N * |        |          |Note: It is recommended to turn off this bit to save system power if no special application concern.
N */
N
N    __IO uint32_t DBNCECON;      /* Offset: 0x180 Interrupt De-bounce Cycle Control                                  */
X    volatile uint32_t DBNCECON;       
N
N} GPIO_DBNCECON_T;
N
N
N
N
N/** @addtogroup GPIO_CONST GPIO Bit Field Definition
N  Constant Definitions for GPIO Controller
N  @{
N */
N
N/* GPIO PMD Bit Field Definitions */
N#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO_T::PMD: PMD7 Position */
N#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO_T::PMD: PMD7 Mask */
N
N#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO_T::PMD: PMD6 Position */
N#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO_T::PMD: PMD6 Mask */
N
N#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO_T::PMD: PMD5 Position */
N#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO_T::PMD: PMD5 Mask */
N
N#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO_T::PMD: PMD4 Position */
N#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO_T::PMD: PMD4 Mask */
N
N#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO_T::PMD: PMD3 Position */
N#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO_T::PMD: PMD3 Mask */
N
N#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO_T::PMD: PMD2 Position */
N#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO_T::PMD: PMD2 Mask */
N
N#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO_T::PMD: PMD1 Position */
N#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO_T::PMD: PMD1 Mask */
N
N#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO_T::PMD: PMD0 Position */
N#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO_T::PMD: PMD0 Mask */
N
N/* GPIO OFFD Bit Field Definitions */
N#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO_T::OFFD: OFFD Position */
N#define GPIO_OFFD_OFFD_Msk          (0xFFul << GPIO_OFFD_OFFD_Pos)              /*!< GPIO_T::OFFD: OFFD Mask */
N
N/* GPIO DOUT Bit Field Definitions */
N#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO_T::DOUT: DOUT Position */
N#define GPIO_DOUT_DOUT_Msk          (0xFFul << GPIO_DOUT_DOUT_Pos)              /*!< GPIO_T::DOUT: DOUT Mask */
N
N/* GPIO DMASK Bit Field Definitions */
N#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO_T::DMASK: DMASK Position */
N#define GPIO_DMASK_DMASK_Msk        (0xFFul << GPIO_DMASK_DMASK_Pos)            /*!< GPIO_T::DMASK: DMASK Mask */
N
N/* GPIO PIN Bit Field Definitions */
N#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO_T::PIN: PIN Position */
N#define GPIO_PIN_PIN_Msk            (0xFFul << GPIO_PIN_PIN_Pos)                /*!< GPIO_T::PIN: PIN Mask */
N
N/* GPIO DBEN Bit Field Definitions */
N#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO_T::DBEN: DBEN Position */
N#define GPIO_DBEN_DBEN_Msk          (0xFFul << GPIO_DBEN_DBEN_Pos)              /*!< GPIO_T::DBEN: DBEN Mask */
N
N/* GPIO IMD Bit Field Definitions */
N#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO_T::IMD: IMD Position */
N#define GPIO_IMD_IMD_Msk            (0xFFul << GPIO_IMD_IMD_Pos)                /*!< GPIO_T::IMD: IMD Mask */
N
N/* GPIO IEN Bit Field Definitions */
N#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO_T::IEN: IR_EN Position */
N#define GPIO_IEN_IR_EN_Msk          (0xFFul << GPIO_IEN_IR_EN_Pos)              /*!< GPIO_T::IEN: IR_EN Mask */
N
N#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO_T::IEN: IF_EN Position */
N#define GPIO_IEN_IF_EN_Msk          (0xFFul << GPIO_IEN_IF_EN_Pos)              /*!< GPIO_T::IEN: IF_EN Mask */
N
N/* GPIO ISRC Bit Field Definitions */
N#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO_T::ISRC: ISRC Position */
N#define GPIO_ISRC_ISRC_Msk          (0xFFul << GPIO_ISRC_ISRC_Pos)              /*!< GPIO_T::ISRC: ISRC Mask */
N
N/* GPIO DBNCECON Bit Field Definitions */
N#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON  Position */
N#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON  Mask */
N
N#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Position */
N#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Mask */
N
N#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Position */
N#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Mask */
N/**@}*/ /* GPIO_CONST */
N/**@}*/ /* GPIO */
N
N
N
N/*----------------------- Hardware Divider Interface Controller ------------------*/
N/** @addtogroup HDIV Hardware Divider(HDIV)
N  Memory Mapped Structure for Divider Interface Controller
N  @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var HDIV_T::DIVIDEND
N * Offset: 0x00  Dividend Source Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |DIVIDEND  |Dividend Source.
N * |        |          |This register is given the dividend of divider before calculation starts.
N * @var HDIV_T::DIVISOR
N * Offset: 0x04  Divisor Source Resister
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |DIVISOR   |Divisor Source.
N * |        |          |This register is given the divisor of divider before calculation starts.
N * |        |          |Note: when this register is written, hardware divider will start calculate
N * @var HDIV_T::DIVQUO
N * Offset: 0x08  Quotient Result Resister
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |QUOTIENT  |Quotient Result
N * |        |          |This register holds the quotient result of divider after calculation complete.
N * @var HDIV_T::DIVREM
N * Offset: 0x08  Reminder Result Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |QUOTIENT  |Reminder Result
N * |        |          |This register holds the reminder result of divider after calculation complete.
N * @var HDIV_T::DIVSTS
N * Offset: 0x08  Divider Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DIV_FINISH|Divider operation finished.
N * |        |          |0 = The divider calculation is not yet.
N * |        |          |1 = The divider calculation is finished.
N * |        |          |This register is read only.
N * |[1]     |DIV0      |Divisor zero warning.
N * |        |          |0 = The divisor is not 0.
N * |        |          |1 = The divisor is 0.
N * |        |          |This register is read only.
N */
N
N    __IO int32_t  DIVIDEND;      /* Offset: 0x00  Dividend Source Register                                           */
X    volatile int32_t  DIVIDEND;       
N    __IO int32_t  DIVISOR;       /* Offset: 0x04  Divisor Source Resister                                            */
X    volatile int32_t  DIVISOR;        
N    __IO int32_t  DIVQUO;        /* Offset: 0x08  Quotient Result Resister                                           */
X    volatile int32_t  DIVQUO;         
N    __IO int32_t  DIVREM;        /* Offset: 0x08  Reminder Result Register                                           */
X    volatile int32_t  DIVREM;         
N    __IO uint32_t DIVSTS;        /* Offset: 0x08  Divider Status Register                                            */
X    volatile uint32_t DIVSTS;         
N
N} HDIV_T;
N
N
N
N
N/** @addtogroup HDIV_CONST HDIV Bit Field Definition
N  Constant Definitions for HDIV Controller
N  @{
N */
N
N#define HDIV_DIVSTS_DIV_FINISH_Pos   0
N#define HDIV_DIVSTS_DIV_FINISH_Msk   (1ul << HDIV_DIVSTS_DIV_FINISH_Pos)
N
N#define HDIV_DIVSTS_DIV0_Pos         1
N#define HDIV_DIVSTS_DIV0_Msk         (1ul << HDIV_DIVSTS_DIV0_Pos)
N
N/**@}*/ /* HDIV_CONST */
N/**@}*/ /* DIV */
N
N
N
N/*------------------------------ I2C Controller ------------------------------*/
N
N/** @addtogroup I2C I2C Controller(I2C)
N  Memory Mapped Structure for I2C Serial Interface Controller
N  @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var I2C_T::I2CON
N * Offset: 0x00  I2C Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2]     |AA        |Assert Acknowledge control bit.
N * |        |          |When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during
N * |        |          |the acknowledge clock pulse on the SCL line when 
N * |        |          |1. A slave is acknowledging the address sent from master, 
N * |        |          |2. The receiver devices are acknowledging the data sent by transmitter. When AA=0 prior to
N * |        |          |address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge
N * |        |          |clock pulse on the SCL line.
N * |[3]     |SI        |I2C Interrupt Flag.
N * |        |          |When a new SIO state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI
N * |        |          |(I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing one
N * |        |          |to this bit.
N * |[4]     |STO       |I2C STOP Flag.
N * |        |          |In master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus
N * |        |          |condition if a STOP condition is detected this flag will be cleared by hardware automatically.
N * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means
N * |        |          |it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
N * |[5]     |STA       |I2C START Flag.
N * |        |          |Setting STA to logic 1 to enter master mode, the I2C hardware sends a START or repeat START condition
N * |        |          |to bus when the bus is free.
N * |[6]     |ENSI      |I2C controller is enabled/disable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |        |          |Set to enable I2C serial function block. When ENS=1 the I2C serial function enables. The multi-function
N * |        |          |pin function of SDA and SCL must set to I2C function first.
N * |[7]     |EI        |Enable interrupt.
N * |        |          |1 = Enable I2C interrupt.
N * |        |          |0 = Disable I2C interrupt.
N * @var I2C_T::I2CADDR0
N * Offset: 0x04  I2C Slave Address Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = Disable General Call Function.
N * |        |          |1 = Enable General Call Function.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven
N * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if
N * |        |          |either of the address is matched.
N * @var I2C_T::I2CDAT
N * Offset: 0x08  I2C Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |I2CDAT    |I2C Data Register
N * |        |          |Bit[7:0] is located with the 8-bit transferred data of I2C serial port.
N * @var I2C_T::I2CSTATUS
N * Offset: 0x0C  I2C Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |I2CSTATUS |I2C Status Register
N * |        |          |The status register of I2C:
N * |        |          |The three least significant bits are always 0. The five most significant bits contain the status code.
N * |        |          |There are 26 possible status codes. When I2STATUS contains F8H, no serial interrupt is
N * |        |          |requested. All other I2STATUS values correspond to defined I2C states. When each of these
N * |        |          |states is entered, a status interrupt is requested (SI = 1). A valid status code is present in
N * |        |          |I2STATUS one machine cycle after SI is set by hardware and is still present one machine cycle
N * |        |          |after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error
N * |        |          |occurs when a START or STOP condition is present at an illegal position in the formation frame.
N * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an
N * |        |          |acknowledge bit.
N * @var I2C_T::I2CLK
N * Offset: 0x10  I2C Clock Divided Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |I2CLK     |I2C clock divided Register
N * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x(I2CLK+1)).
N * @var I2C_T::I2CTOC
N * Offset: 0x14  I2C Time-Out Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TIF       |Time-Out flag.
N * |        |          |1 = Time-Out flag is set by H/W. It can interrupt CPU.
N * |        |          |0 = S/W can clear the flag.
N * |[1]     |DIV4      |Time-Out counter input clock is divider by 4
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |        |          |When Enable, The time-Out period is prolong 4 times.
N * |[2]     |ENTI      |Time-out counter is enabled/disable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |        |          |When Enable, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will
N * |        |          |reset counter and re-start up counting after SI is cleared.
N * @var I2C_T::I2CADDR1
N * Offset: 0x18  I2C Slave Address Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = Disable General Call Function.
N * |        |          |1 = Enable General Call Function.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven
N * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if
N * |        |          |either of the address is matched.
N * @var I2C_T::I2CADDR2
N * Offset: 0x1C  I2C Slave Address Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = Disable General Call Function.
N * |        |          |1 = Enable General Call Function.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven
N * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if
N * |        |          |either of the address is matched.
N * @var I2C_T::I2CADDR3
N * Offset: 0x20  I2C Slave Address Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = Disable General Call Function.
N * |        |          |1 = Enable General Call Function.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven
N * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if
N * |        |          |either of the address is matched.
N * @var I2C_T::I2CADM0
N * Offset: 0x24  I2C Slave Address Mask Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2ADMx    |I2C Address Mask register
N * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as address register.)
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received
N * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received
N * |        |          |corresponding register bit should be exact the same as address register.
N * @var I2C_T::I2CADM1
N * Offset: 0x28  I2C Slave Address Mask Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2ADMx    |I2C Address Mask register
N * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as address register.)
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received
N * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received
N * |        |          |corresponding register bit should be exact the same as address register.
N * @var I2C_T::I2CADM2
N * Offset: 0x2C  I2C Slave Address Mask Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2ADMx    |I2C Address Mask register
N * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as address register.)
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received
N * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received
N * |        |          |corresponding register bit should be exact the same as address register.
N * @var I2C_T::I2CADM3
N * Offset: 0x30  I2C Slave Address Mask Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2ADMx    |I2C Address Mask register
N * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as address register.)
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received
N * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received
N * |        |          |corresponding register bit should be exact the same as address register.
N * @var I2C_T::I2CWKUPCON
N * Offset: 0x3C  I2C Wake Up Control Register
N * ---------------------------------------------------------------------------------------------------
N * @var I2C_T::I2CWKUPSTS
N * Offset: 0x40  I2C Wake Up Status Register
N * ---------------------------------------------------------------------------------------------------
N */
N
N    __IO uint32_t I2CON;         /* Offset: 0x00  I2C Control Register                                               */
X    volatile uint32_t I2CON;          
N    __IO uint32_t I2CADDR0;      /* Offset: 0x04  I2C Slave Address Register 0                                       */
X    volatile uint32_t I2CADDR0;       
N    __IO uint32_t I2CDAT;        /* Offset: 0x08  I2C Data Register                                                  */
X    volatile uint32_t I2CDAT;         
N    __I  uint32_t I2CSTATUS;     /* Offset: 0x0C  I2C Status Register                                                */
X    volatile const  uint32_t I2CSTATUS;      
N    __IO uint32_t I2CLK;         /* Offset: 0x10  I2C Clock Divided Register                                         */
X    volatile uint32_t I2CLK;          
N    __IO uint32_t I2CTOC;        /* Offset: 0x14  I2C Time-Out Control Register                                      */
X    volatile uint32_t I2CTOC;         
N    __IO uint32_t I2CADDR1;      /* Offset: 0x18  I2C Slave Address Register 1                                       */
X    volatile uint32_t I2CADDR1;       
N    __IO uint32_t I2CADDR2;      /* Offset: 0x1C  I2C Slave Address Register 2                                       */
X    volatile uint32_t I2CADDR2;       
N    __IO uint32_t I2CADDR3;      /* Offset: 0x20  I2C Slave Address Register 3                                       */
X    volatile uint32_t I2CADDR3;       
N    __IO uint32_t I2CADM0;       /* Offset: 0x24  I2C Slave Address Mask Register 0                                  */
X    volatile uint32_t I2CADM0;        
N    __IO uint32_t I2CADM1;       /* Offset: 0x28  I2C Slave Address Mask Register 1                                  */
X    volatile uint32_t I2CADM1;        
N    __IO uint32_t I2CADM2;       /* Offset: 0x2C  I2C Slave Address Mask Register 2                                  */
X    volatile uint32_t I2CADM2;        
N    __IO uint32_t I2CADM3;       /* Offset: 0x30  I2C Slave Address Mask Register 3                                  */
X    volatile uint32_t I2CADM3;        
N    __I  uint32_t RESERVED0[2]; 
X    volatile const  uint32_t RESERVED0[2]; 
N    __IO uint32_t I2CWKUPCON;    /* Offset: 0x3C  I2C Wake Up Control Register                                       */
X    volatile uint32_t I2CWKUPCON;     
N    __IO uint32_t I2CWKUPSTS;    /* Offset: 0x40  I2C Wake Up Status Register                                        */
X    volatile uint32_t I2CWKUPSTS;     
N
N} I2C_T;
N
N
N
N/** @addtogroup I2C_CONST I2C Bit Field Definition
N  Constant Definitions for I2C Controller
N  @{
N */
N
N/* I2C I2CON Bit Field Definitions */
N#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C_T::I2CON: EI Position */
N#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C_T::I2CON: EI Mask */
N
N#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C_T::I2CON: ENS1 Position */
N#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C_T::I2CON: ENS1 Mask */
N
N#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C_T::I2CON: STA Position */
N#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C_T::I2CON: STA Mask */
N
N#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C_T::I2CON: STO Position */
N#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C_T::I2CON: STO Mask */
N
N#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C_T::I2CON: SI Position */
N#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C_T::I2CON: SI Mask */
N
N#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C_T::I2CON: AA Position */
N#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C_T::I2CON: AA Mask */
N
N/* I2C I2CADDR Bit Field Definitions */
N#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C_T::I2CADDR1: I2CADDR Position */
N#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C_T::I2CADDR1: I2CADDR Mask */
N
N#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C_T::I2CADDR1: GC Position */
N#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C_T::I2CADDR1: GC Mask */
N
N/* I2C I2CDAT Bit Field Definitions */
N#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C_T::I2CDAT: I2CDAT Position */
N#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C_T::I2CDAT: I2CDAT Mask */
N
N/* I2C I2CSTATUS Bit Field Definitions */
N#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C_T::I2CSTATUS: I2CSTATUS Position */
N#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C_T::I2CSTATUS: I2CSTATUS Mask */
N
N/* I2C I2CLK Bit Field Definitions */
N#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C_T::I2CLK: I2CLK Position */
N#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C_T::I2CLK: I2CLK Mask */
N
N/* I2C I2CTOC Bit Field Definitions */
N#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C_T::I2CTOC: ENTI Position */
N#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C_T::I2CTOC: ENTI Mask */
N
N#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C_T::I2CTOC: DIV4 Position */
N#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C_T::I2CTOC: DIV4 Mask */
N
N#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C_T::I2CTOC: TIF Position */
N#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C_T::I2CTOC: TIF Mask */
N
N/* I2C I2CADM Bit Field Definitions */
N#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C_T::I2CADM0: I2CADM Position */
N#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C_T::I2CADM0: I2CADM Mask */
N
N/* I2C I2CWKUPCON Bit Field Definitions */
N#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C_T::I2CWKUPCON: WKUPEN Position */
N#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C_T::I2CWKUPCON: WKUPEN Mask */
N
N/* I2C I2CWKUPSTS Bit Field Definitions */
N#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C_T::I2CWKUPSTS: WKUPIF Position */
N#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C_T::I2CWKUPSTS: WKUPIF Mask */
N
N/**@}*/ /* I2C_CONST */
N/**@}*/ /* I2C */
N
N
N
N/*----------------------------- PWM Controller -------------------------------*/
N
N/** @addtogroup PWM PWM Controller(PWM)
N  Memory Mapped Structure for PWM Generator and Capture Timer
N  @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var PWM_T::PPR
N * Offset: 0x00  PWM Pre-Scale Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CP01      |Clock pre-scalar 0(PWM counter 0 & 1 for group A and PWM counter 4 & 5 for group B)
N * |        |          |Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM counter
N * |        |          |If CP01=0, then the pre-scalar 0 output clock will be stopped. So corresponding PWM
N * |        |          |counter will be stopped also.
N * |[15:8]  |CP23      |Clock pre-scalar 2(PWM counter 2 & 3 for group A and PWM counter 6 & 7 for group B)
N * |        |          |Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM counter
N * |        |          |If CP23=0, then the pre-scalar 2 output clock will be stopped. So corresponding PWM
N * |        |          |counter will be stopped also.
N * |[23:16] |DZI01     |Dead zone interval register for pair of channel 0 and channel 1(PWM0 and PWM1 pair
N * |        |          |for PWM group A, PWM4 and PWM5 pair for PWM group B)
N * |        |          |These 8 bits determine dead zone length.
N * |        |          |The unit time of dead zone length is received from corresponding CSR bits.
N * |[31:24] |DZI23     |Dead zone interval register for pair of channel 2 and channel 3(PWM2 and PWM3 pair
N * |        |          |for PWM group A, PWM6 and PWM7 pair for PWM group B)
N * |        |          |These 8 bits determine dead zone length.
N * |        |          |The unit time of dead zone length is received from corresponding CSR bits.
N * @var PWM_T::CSR
N * Offset: 0x04  PWM Clock Source Divider Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |CSR0      |Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
N * |        |          |Select clock input for timer.
N * |        |          |(Table is the same as CSR3)
N * |[6:4]   |CSR1      |Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
N * |        |          |Select clock input for timer.
N * |        |          |(Table is the same as CSR3)
N * |[10:8]  |CSR2      |Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
N * |        |          |Select clock input for timer.
N * |        |          |(Table is the same as CSR3)
N * |[14:12] |CSR3      |Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
N * |        |          |Select clock input for timer.
N * |        |          |CSRx[2:0] = Input clock divider
N * |        |          |100 = 1
N * |        |          |011 = 16
N * |        |          |010 = 8
N * |        |          |001 = 4
N * |        |          |000 = 2
N * @var PWM_T::PCR
N * Offset: 0x08  PWM Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CH0EN     |PWM-Timer 0 Enable/Disable Start Run (PWM timer 0 for group A and PWM timer 4 for group B)
N * |        |          |1 = Enable corresponding PWM-Timer Start Run
N * |        |          |0 = Stop corresponding PWM-Timer Running
N * |[2]     |CH0INV    |PWM-Timer 0 Output Inverter ON/OFF(PWM timer 0 for group A and PWM timer 4 for group B)
N * |        |          |1 = Inverter ON
N * |        |          |0 = Inverter OFF
N * |[3]     |CH0MOD    |PWM-Timer 0 Auto-reload/One-Shot Mode(PWM timer 0 for group A and PWM timer 4
N * |        |          |for group B)
N * |        |          |1 = Auto-reload Mode
N * |        |          |0 = One-Shot Mode
N * |        |          |Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.
N * |[4]     |DZEN01    |Dead-Zone 0 Generator Enable/Disable(PWM0 and PWM1 pair for PWM group A,
N * |        |          |PWM4 and PWM5 pair for PWM group B)
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a
N * |        |          |complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a
N * |        |          |complementary pair for PWM group B.
N * |[5]     |DZEN23    |Dead-Zone 2 Generator Enable/Disable(PWM2 and PWM3 pair for PWM group A,
N * |        |          |PWM6 and PWM7 pair for PWM group B)
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a
N * |        |          |complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a
N * |        |          |complementary pair for PWM group B.
N * |[8]     |CH1EN     |PWM-Timer 1 Enable/Disable Start Run (PWM timer 1 for group A and PWM timer 5 for
N * |        |          |group B)
N * |        |          |1 = Enable corresponding PWM-Timer Start Run
N * |        |          |0 = Stop corresponding PWM-Timer Running
N * |[10]    |CH1INV    |PWM-Timer 1 Output Inverter ON/OFF(PWM timer 1 for group A and PWM timer 5 for
N * |        |          |group B)
N * |        |          |1 = Inverter ON
N * |        |          |0 = Inverter OFF
N * |[11]    |CH1MOD    |PWM-Timer 1 Auto-reload/One-Shot Mode(PWM timer 1 for group A and PWM timer 5
N * |        |          |for group B)
N * |        |          |1 = Auto-reload Mode
N * |        |          |0 = One-Shot Mode
N * |        |          |Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.
N * |[16]    |CH2EN     |PWM-Timer 2 Enable/Disable Start Run (PWM timer 2 for group A and PWM timer 6 for
N * |        |          |group B)
N * |        |          |1 = Enable corresponding PWM-Timer Start Run
N * |        |          |0 = Stop corresponding PWM-Timer Running
N * |[18]    |CH2INV    |PWM-Timer 2 Output Inverter ON/OFF(PWM timer 2 for group A and PWM timer 6 for
N * |        |          |group B)
N * |        |          |1 = Inverter ON
N * |        |          |0 = Inverter OFF
N * |[19]    |CH2MOD    |PWM-Timer 2 Auto-reload/One-Shot Mode(PWM timer 2 for group A and PWM timer 6
N * |        |          |for group B)
N * |        |          |1 = Auto-reload Mode
N * |        |          |0 = One-Shot Mode
N * |        |          |Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.
N * |[24]    |CH3EN     |PWM-Timer 3 Enable/Disable Start Run (PWM timer 3 for group A and PWM timer 7 for
N * |        |          |group B)
N * |        |          |1 = Enable corresponding PWM-Timer Start Run
N * |        |          |0 = Stop corresponding PWM-Timer Running
N * |[26]    |CH3INV    |PWM-Timer 3 Output Inverter ON/OFF(PWM timer 3 for group A and PWM timer 7 for
N * |        |          |group B)
N * |        |          |1 = Inverter ON
N * |        |          |0 = Inverter OFF
N * |[27]    |CH3MOD    |PWM-Timer 3 Auto-reload/One-Shot Mode(PWM timer 3 for group A and PWM timer 7
N * |        |          |for group B)
N * |        |          |1 = Auto-reload Mode
N * |        |          |0 = One-Shot Mode
N * |        |          |Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.
N * @var PWM_T::CNR0
N * Offset: 0x0C  PWM Counter 0/Timer 0 Loaded Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNR       |PWM Counter/Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |Duty ratio = (CMR+1)/(CNR+1).
N * |        |          |CMR >= CNR: PWM output is always high.
N * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
N * |        |          |(Unit = one PWM clock cycle)
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::CMR0
N * Offset: 0x10  PWM Comparator 0 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMR       |PWM Comparator Register
N * |        |          |CNR determines the PWM duty.
N * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |Duty ratio = (CMR+1)/(CNR+1).
N * |        |          |CMR >= CNR: PWM output is always high.
N * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
N * |        |          |(Unit = one PWM clock cycle)
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::PDR0
N * Offset: 0x14  PWM Data 0 Register(current counter 0 value)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDR       |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N * @var PWM_T::CNR1
N * Offset: 0x18  PWM Counter 1/Timer 1 Loaded Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNR       |PWM Counter/Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |Duty ratio = (CMR+1)/(CNR+1).
N * |        |          |CMR >= CNR: PWM output is always high.
N * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
N * |        |          |(Unit = one PWM clock cycle)
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::CMR1
N * Offset: 0x1C  PWM Comparator 1 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMR       |PWM Comparator Register
N * |        |          |CNR determines the PWM duty.
N * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |Duty ratio = (CMR+1)/(CNR+1).
N * |        |          |CMR >= CNR: PWM output is always high.
N * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
N * |        |          |(Unit = one PWM clock cycle)
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::PDR1
N * Offset: 0x20  PWM Data 1 Register(current counter 1 value)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDR       |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N * @var PWM_T::CNR2
N * Offset: 0x24  PWM Counter 2/Timer 2 Loaded Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNR       |PWM Counter/Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |Duty ratio = (CMR+1)/(CNR+1).
N * |        |          |CMR >= CNR: PWM output is always high.
N * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
N * |        |          |(Unit = one PWM clock cycle)
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::CMR2
N * Offset: 0x28  PWM Comparator 2 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMR       |PWM Comparator Register
N * |        |          |CNR determines the PWM duty.
N * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |Duty ratio = (CMR+1)/(CNR+1).
N * |        |          |CMR >= CNR: PWM output is always high.
N * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
N * |        |          |(Unit = one PWM clock cycle)
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::PDR2
N * Offset: 0x2C  PWM Data 2 Register(current counter 2 value)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDR       |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N * @var PWM_T::CNR3
N * Offset: 0x30  PWM Counter 3/Timer 3 Loaded Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNR       |PWM Counter/Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |Duty ratio = (CMR+1)/(CNR+1).
N * |        |          |CMR >= CNR: PWM output is always high.
N * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
N * |        |          |(Unit = one PWM clock cycle)
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::CMR3
N * Offset: 0x34  PWM Comparator 3 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMR       |PWM Comparator Register
N * |        |          |CNR determines the PWM duty.
N * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
N * |        |          |45 or 67, depends on selected PWM channel.
N * |        |          |Duty ratio = (CMR+1)/(CNR+1).
N * |        |          |CMR >= CNR: PWM output is always high.
N * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
N * |        |          |(Unit = one PWM clock cycle)
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::PDR3
N * Offset: 0x38  PWM Data 3 Register(current counter 3 value)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDR       |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N * @var PWM_T::PIER
N * Offset: 0x40  PWM Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWMIE0    |PWM channel 0 Interrupt Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |[1]     |PWMIE1    |PWM channel 1 Interrupt Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |[2]     |PWMIE2    |PWM channel 2 Interrupt Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * |[3]     |PWMIE3    |PWM channel 3 Interrupt Enable
N * |        |          |1 = Enable
N * |        |          |0 = Disable
N * @var PWM_T::PIIR
N * Offset: 0x44  PWM Interrupt Indication Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWMIF0    |PWM channel 0 Interrupt Status
N * |        |          |Flag is set by hardware when PWM0 down counter reaches zero, software can clear this
N * |        |          |bit by writing a one to it.
N * |[1]     |PWMIF1    |PWM channel 1 Interrupt Status
N * |        |          |Flag is set by hardware when PWM1 down counter reaches zero, software can clear this
N * |        |          |bit by writing a one to it.
N * |[2]     |PWMIF2    |PWM channel 2 Interrupt Status
N * |        |          |Flag is set by hardware when PWM2 down counter reaches zero, software can clear this
N * |        |          |bit by writing a one to it.
N * |[3]     |PWMIF3    |PWM channel 3 Interrupt Status
N * |        |          |Flag is set by hardware when PWM3 down counter reaches zero, software can clear this
N * |        |          |bit by writing a one to it.
N * @var PWM_T::CCR0
N * Offset: 0x50  Capture 0/1 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INV0      |PWM Group Channel 0 Inverter ON/OFF
N * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
N * |        |          |0 = Inverter OFF
N * |[1]     |CRL_IE0   |PWM Group Channel 0 Rising Latch Interrupt Enable ON/OFF
N * |        |          |1 = Enable rising latch interrupt
N * |        |          |0 = Disable rising latch interrupt
N * |        |          |When Enable, if Capture detects PWM group channel 0 has rising transition, Capture
N * |        |          |issues an Interrupt.
N * |[2]     |CFL_IE0   |PWM Group Channel 0 Falling Latch Interrupt Enable ON/OFF
N * |        |          |1 = Enable falling latch interrupt
N * |        |          |0 = Disable falling latch interrupt
N * |        |          |When Enable, if Capture detects PWM group channel 0 has falling transition, Capture
N * |        |          |issues an Interrupt.
N * |[3]     |CAPCH0EN  |Capture Channel 0 transition Enable/Disable
N * |        |          |1 = Enable capture function on PWM group channel 0.
N * |        |          |0 = Disable capture function on PWM group channel 0
N * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) 
N * |        |          |and CFLR (Falling latch).
N * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group
N * |        |          |channel 0 Interrupt.
N * |[4]     |CAPIF0    |Capture0 Interrupt Indication Flag
N * |        |          |If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs
N * |        |          |at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause
N * |        |          |CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1).
N * |        |          |This flag is clear by software with a write 1 to itself.
N * |[6]     |CRLRI0    |CRLR0 Latched Indicator Bit
N * |        |          |When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Clear this bit by writing a one to it.
N * |[7]     |CFLRI0    |CFLR0 Latched Indicator Bit
N * |        |          |When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Clear this bit by writing a one to it.
N * |[16]    |INV1      |PWM Group Channel 1 Inverter ON/OFF
N * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
N * |        |          |0 = Inverter OFF
N * |[17]    |CRL_IE1   |PWM Group Channel 1 Rising Latch Interrupt Enable ON/OFF
N * |        |          |1 = Enable rising latch interrupt
N * |        |          |0 = Disable rising latch interrupt
N * |        |          |When Enable, if Capture detects PWM group channel 1 has rising transition, Capture
N * |        |          |issues an Interrupt.
N * |[18]    |CFL_IE1   |PWM Group Channel 1 Falling Latch Interrupt Enable ON/OFF
N * |        |          |1 = Enable falling latch interrupt
N * |        |          |0 = Disable falling latch interrupt
N * |        |          |When Enable, if Capture detects PWM group channel 1 has falling transition, Capture
N * |        |          |issues an Interrupt.
N * |[19]    |CAPCH1EN  |Capture Channel 1 transition Enable/Disable
N * |        |          |1 = Enable capture function on PWM group channel 1.
N * |        |          |0 = Disable capture function on PWM group channel 1
N * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising
N * |        |          |latch) and CFLR (Falling latch).
N * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group
N * |        |          |channel 1 Interrupt.
N * |[20]    |CAPIF1    |Capture1 Interrupt Indication Flag
N * |        |          |If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs
N * |        |          |at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause
N * |        |          |CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1).
N * |        |          |This flag is clear by software with a write 1 to itself.
N * |[22]    |CRLRI1    |CRLR1 Latched Indicator Bit
N * |        |          |When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Clear this bit by writing a one to it.
N * |[23]    |CFLRI1    |CFLR1 Latched Indicator Bit
N * |        |          |When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Clear this bit by writing a one to it.
N * @var PWM_T::CCR2
N * Offset: 0x54  Capture 2/3 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INV2      |PWM Group Channel 2 Inverter ON/OFF
N * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
N * |        |          |0 = Inverter OFF
N * |[1]     |CRL_IE2   |PWM Group Channel 2 Rising Latch Interrupt Enable ON/OFF
N * |        |          |1 = Enable rising latch interrupt
N * |        |          |0 = Disable rising latch interrupt
N * |        |          |When Enable, if Capture detects PWM group channel 2 has rising transition, Capture
N * |        |          |issues an Interrupt.
N * |[2]     |CFL_IE2   |PWM Group Channel 2 Falling Latch Interrupt Enable ON/OFF
N * |        |          |1 = Enable falling latch interrupt
N * |        |          |0 = Disable falling latch interrupt
N * |        |          |When Enable, if Capture detects PWM group channel 2 has falling transition, Capture
N * |        |          |issues an Interrupt.
N * |[3]     |CAPCH2EN  |Capture Channel 2 transition Enable/Disable
N * |        |          |1 = Enable capture function on PWM group channel 2.
N * |        |          |0 = Disable capture function on PWM group channel 2
N * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising
N * |        |          |latch) and CFLR (Falling latch).
N * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group
N * |        |          |channel 2 Interrupt.
N * |[4]     |CAPIF2    |Capture2 Interrupt Indication Flag
N * |        |          |If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs
N * |        |          |at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause
N * |        |          |CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1).
N * |        |          |This flag is clear by software with a write 1 to itself.
N * |[6]     |CRLRI2    |CRLR2 Latched Indicator Bit
N * |        |          |When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Clear this bit by writing a one to it.
N * |[7]     |CFLRI2    |CFLR2 Latched Indicator Bit
N * |        |          |When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Clear this bit by writing a one to it.
N * |[16]    |INV3      |PWM Group Channel 3 Inverter ON/OFF
N * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
N * |        |          |0 = Inverter OFF
N * |[17]    |CRL_IE3   |PWM Group Channel 3 Rising Latch Interrupt Enable ON/OFF
N * |        |          |1 = Enable rising latch interrupt
N * |        |          |0 = Disable rising latch interrupt
N * |        |          |When Enable, if Capture detects PWM group channel 3 has rising transition, Capture
N * |        |          |issues an Interrupt.
N * |[18]    |CFL_IE3   |PWM Group Channel 3 Falling Latch Interrupt Enable ON/OFF
N * |        |          |1 = Enable falling latch interrupt
N * |        |          |0 = Disable falling latch interrupt
N * |        |          |When Enable, if Capture detects PWM group channel 3 has falling transition, Capture
N * |        |          |issues an Interrupt.
N * |[19]    |CAPCH3EN  |Capture Channel 3 transition Enable/Disable
N * |        |          |1 = Enable capture function on PWM group channel 3.
N * |        |          |0 = Disable capture function on PWM group channel 3
N * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising
N * |        |          |latch) and CFLR (Falling latch).
N * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group
N * |        |          |channel 3 Interrupt.
N * |[20]    |CAPIF3    |Capture3 Interrupt Indication Flag
N * |        |          |If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs
N * |        |          |at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause
N * |        |          |CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1).
N * |        |          |This flag is clear by software with a write 1 to itself.
N * |[22]    |CRLRI3    |CRLR3 Latched Indicator Bit
N * |        |          |When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Clear this bit by writing a one to it.
N * |[23]    |CFLRI3    |CFLR3 Latched Indicator Bit
N * |        |          |When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of
N * |        |          |PWM down-counter and this bit is set by hardware.
N * |        |          |Clear this bit by writing a one to it.
N * @var PWM_T::CRLR0
N * Offset: 0x58  Capture 0 Rising Latch Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLR      |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR0
N * Offset: 0x5C  Capture 0 Falling Latch Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLR      |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
N * @var PWM_T::CRLR1
N * Offset: 0x60  Capture 1 Rising Latch Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLR      |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR1
N * Offset: 0x64  Capture 1 Falling Latch Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLR      |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
N * @var PWM_T::CRLR2
N * Offset: 0x68  Capture 2 Rising Latch Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLR      |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR2
N * Offset: 0x6C  Capture 2 Falling Latch Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLR      |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N * @var PWM_T::CRLR3
N * Offset: 0x70  Capture 3 Rising Latch Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLR      |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR3
N * Offset: 0x74  Capture 3 Falling Latch Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLR      |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N * @var PWM_T::CAPENR
N * Offset: 0x78  Capture Input Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |CAPENR    |Capture Input Enable Register
N * |        |          |There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs ON or
N * |        |          |OFF.
N * |        |          |0 = OFF (PWMx multi-function pin input does not affect input capture function.)
N * |        |          |1 = (PWMx multi-function pin input will affect its input capture function.)
N * |        |          |CAPENR
N * |        |          |Bit 3210 for PWM group A
N * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [0]
N * |        |          |Bit xx1x -> Capture channel 1 is from P2 [1]
N * |        |          |Bit x1xx -> Capture channel 2 is from P2 [2]
N * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [3]
N * |        |          |Bit 3210 for PWM group B
N * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [4]
N * |        |          |Bit xx1x -> Capture channel 1 is from P2 [5]
N * |        |          |Bit x1xx -> Capture channel 2 is from P2 [6]
N * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [7]
N * @var PWM_T::POE
N * Offset: 0x7C  PWM Output Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWM0      |PWM Channel 0 Output Enable Register
N * |        |          |1 = Enable PWM channel 0 output to pin.
N * |        |          |0 = Disable PWM channel 0 output to pin.
N * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N * |[1]     |PWM1      |PWM Channel 1 Output Enable Register
N * |        |          |1 = Enable PWM channel 1 output to pin.
N * |        |          |0 = Disable PWM channel 1 output to pin.
N * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N * |[2]     |PWM2      |PWM Channel 2 Output Enable Register
N * |        |          |1 = Enable PWM channel 2 output to pin.
N * |        |          |0 = Disable PWM channel 2 output to pin.
N * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N * |[3]     |PWM3      |PWM Channel 3 Output Enable Register
N * |        |          |1 = Enable PWM channel 3 output to pin.
N * |        |          |0 = Disable PWM channel 3 output to pin.
N * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N * @var PWM_T::TCON
N * Offset: 0x80  PWM Trigger Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWM0PTEN  |Channel 0 PWM Period Trigger ADC Enable Register
N * |        |          |1 = Enable PWM channel 0 trigger ADC function
N * |        |          |0 = Disable PWM channel 0 trigger ADC function
N * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to underflow.
N * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
N * |        |          |when PWM counter up count to (CNR+1) or down count to underflow based on INT01PTYPE setting.
N * |        |          |1 = Enable PWM channel 0 output to pin.
N * |        |          |0 = Disable PWM channel 0 output to pin.
N * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N * |[1]     |PWM1PTEN  |Channel 1 PWM Period Trigger ADC Enable Register
N * |        |          |1 = Enable PWM channel 1 trigger ADC function
N * |        |          |0 = Disable PWM channel 1 trigger ADC function
N * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to underflow.
N * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
N * |        |          |when PWM counter up count to (CNR+1) or down count to underflow based on INT01PTYPE setting.
N * |[2]     |PWM2PTEN  |Channel 2 PWM Period Trigger ADC Enable Register
N * |        |          |1 = Enable PWM channel 2 trigger ADC function
N * |        |          |0 = Disable PWM channel 2 trigger ADC function
N * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to underflow.
N * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
N * |        |          |when PWM counter up count to (CNR+1) or down count to underflow based on INT23PTYPE setting.
N * |[3]     |PWM3PTEN  |Channel 3 PWM Period Trigger ADC Enable Register
N * |        |          |1 = Enable PWM channel 3 trigger ADC function
N * |        |          |0 = Disable PWM channel 3 trigger ADC function
N * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to underflow.
N * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
N * |        |          |when PWM counter up count to (CNR+1) or down count to underflow based on INT23PTYPE setting.
N * |[8]     |PWM0DTEN  |Channel 0 PWM Duty Trigger ADC Enable Register
N * |        |          |1 = Enable PWM channel 0 trigger ADC function
N * |        |          |0 = Disable PWM channel 0 trigger ADC function
N * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to match CMR.
N * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
N * |        |          |when PWM counter up count or down count to match CMR based on INT01DTYPE setting.
N * |[9]     |PWM1DTEN  |Channel 1 PWM Duty Trigger ADC Enable Register
N * |        |          |1 = Enable PWM channel 1 trigger ADC function
N * |        |          |0 = Disable PWM channel 1 trigger ADC function
N * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to match CMR.
N * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
N * |        |          |when PWM counter up count or down count to match CMR based on INT01DTYPE setting.
N * |[10]    |PWM2DTEN  |Channel 2 PWM Duty Trigger ADC Enable Register
N * |        |          |1 = Enable PWM channel 2 trigger ADC function
N * |        |          |0 = Disable PWM channel 2 trigger ADC function
N * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to match CMR.
N * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
N * |        |          |when PWM counter up count or down count to match CMR based on INT23DTYPE setting.
N * |[11]    |PWM3DTEN  |Channel 3 PWM Duty Trigger ADC Enable Register
N * |        |          |1 = Enable PWM channel 3 trigger ADC function
N * |        |          |0 = Disable PWM channel 3 trigger ADC function
N * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to match CMR.
N * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
N * |        |          |when PWM counter up count or down count to match CMR based on INT23DTYPE setting.
N * @var PWM_T::TSTATUS
N * Offset: 0x84  PWM Trigger Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWM0TF    |PWM Channel 0 Trigger ADC Flag
N * |        |          |This bit is set to 1 by hardware when PWM0 trigger ADC condition matched. As this bit is set to 1,
N * |        |          |ADC will start conversion if ADC triggered source is selected by PWM.
N * |        |          |Software can write 1 to clear this bit.
N * |[1]     |PWM1TF    |PWM Channel 1 Trigger ADC Flag
N * |        |          |This bit is set to 1 by hardware when PWM1 trigger ADC condition matched. As this bit is set to 1,
N * |        |          |ADC will start conversion if ADC triggered source is selected by PWM.
N * |        |          |Software can write 1 to clear this bit.
N * |[2]     |PWM2TF    |PWM Channel 2 Trigger ADC Flag
N * |        |          |This bit is set to 1 by hardware when PWM2 trigger ADC condition matched. As this bit is set to 1,
N * |        |          |ADC will start conversion if ADC triggered source is selected by PWM.
N * |        |          |Software can write 1 to clear this bit.
N * |[3]     |PWM3TF    |PWM Channel 3 Trigger ADC Flag
N * |        |          |This bit is set to 1 by hardware when PWM3 trigger ADC condition matched. As this bit is set to 1,
N * |        |          |ADC will start conversion if ADC triggered source is selected by PWM.
N * |        |          |Software can write 1 to clear this bit.
N * @var PWM_T::PSCR
N * Offset: 0x98  PWM Synchronous Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8]     |PSSEN1    |PWM1 Synchronous Start Enable
N * |        |          |1 = PWM1 synchronous start enable.
N * |        |          |0 = PWM1 synchronous start disable.
N * |        |          |If this bit is set to 1, PWM-Timer1 will synchronous start with PWM-Timer0 when SW writes 1 to PCR.CH0EN in PWM group A.
N * |[16]    |PSSEN2    |PWM2 Synchronous Start Enable
N * |        |          |1 = PWM2 synchronous start enable.
N * |        |          |0 = PWM2 synchronous start disable.
N * |        |          |If this bit is set to 1, PWM-Timer2 will synchronous start with PWM-Timer0 when SW writes 1 to PCR.CH0EN in PWM group A.
N * |[24]    |PSSEN3    |PWM3 Synchronous Start Enable
N * |        |          |1 = PWM3 synchronous start enable.
N * |        |          |0 = PWM3 synchronous start disable.
N * |        |          |If this bit is set to 1, PWM-Timer3 will synchronous start with PWM-Timer0 when SW writes 1 to PCR.CH0EN in PWM group A.
N */
N
N    __IO uint32_t PPR;           /* Offset: 0x00  PWM Pre-Scale Register                                             */
X    volatile uint32_t PPR;            
N    __IO uint32_t CSR;           /* Offset: 0x04  PWM Clock Source Divider Select Register                           */
X    volatile uint32_t CSR;            
N    __IO uint32_t PCR;           /* Offset: 0x08  PWM Control Register                                               */
X    volatile uint32_t PCR;            
N    __IO uint32_t CNR0;          /* Offset: 0x0C  PWM Counter 0/Timer 0 Loaded Value                                 */
X    volatile uint32_t CNR0;           
N    __IO uint32_t CMR0;          /* Offset: 0x10  PWM Comparator 0 Register                                          */
X    volatile uint32_t CMR0;           
N    __I  uint32_t PDR0;          /* Offset: 0x14  PWM Data 0 Register(current counter 0 value)                       */
X    volatile const  uint32_t PDR0;           
N    __IO uint32_t CNR1;          /* Offset: 0x18  PWM Counter 1/Timer 1 Loaded Value                                 */
X    volatile uint32_t CNR1;           
N    __IO uint32_t CMR1;          /* Offset: 0x1C  PWM Comparator 1 Register                                          */
X    volatile uint32_t CMR1;           
N    __I  uint32_t PDR1;          /* Offset: 0x20  PWM Data 1 Register(current counter 1 value)                       */
X    volatile const  uint32_t PDR1;           
N    __IO uint32_t CNR2;          /* Offset: 0x24  PWM Counter 2/Timer 2 Loaded Value                                 */
X    volatile uint32_t CNR2;           
N    __IO uint32_t CMR2;          /* Offset: 0x28  PWM Comparator 2 Register                                          */
X    volatile uint32_t CMR2;           
N    __I  uint32_t PDR2;          /* Offset: 0x2C  PWM Data 2 Register(current counter 2 value)                       */
X    volatile const  uint32_t PDR2;           
N    __IO uint32_t CNR3;          /* Offset: 0x30  PWM Counter 3/Timer 3 Loaded Value                                 */
X    volatile uint32_t CNR3;           
N    __IO uint32_t CMR3;          /* Offset: 0x34  PWM Comparator 3 Register                                          */
X    volatile uint32_t CMR3;           
N    __I  uint32_t PDR3;          /* Offset: 0x38  PWM Data 3 Register(current counter 3 value)                       */
X    volatile const  uint32_t PDR3;           
N    __I  uint32_t RESERVE0;     
X    volatile const  uint32_t RESERVE0;     
N    __IO uint32_t PIER;          /* Offset: 0x40  PWM Interrupt Enable Register                                      */
X    volatile uint32_t PIER;           
N    __IO uint32_t PIIR;          /* Offset: 0x44  PWM Interrupt Indication Register                                  */
X    volatile uint32_t PIIR;           
N    __I  uint32_t RESERVE1[2];  
X    volatile const  uint32_t RESERVE1[2];  
N    __IO uint32_t CCR0;          /* Offset: 0x50  Capture 0/1 Control Register                                       */
X    volatile uint32_t CCR0;           
N    __IO uint32_t CCR2;          /* Offset: 0x54  Capture 2/3 Control Register                                       */
X    volatile uint32_t CCR2;           
N    __IO uint32_t CRLR0;         /* Offset: 0x58  Capture 0 Rising Latch Register                                    */
X    volatile uint32_t CRLR0;          
N    __IO uint32_t CFLR0;         /* Offset: 0x5C  Capture 0 Falling Latch Register                                   */
X    volatile uint32_t CFLR0;          
N    __IO uint32_t CRLR1;         /* Offset: 0x60  Capture 1 Rising Latch Register                                    */
X    volatile uint32_t CRLR1;          
N    __IO uint32_t CFLR1;         /* Offset: 0x64  Capture 1 Falling Latch Register                                   */
X    volatile uint32_t CFLR1;          
N    __IO uint32_t CRLR2;         /* Offset: 0x68  Capture 2 Rising Latch Register                                    */
X    volatile uint32_t CRLR2;          
N    __IO uint32_t CFLR2;         /* Offset: 0x6C  Capture 2 Falling Latch Register                                   */
X    volatile uint32_t CFLR2;          
N    __IO uint32_t CRLR3;         /* Offset: 0x70  Capture 3 Rising Latch Register                                    */
X    volatile uint32_t CRLR3;          
N    __IO uint32_t CFLR3;         /* Offset: 0x74  Capture 3 Falling Latch Register                                   */
X    volatile uint32_t CFLR3;          
N    __IO uint32_t CAPENR;        /* Offset: 0x78  Capture Input Enable Register                                      */
X    volatile uint32_t CAPENR;         
N    __IO uint32_t POE;           /* Offset: 0x7C  PWM Output Enable Register                                         */
X    volatile uint32_t POE;            
N    __IO uint32_t TCON;          /* Offset: 0x80  PWM Trigger Control Register                                       */
X    volatile uint32_t TCON;           
N    __IO uint32_t TSTATUS;       /* Offset: 0x84  PWM Trigger Status Register                                        */
X    volatile uint32_t TSTATUS;        
N    __I  uint32_t RESERVE2[4];  
X    volatile const  uint32_t RESERVE2[4];  
N    __IO uint32_t PSCR;          /* Offset: 0x98  PWM Synchronous Control Register                                   */
X    volatile uint32_t PSCR;           
N
N} PWM_T;
N
N
N
N/** @addtogroup PWM_CONST PWM Bit Field Definition
N  Constant Definitions for PWM Controller
N  @{
N */
N
N/* PWM PPR Bit Field Definitions */
N#define PWM_PPR_DZI23_Pos                       24                                  /*!< PWM_T::PPR: DZI23 Position */
N#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)       /*!< PWM_T::PPR: DZI23 Mask */
N
N#define PWM_PPR_DZI01_Pos                       16                                  /*!< PWM_T::PPR: DZI01 Position */
N#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)       /*!< PWM_T::PPR: DZI01 Mask */
N
N#define PWM_PPR_CP23_Pos                        8                                   /*!< PWM_T::PPR: CP23 Position */
N#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)        /*!< PWM_T::PPR: CP23 Mask */
N
N#define PWM_PPR_CP01_Pos                        0                                   /*!< PWM_T::PPR: CP01 Position */
N#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)        /*!< PWM_T::PPR: CP01 Mask */
N
N/* PWM CSR Bit Field Definitions */
N#define PWM_CSR_CSR3_Pos                        12                                  /*!< PWM_T::CSR: CSR3 Position */
N#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)           /*!< PWM_T::CSR: CSR3 Mask */
N
N#define PWM_CSR_CSR2_Pos                        8                                   /*!< PWM_T::CSR: CSR2 Position */
N#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)           /*!< PWM_T::CSR: CSR2 Mask */
N
N#define PWM_CSR_CSR1_Pos                        4                                   /*!< PWM_T::CSR: CSR1 Position */
N#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)           /*!< PWM_T::CSR: CSR1 Mask */
N
N#define PWM_CSR_CSR0_Pos                        0                                   /*!< PWM_T::CSR: CSR0 Position */
N#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)           /*!< PWM_T::CSR: CSR0 Mask */
N
N/* PWM PCR Bit Field Definitions */
N#define PWM_PCR_PWM23TYPE_Pos                   31                                  /*!< PWM_T::PCR: PWM23TYPE Position */
N#define PWM_PCR_PWM23TYPE_Msk                   (1ul << PWM_PCR_PWM23TYPE_Pos)      /*!< PWM_T::PCR: PWM23TYPE Mask */
N
N#define PWM_PCR_PWM01TYPE_Pos                   30                                  /*!< PWM_T::PCR: PWM01TYPE Position */
N#define PWM_PCR_PWM01TYPE_Msk                   (1ul << PWM_PCR_PWM01TYPE_Pos)      /*!< PWM_T::PCR: PWM01TYPE Mask */
N
N#define PWM_PCR_CH3MOD_Pos                      27                                  /*!< PWM_T::PCR: CH3MOD Position */
N#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)         /*!< PWM_T::PCR: CH3MOD Mask */
N
N#define PWM_PCR_CH3INV_Pos                      26                                  /*!< PWM_T::PCR: CH3INV Position */
N#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)         /*!< PWM_T::PCR: CH3INV Mask */
N
N#define PWM_PCR_CH3PINV_Pos                     25                                  /*!< PWM_T::PCR: CH3PINV Position */
N#define PWM_PCR_CH3PINV_Msk                     (1ul << PWM_PCR_CH3PINV_Pos)        /*!< PWM_T::PCR: CH3PINV Mask */
N
N#define PWM_PCR_CH3EN_Pos                       24                                  /*!< PWM_T::PCR: CH3EN Position */
N#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)          /*!< PWM_T::PCR: CH3EN Mask */
N
N#define PWM_PCR_CH2MOD_Pos                      19                                  /*!< PWM_T::PCR: CH2MOD Position */
N#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)         /*!< PWM_T::PCR: CH2MOD Mask */
N
N#define PWM_PCR_CH2INV_Pos                      18                                  /*!< PWM_T::PCR: CH2INV Position */
N#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)         /*!< PWM_T::PCR: CH2INV Mask */
N
N#define PWM_PCR_CH2PINV_Pos                     17                                  /*!< PWM_T::PCR: CH2PINV Position */
N#define PWM_PCR_CH2PINV_Msk                     (1ul << PWM_PCR_CH2PINV_Pos)        /*!< PWM_T::PCR: CH2PINV Mask */
N
N#define PWM_PCR_CH2EN_Pos                       16                                  /*!< PWM_T::PCR: CH2EN Position */
N#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)          /*!< PWM_T::PCR: CH2EN Mask */
N
N#define PWM_PCR_CH1MOD_Pos                      11                                  /*!< PWM_T::PCR: CH1MOD Position */
N#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)         /*!< PWM_T::PCR: CH1MOD Mask */
N
N#define PWM_PCR_CH1INV_Pos                      10                                  /*!< PWM_T::PCR: CH1INV Position */
N#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)         /*!< PWM_T::PCR: CH1INV Mask */
N
N#define PWM_PCR_CH1PINV_Pos                     9                                   /*!< PWM_T::PCR: CH1PINV Position */
N#define PWM_PCR_CH1PINV_Msk                     (1ul << PWM_PCR_CH1PINV_Pos)        /*!< PWM_T::PCR: CH1PINV Mask */
N
N#define PWM_PCR_CH1EN_Pos                       8                                   /*!< PWM_T::PCR: CH1EN Position */
N#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)          /*!< PWM_T::PCR: CH1EN Mask */
N
N#define PWM_PCR_DZEN23_Pos                      5                                   /*!< PWM_T::PCR: DZEN23 Position */
N#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)         /*!< PWM_T::PCR: DZEN23 Mask */
N
N#define PWM_PCR_DZEN01_Pos                      4                                   /*!< PWM_T::PCR: DZEN01 Position */
N#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)         /*!< PWM_T::PCR: DZEN01 Mask */
N
N#define PWM_PCR_CH0MOD_Pos                      3                                   /*!< PWM_T::PCR: CH0MOD Position */
N#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)         /*!< PWM_T::PCR: CH0MOD Mask */
N
N#define PWM_PCR_CH0INV_Pos                      2                                   /*!< PWM_T::PCR: CH0INV Position */
N#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)         /*!< PWM_T::PCR: CH0INV Mask */
N
N#define PWM_PCR_CH0PINV_Pos                      1                                  /*!< PWM_T::PCR: CH0PINV Position */
N#define PWM_PCR_CH0PINV_Msk                     (1ul << PWM_PCR_CH0PINV_Pos)        /*!< PWM_T::PCR: CH0PINV Mask */
N
N#define PWM_PCR_CH0EN_Pos                       0                                   /*!< PWM_T::PCR: CH0EN Position */
N#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM_T::PCR: CH0EN Mask */
N
N/* PWM CNR Bit Field Definitions */
N#define PWM_CNR_CNR_Pos                         0                                   /*!< PWM_T::CNR0: CNR Position */
N#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)       /*!< PWM_T::CNR0: CNR Mask */
N
N/* PWM CMR Bit Field Definitions */
N#define PWM_CMR_CMR_Pos                         0                                   /*!< PWM_T::CMR0: CMR Position */
N#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)       /*!< PWM_T::CMR0: CMR Mask */
N
N/* PWM PDR Bit Field Definitions */
N#define PWM_PDR_PDR_Pos                         0                                   /*!< PWM_T::PDR0: PDR Position */
N#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)       /*!< PWM_T::PDR0: PDR Mask */
N
N
N/* PWM PIER Bit Field Definitions */
N#define PWM_PIER_INT23DTYPE_Pos                 25                                  /*!< PWM_T::PIER: INT23DTYPE Position */
N#define PWM_PIER_INT23DTYPE_Msk                 (1ul << PWM_PIER_INT23DTYPE_Pos)    /*!< PWM_T::PIER: INT23DTYPE Mask */
N
N#define PWM_PIER_INT01DTYPE_Pos                 24                                  /*!< PWM_T::PIER: INT01DTYPE Position */
N#define PWM_PIER_INT01DTYPE_Msk                 (1ul << PWM_PIER_INT01DTYPE_Pos)    /*!< PWM_T::PIER: INT01DTYPE Mask */
N
N#define PWM_PIER_INT23TYPE_Pos                  17                                  /*!< PWM_T::PIER: INT23TYPE Position */
N#define PWM_PIER_INT23TYPE_Msk                  (1ul << PWM_PIER_INT23TYPE_Pos)     /*!< PWM_T::PIER: INT23TYPE Mask */
N
N#define PWM_PIER_INT01TYPE_Pos                  16                                  /*!< PWM_T::PIER: INT01TYPE Position */
N#define PWM_PIER_INT01TYPE_Msk                  (1ul << PWM_PIER_INT01TYPE_Pos)     /*!< PWM_T::PIER: INT01TYPE Mask */
N
N#define PWM_PIER_PWMDIE3_Pos                    11                                  /*!< PWM_T::PIER: PWMDIE3 Position */
N#define PWM_PIER_PWMDIE3_Msk                    (1ul << PWM_PIER_PWMDIE3_Pos)       /*!< PWM_T::PIER: PWMDIE3 Mask */
N
N#define PWM_PIER_PWMDIE2_Pos                    10                                  /*!< PWM_T::PIER: PWMDIE2 Position */
N#define PWM_PIER_PWMDIE2_Msk                    (1ul << PWM_PIER_PWMDIE2_Pos)       /*!< PWM_T::PIER: PWMDIE2 Mask */
N
N#define PWM_PIER_PWMDIE1_Pos                    9                                   /*!< PWM_T::PIER: PWMDIE1 Position */
N#define PWM_PIER_PWMDIE1_Msk                     (1ul << PWM_PIER_PWMDIE1_Pos)      /*!< PWM_T::PIER: PWMDIE1 Mask */
N
N#define PWM_PIER_PWMDIE0_Pos                    8                                   /*!< PWM_T::PIER: PWMDIE0 Position */
N#define PWM_PIER_PWMDIE0_Msk                    (1ul << PWM_PIER_PWMDIE0_Pos)       /*!< PWM_T::PIER: PWMDIE0 Mask */
N
N#define PWM_PIER_PWMIE3_Pos                     3                                   /*!< PWM_T::PIER: PWMIE3 Position */
N#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)        /*!< PWM_T::PIER: PWMIE3 Mask */
N
N#define PWM_PIER_PWMIE2_Pos                     2                                   /*!< PWM_T::PIER: PWMIE2 Position */
N#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)        /*!< PWM_T::PIER: PWMIE2 Mask */
N
N#define PWM_PIER_PWMIE1_Pos                     1                                   /*!< PWM_T::PIER: PWMIE1 Position */
N#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)        /*!< PWM_T::PIER: PWMIE1 Mask */
N
N#define PWM_PIER_PWMIE0_Pos                     0                                   /*!< PWM_T::PIER: PWMIE0 Position */
N#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)        /*!< PWM_T::PIER: PWMIE0 Mask */
N
N/* PWM PIIR Bit Field Definitions */
N#define PWM_PIIR_PWMDIF3_Pos                    11                                  /*!< PWM_T::PIIR: PWMDIF3 Position */
N#define PWM_PIIR_PWMDIF3_Msk                    (1ul << PWM_PIIR_PWMDIF3_Pos)       /*!< PWM_T::PIIR: PWMDIF3 Mask */
N
N#define PWM_PIIR_PWMDIF2_Pos                    10                                  /*!< PWM_T::PIIR: PWMDIF2 Position */
N#define PWM_PIIR_PWMDIF2_Msk                    (1ul << PWM_PIIR_PWMDIF2_Pos)       /*!< PWM_T::PIIR: PWMDIF2 Mask */
N
N#define PWM_PIIR_PWMDIF1_Pos                    9                                   /*!< PWM_T::PIIR: PWMDIF1 Position */
N#define PWM_PIIR_PWMDIF1_Msk                    (1ul << PWM_PIIR_PWMDIF1_Pos)       /*!< PWM_T::PIIR: PWMDIF1 Mask */
N
N#define PWM_PIIR_PWMDIF0_Pos                    8                                   /*!< PWM_T::PIIR: PWMDIF0 Position */
N#define PWM_PIIR_PWMDIF0_Msk                    (1ul << PWM_PIIR_PWMDIF0_Pos)       /*!< PWM_T::PIIR: PWMDIF0 Mask */
N
N#define PWM_PIIR_PWMIF3_Pos                     3                                   /*!< PWM_T::PIIR: PWMIF3 Position */
N#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)        /*!< PWM_T::PIIR: PWMIF3 Mask */
N
N#define PWM_PIIR_PWMIF2_Pos                     2                                   /*!< PWM_T::PIIR: PWMIF2 Position */
N#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)        /*!< PWM_T::PIIR: PWMIF2 Mask */
N
N#define PWM_PIIR_PWMIF1_Pos                     1                                   /*!< PWM_T::PIIR: PWMIF1 Position */
N#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)        /*!< PWM_T::PIIR: PWMIF1 Mask */
N
N#define PWM_PIIR_PWMIF0_Pos                     0                                   /*!< PWM_T::PIIR: PWMIF0 Position */
N#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)        /*!< PWM_T::PIIR: PWMIF0 Mask */
N
N/* PWM CCR0 Bit Field Definitions */
N#define PWM_CCR0_CFLRI1_Pos                     23                                  /*!< PWM_T::CCR0: CFLRI1 Position */
N#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)        /*!< PWM_T::CCR0: CFLRI1 Mask */
N
N#define PWM_CCR0_CRLRI1_Pos                     22                                  /*!< PWM_T::CCR0: CRLRI1 Position */
N#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)        /*!< PWM_T::CCR0: CRLRI1 Mask */
N
N#define PWM_CCR0_CAPIF1_Pos                     20                                  /*!< PWM_T::CCR0: CAPIF1 Position */
N#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)        /*!< PWM_T::CCR0: CAPIF1 Mask */
N
N#define PWM_CCR0_CAPCH1EN_Pos                   19                                  /*!< PWM_T::CCR0: CAPCH1EN Position */
N#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)      /*!< PWM_T::CCR0: CAPCH1EN Mask */
N
N#define PWM_CCR0_CFL_IE1_Pos                    18                                  /*!< PWM_T::CCR0: CFL_IE1 Position */
N#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)       /*!< PWM_T::CCR0: CFL_IE1 Mask */
N
N#define PWM_CCR0_CRL_IE1_Pos                    17                                  /*!< PWM_T::CCR0: CRL_IE1 Position */
N#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)       /*!< PWM_T::CCR0: CRL_IE1 Mask */
N
N#define PWM_CCR0_INV1_Pos                       16                                  /*!< PWM_T::CCR0: INV1 Position */
N#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)          /*!< PWM_T::CCR0: INV1 Mask */
N
N#define PWM_CCR0_CFLRI0_Pos                     7                                   /*!< PWM_T::CCR0: CFLRI0 Position */
N#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)        /*!< PWM_T::CCR0: CFLRI0 Mask */
N
N#define PWM_CCR0_CRLRI0_Pos                     6                                   /*!< PWM_T::CCR0: CRLRI0 Position */
N#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)        /*!< PWM_T::CCR0: CRLRI0 Mask */
N
N#define PWM_CCR0_CAPIF0_Pos                     4                                   /*!< PWM_T::CCR0: CAPIF0 Position */
N#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)        /*!< PWM_T::CCR0: CAPIF0 Mask */
N
N#define PWM_CCR0_CAPCH0EN_Pos                   3                                   /*!< PWM_T::CCR0: CAPCH0EN Position */
N#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)      /*!< PWM_T::CCR0: CAPCH0EN Mask */
N
N#define PWM_CCR0_CFL_IE0_Pos                    2                                   /*!< PWM_T::CCR0: CFL_IE0 Position */
N#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)       /*!< PWM_T::CCR0: CFL_IE0 Mask */
N
N#define PWM_CCR0_CRL_IE0_Pos                    1                                   /*!< PWM_T::CCR0: CRL_IE0 Position */
N#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)       /*!< PWM_T::CCR0: CRL_IE0 Mask */
N
N#define PWM_CCR0_INV0_Pos                       0                                   /*!< PWM_T::CCR0: INV0 Position */
N#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)          /*!< PWM_T::CCR0: INV0 Mask */
N
N/* PWM CCR2 Bit Field Definitions */
N#define PWM_CCR2_CFLRI3_Pos                     23                                  /*!< PWM_T::CCR2: CFLRI3 Position */
N#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)        /*!< PWM_T::CCR2: CFLRI3 Mask */
N
N#define PWM_CCR2_CRLRI3_Pos                     22                                  /*!< PWM_T::CCR2: CRLRI3 Position */
N#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)        /*!< PWM_T::CCR2: CRLRI3 Mask */
N
N#define PWM_CCR2_CAPIF3_Pos                     20                                  /*!< PWM_T::CCR2: CAPIF3 Position */
N#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)        /*!< PWM_T::CCR2: CAPIF3 Mask */
N
N#define PWM_CCR2_CAPCH3EN_Pos                   19                                  /*!< PWM_T::CCR2: CAPCH3EN Position */
N#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)      /*!< PWM_T::CCR2: CAPCH3EN Mask */
N
N#define PWM_CCR2_CFL_IE3_Pos                    18                                  /*!< PWM_T::CCR2: CFL_IE3 Position */
N#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)       /*!< PWM_T::CCR2: CFL_IE3 Mask */
N
N#define PWM_CCR2_CRL_IE3_Pos                    17                                  /*!< PWM_T::CCR2: CRL_IE3 Position */
N#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)       /*!< PWM_T::CCR2: CRL_IE3 Mask */
N
N#define PWM_CCR2_INV3_Pos                       16                                  /*!< PWM_T::CCR2: INV3 Position */
N#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)          /*!< PWM_T::CCR2: INV3 Mask */
N
N#define PWM_CCR2_CFLRI2_Pos                     7                                   /*!< PWM_T::CCR2: CFLRI2 Position */
N#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)        /*!< PWM_T::CCR2: CFLRI2 Mask */
N
N#define PWM_CCR2_CRLRI2_Pos                     6                                   /*!< PWM_T::CCR2: CRLRI2 Position */
N#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)        /*!< PWM_T::CCR2: CRLRI2 Mask */
N
N#define PWM_CCR2_CAPIF2_Pos                     4                                   /*!< PWM_T::CCR2: CAPIF2 Position */
N#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)        /*!< PWM_T::CCR2: CAPIF2 Mask */
N
N#define PWM_CCR2_CAPCH2EN_Pos                   3                                   /*!< PWM_T::CCR2: CAPCH2EN Position */
N#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)      /*!< PWM_T::CCR2: CAPCH2EN Mask */
N
N#define PWM_CCR2_CFL_IE2_Pos                    2                                   /*!< PWM_T::CCR2: CFL_IE2 Position */
N#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)       /*!< PWM_T::CCR2: CFL_IE2 Mask */
N
N#define PWM_CCR2_CRL_IE2_Pos                    1                                   /*!< PWM_T::CCR2: CRL_IE2 Position */
N#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)       /*!< PWM_T::CCR2: CRL_IE2 Mask */
N
N#define PWM_CCR2_INV2_Pos                       0                                   /*!< PWM_T::CCR2: INV2 Position */
N#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)          /*!< PWM_T::CCR2: INV2 Mask */
N
N/* PWM CRLR Bit Field Definitions */
N#define PWM_CRLR_CRLR_Pos                       0                                   /*!< PWM_T::CRLR0: CRLR Position */
N#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)     /*!< PWM_T::CRLR0: CRLR Mask */
N
N/* PWM CFLR Bit Field Definitions */
N#define PWM_CFLR_CFLR_Pos                       0                                   /*!< PWM_T::CFLR0: CFLR Position */
N#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)     /*!< PWM_T::CFLR0: CFLR Mask */
N
N/* PWM CAPENR Bit Field Definitions */
N#define PWM_CAPENR_CINEN3_Pos                   3                                   /*!< PWM_T::CAPENR: CINEN3 Position */
N#define PWM_CAPENR_CINEN3_Msk                   (1ul << PWM_CAPENR_CINEN3_Pos)      /*!< PWM_T::CAPENR: CINEN3 Mask */
N
N#define PWM_CAPENR_CINEN2_Pos                   2                                   /*!< PWM_T::CAPENR: CINEN2 Position */
N#define PWM_CAPENR_CINEN2_Msk                   (1ul << PWM_CAPENR_CINEN2_Pos)      /*!< PWM_T::CAPENR: CINEN2 Mask */
N
N#define PWM_CAPENR_CINEN1_Pos                   1                                   /*!< PWM_T::CAPENR: CINEN1 Position */
N#define PWM_CAPENR_CINEN1_Msk                   (1ul << PWM_CAPENR_CINEN1_Pos)      /*!< PWM_T::CAPENR: CINEN1 Mask */
N
N#define PWM_CAPENR_CINEN0_Pos                   0                                   /*!< PWM_T::CAPENR: CINEN0 Position */
N#define PWM_CAPENR_CINEN0_Msk                   (1ul << PWM_CAPENR_CINEN0_Pos)      /*!< PWM_T::CAPENR: CINEN0 Mask */
N
N/* PWM POE Bit Field Definitions */
N#define PWM_POE_PWM3_Pos                        3                                   /*!< PWM_T::POE: POE3 Position */
N#define PWM_POE_PWM3_Msk                        (1ul << PWM_POE_PWM3_Pos)           /*!< PWM_T::POE: POE3 Mask */
N
N#define PWM_POE_PWM2_Pos                        2                                   /*!< PWM_T::POE: POE2 Position */
N#define PWM_POE_PWM2_Msk                        (1ul << PWM_POE_PWM2_Pos)           /*!< PWM_T::POE: POE2 Mask */
N
N#define PWM_POE_PWM1_Pos                        1                                   /*!< PWM_T::POE: POE1 Position */
N#define PWM_POE_PWM1_Msk                        (1ul << PWM_POE_PWM1_Pos)           /*!< PWM_T::POE: POE1 Mask */
N
N#define PWM_POE_PWM0_Pos                        0                                   /*!< PWM_T::POE: POE0 Position */
N#define PWM_POE_PWM0_Msk                        (1ul << PWM_POE_PWM0_Pos)           /*!< PWM_T::POE: POE0 Mask */
N
N/* PWM TCON Bit Field Definitions */
N#define PWM_TCON_PWM3DTEN_Pos                   11                                  /*!< PWM_T::TCON: PWM3DTEN Position */
N#define PWM_TCON_PWM3DTEN_Msk                   (1ul << PWM_TCON_PWM3DTEN_Pos)      /*!< PWM_T::TCON: PWM3DTEN Mask */
N
N#define PWM_TCON_PWM2DTEN_Pos                   10                                  /*!< PWM_T::TCON: PWM2DTEN Position */
N#define PWM_TCON_PWM2DTEN_Msk                   (1ul << PWM_TCON_PWM2DTEN_Pos)      /*!< PWM_T::TCON: PWM2DTEN Mask */
N
N#define PWM_TCON_PWM1DTEN_Pos                   9                                   /*!< PWM_T::TCON: PWM1DTEN Position */
N#define PWM_TCON_PWM1DTEN_Msk                   (1ul << PWM_TCON_PWM1DTEN_Pos)      /*!< PWM_T::TCON: PWM1DTEN Mask */
N
N#define PWM_TCON_PWM0DTEN_Pos                   8                                   /*!< PWM_T::TCON: PWM0DTEN Position */
N#define PWM_TCON_PWM0DTEN_Msk                   (1ul << PWM_TCON_PWM0DTEN_Pos)      /*!< PWM_T::TCON: PWM0DTEN Mask */
N
N#define PWM_TCON_PWM3TEN_Pos                    3                                   /*!< PWM_T::TCON: PWM3TEN Position */
N#define PWM_TCON_PWM3TEN_Msk                    (1ul << PWM_TCON_PWM3TEN_Pos)       /*!< PWM_T::TCON: PWM3TEN Mask */
N
N#define PWM_TCON_PWM2TEN_Pos                    2                                   /*!< PWM_T::TCON: PWM2TEN Position */
N#define PWM_TCON_PWM2TEN_Msk                    (1ul << PWM_TCON_PWM2TEN_Pos)       /*!< PWM_T::TCON: PWM2TEN Mask */
N
N#define PWM_TCON_PWM1TEN_Pos                    1                                   /*!< PWM_T::TCON: PWM1TEN Position */
N#define PWM_TCON_PWM1TEN_Msk                    (1ul << PWM_TCON_PWM1TEN_Pos)       /*!< PWM_T::TCON: PWM1TEN Mask */
N
N#define PWM_TCON_PWM0TEN_Pos                    0                                   /*!< PWM_T::TCON: PWM0TEN Position */
N#define PWM_TCON_PWM0TEN_Msk                    (1ul << PWM_TCON_PWM0TEN_Pos)       /*!< PWM_T::TCON: PWM0TEN Mask */
N
N/* PWM TSTATUS Bit Field Definitions */
N#define PWM_TSTATUS_PWM3TF_Pos                  3                                   /*!< PWM_T::TSTATUS: PWM3TF Position */
N#define PWM_TSTATUS_PWM3TF_Msk                  (1ul << PWM_TSTATUS_PWM3TF_Pos)     /*!< PWM_T::TSTATUS: PWM3TF Mask */
N
N#define PWM_TSTATUS_PWM2TF_Pos                  2                                   /*!< PWM_T::TSTATUS: PWM2TF Position */
N#define PWM_TSTATUS_PWM2TF_Msk                  (1ul << PWM_TSTATUS_PWM2TF_Pos)     /*!< PWM_T::TSTATUS: PWM2TF Mask */
N
N#define PWM_TSTATUS_PWM1TF_Pos                  1                                   /*!< PWM_T::TSTATUS: PWM1TF Position */
N#define PWM_TSTATUS_PWM1TF_Msk                  (1ul << PWM_TSTATUS_PWM1TF_Pos)     /*!< PWM_T::TSTATUS: PWM1TF Mask */
N
N#define PWM_TSTATUS_PWM0TF_Pos                  0                                   /*!< PWM_T::TSTATUS: PWM0TF Position */
N#define PWM_TSTATUS_PWM0TF_Msk                  (1ul << PWM_TSTATUS_PWM0TF_Pos)     /*!< PWM_T::TSTATUS: PWM0TF Mask */
N
N/* PWM PSCR Bit Field Definitions */
N#define PWM_PSCR_PSSEN3_Pos                     24                                  /*!< PWM_T::PSCR: PSSEN3 Position */
N#define PWM_PSCR_PSSEN3_Msk                     (1ul << PWM_PSCR_PSSEN3_Pos)        /*!< PWM_T::PSCR: PSSEN3 Mask */
N
N#define PWM_PSCR_PSSEN2_Pos                     16                                  /*!< PWM_T::PSCR: PSSEN2 Position */
N#define PWM_PSCR_PSSEN2_Msk                     (1ul << PWM_PSCR_PSSEN2_Pos)        /*!< PWM_T::PSCR: PSSEN2 Mask */
N
N#define PWM_PSCR_PSSEN1_Pos                     8                                   /*!< PWM_T::PSCR: PSSEN1 Position */
N#define PWM_PSCR_PSSEN1_Msk                     (1ul << PWM_PSCR_PSSEN1_Pos)        /*!< PWM_T::PSCR: PSSEN1 Mask */
N
N#define PWM_PSCR_PSSEN0_Pos                     0                                   /*!< PWM_T::PSCR: PSSEN0 Position */
N#define PWM_PSCR_PSSEN0_Msk                     (1ul << PWM_PSCR_PSSEN0_Pos)        /*!< PWM_T::PSCR: PSSEN0 Mask */
N/**@}*/ /* PWM_CONST */
N/**@}*/ /* PWM */
N
N
N
N/*------------------------- SPI Interface Controller -------------------------*/
N/** @addtogroup SPI SPI Controller(SPI)
N  Memory Mapped Structure for SPI Controller
N  @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var SPI_T::CNTRL
N * Offset: 0x00  SPI Control and Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GO_BUSY   |SPI Transfer Trigger and Busy Status
N * |        |          |On M05xxBN:
N * |        |          |During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit
N * |        |          |will be cleared automatically.
N * |        |          |0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
N * |        |          |1 = In Master mode, writing 1 to this bit will start the SPI data transfer; in Slave mode,
N * |        |          |writing 1 to this bit indicates that the slave is ready to communicate with a master.
N * |        |          |Note: All registers should be set before writing 1 to the GO_BUSY bit.
N * |        |          |On M05xxDN/DE:
N * |        |          |In FIFO mode, this bit will be controlled by hardware. Software cannot modify this bit.
N * |        |          |If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1. As the
N * |        |          |transfer is finished, this bit will be cleared automatically.
N * |        |          |0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
N * |        |          |1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode,
N * |        |          |writing 1 to this bit indicates that the slave is ready to communicate with a master.
N * |        |          |Note 1: When FIFO mode is disabled, all configurations should be ready before writing
N * |        |          |1 to the GO_BUSY bit.
N * |        |          |Note 2: In M05xxDN/DE SPI Slave mode, if FIFO mode is disabled and the SPI bus
N * |        |          |clock is kept at idle state during a data transfer, the GO_BUSY bit will not be cleared to
N * |        |          |0 when slave select signal goes to inactive state.
N * |[1]     |RX_NEG    |Receive on Negative Edge
N * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
N * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
N * |[2]     |TX_NEG    |Transmit on Negative Edge
N * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
N * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPI bus clock.
N * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
N * |        |          |This field specifies how many bits are transmitted in one transaction.
N * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
N * |        |          |TX_BIT_LEN = 0x08 ... 8 bit
N * |        |          |TX_BIT_LEN = 0x09 ... 9 bits
N * |        |          |......
N * |        |          |TX_BIT_LEN = 0x1f ... 31 bits
N * |        |          |TX_BIT_LEN = 0x00 ... 32 bits
N * |[9:8]   |TX_NUM    |Numbers of Transmit/Receive Word (M05xxBN Only)
N * |        |          |This field specifies how many transmit/receive word numbers should be executed 
N * |        |          |in one transfer.
N * |        |          |00 = Only one transmit/receive word will be executed in one transfer.
N * |        |          |01 = Two successive transmit/receive words will be executed in one transfer. (burst mode)
N * |        |          |10 = Reserved.
N * |        |          |11 = Reserved.
N * |        |          |Note: In Slave mode with level-trigger configuration, if TX_NUM is set to 01, the slave
N * |        |          |select pin must be kept at active state during the successive data transfer.
N * |[10]    |LSB       |LSB First
N * |        |          |0 = The MSB is transmitted/received first.
N * |        |          |1 = The LSB is transmitted/received first.
N * |[11]    |CLKP      |Clock Polarity
N * |        |          |0 = SPI bus clock idle low.
N * |        |          |1 = SPI bus clock idle high.
N * |[15:12] |SP_CYCLE  |Suspend Interval (master only)
N * |        |          |These four bits provide configurable suspend interval between two successive
N * |        |          |transactions in a transfer. The definition of the suspend interval is the interval between
N * |        |          |the last clock edge of the preceding transaction word and the first clock edge of the
N * |        |          |following transaction word.
N * |        |          |On M05xxBN:
N * |        |          |The default value is 0x0. When TX_NUM = 00b, setting this field has no effect on
N * |        |          |transfer. The desired suspend interval is obtained according to the following equation:
N * |        |          |For byte suspend interval and burst mode suspend interval:
N * |        |          |(SP_CYCLE[3:0] + 2) * period of SPI bus clock + 1 system clock cycle
N * |        |          |Example:
N * |        |          |SP_CYCLE = 0x0 ... 2 SPI bus clock cycle + 1 system clock cycle
N * |        |          |SP_CYCLE = 0x1 ... 3 SPI bus clock cycle + 1 system clock cycle
N * |        |          |......
N * |        |          |SP_CYCLE = 0xE ... 16 SPI bus clock cycle + 1 system clock cycle
N * |        |          |SP_CYCLE = 0xF ... 17 SPI bus clock cycle + 1 system clock cycle
N * |        |          |If the SPI bus clock rate equals system clock rate, that is to say, the DIV_ONE feature
N * |        |          |is enabled, the burst mode suspend interval period is
N * |        |          |(SP_CYCLE[3:0] * 2 + 3.5) * period of system clock
N * |        |          |On M05xxDN/DE:
N * |        |          |The default value is 0x3. The period of the suspend interval is obtained according
N * |        |          |to the following equation:
N * |        |          |(SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle
N * |        |          |Example:
N * |        |          |SP_CYCLE = 0x0 ... 0.5 SPI bus clock cycle
N * |        |          |SP_CYCLE = 0x1 ... 1.5 SPI bus clock cycle
N * |        |          |......
N * |        |          |SP_CYCLE = 0xE ... 14.5 SPI bus clock cycle
N * |        |          |SP_CYCLE = 0xF ... 15.5 SPI bus clock cycle
N * |[16]    |IF        |Unit-Transfer Interrupt Flag
N * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
N * |        |          |1 = SPI controller has finished one unit transfer.
N * |        |          |NOTE: This bit can be cleared by writing 1 to itself.
N * |[17]    |IE        |Unit-Transfer Interrupt Enable Control
N * |        |          |0 = SPI unit-transfer interrupt Disabled.
N * |        |          |1 = SPI unit-transfer interrupt Enabled.
N * |[18]    |SLAVE     |SLAVE Mode Control
N * |        |          |0 = Master mode.
N * |        |          |1 = Slave mode.
N * |[19]    |REORDER   |Byte Reorder Function Selection
N * |        |          |On M05xxBN:
N * |        |          |00 = Disable both byte reorder and byte suspend functions.
N * |        |          |01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPI clock
N * |        |          |cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00 (32 bits).
N * |        |          |10 = Enable byte reorder function, but disable byte suspend function.
N * |        |          |11 = Disable byte reorder function, but insert a suspend interval (2~17 SPI clock cycles)
N * |        |          |among each byte. The setting of TX_BIT_LEN must be configured as 0x00 (32 bits).
N * |        |          |Note 1: The byte reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
N * |        |          |Note 2: In Slave mode with level-trigger configuration, if the byte suspend function is enabled,
N * |        |          |the slave select pin must be kept at active state during the successive four bytes transfer.
N * |        |          |On M05xxDN/DE:
N * |        |          |00 = Byte reorder function and byte suspend function are Disabled.
N * |        |          |01 = Byte reorder function Enabled. Byte suspend interval is determined by the setting
N * |        |          |of SP_CYCLE. Set SP_CYCLE to 0 to disabled byte suspend function.
N * |        |          |10 = Reserved.
N * |        |          |11 = Reserved.
N * |        |          |Note: Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
N * |[21]    |FIFO      |FIFO Mode Enable Control (M05xxDN/DE Only)
N * |        |          |0 = FIFO mode Disabled.
N * |        |          |1 = FIFO mode Enabled.
N * |        |          |Note:
N * |        |          |1. Before enabling FIFO mode, the other related settings should be set in advance.
N * |        |          |2. In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1
N * |        |          |automatically after writing data to the transmit FIFO buffer; the GO_BUSY bit
N * |        |          |will be cleared to 0 automatically when the SPI controller is in idle.
N * |        |          |If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1
N * |        |          |and the GO_BUSY bit will be cleared to 0.
N * |        |          |3. After clearing this bit to 0, user must wait for at least 2 peripheral clock periods
N * |        |          |before setting this bit to 1 again.
N * |[23]    |VARCLK_EN |Variable Clock Enable Control (M05xxBN Master Mode Only)
N * |        |          |0 = The bus clock output frequency is fixed and decided only by the value of DIVIDER.
N * |        |          |1 = The bus clock output frequency is variable. The output frequency is decided by the
N * |        |          |values of VARCLK, DIVIDER, and DIVIDER2.
N * |        |          |Note: When this VARCLK_EN bit is set, the setting of TX_BIT_LEN must be 
N * |        |          |programmed as 0x10 (16-bit mode).
N * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only) (M05xxDN/DE Only)
N * |        |          |A mutual mirror bit of SPI_STATUS[24].
N * |        |          |0 = Receive FIFO buffer is not empty.
N * |        |          |1 = Receive FIFO buffer is empty.
N * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (Read Only) (M05xxDN/DE Only)
N * |        |          |A mutual mirror bit of SPI_STATUS[25].
N * |        |          |0 = Receive FIFO buffer is not full.
N * |        |          |1 = Receive FIFO buffer is full.
N * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only) (M05xxDN/DE Only)
N * |        |          |A mutual mirror bit of SPI_STATUS[26].
N * |        |          |0 = Transmit FIFO buffer is not empty.
N * |        |          |1 = Transmit FIFO buffer is empty.
N * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only) (M05xxDN/DE Only)
N * |        |          |A mutual mirror bit of SPI_STATUS[27].
N * |        |          |0 = Transmit FIFO buffer is not full.
N * |        |          |1 = Transmit FIFO buffer is full.
N * @var SPI_T::DIVIDER
N * Offset: 0x04  SPI Clock Divider Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |DIVIDER   |Clock Divider
N * |        |          |On M05xxBN:
N * |        |          |Only available in Master mode. The value in this field is the frequency divider to
N * |        |          |determine the master's peripheral clock frequency (f_spi) and the bus clock frequency on the
N * |        |          |SPI bus clock output pin. The desired frequency is obtained according to the following equation:
N * |        |          |f_spi = f_pclk / ((DIVIDER + 1)*2)
N * |        |          |In Slave mode, the period of SPI bus clock driven by a master shall equal or over 5
N * |        |          |times the period of PCLK. In other words, the maximum frequency of SPI bus clock is
N * |        |          |the fifth of the frequency of slave's PCLK.
N * |        |          |On M05xxDN/DE:
N * |        |          |Only DIVIDER[7:0] is available. The value in this field is the frequency divider to
N * |        |          |determine the SPI peripheral clock frequency, f_spi, and the SPI master's bus clock
N * |        |          |frequency on the SPI bus clock output pin. The frequency is obtained according to the
N * |        |          |following equation.
N * |        |          |If the bit of BCn, SPI_CNTRL2[31], is set to 0,
N * |        |          |f_spi = f_SPI_clock_src / ((DIVIDER + 1)*2)
N * |        |          |else if BCn is set to 1,
N * |        |          |f_spi = f_SPI_clock_src / (DIVIDER + 1)
N * |        |          |where f_SPI_clock_src is the SPI peripheral clock source which is defined in the CLKSEL1 register.
N * @var SPI_T::SSR
N * Offset: 0x08  SPI Slave Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SSR       |Slave Select Control (Master Only)
N * |        |          |If AUTOSS bit is cleared to 0,
N * |        |          |0 = Set the SPISSx line to inactive state.
N * |        |          |1 = Set the proper SPISSx line to active state.
N * |        |          |If AUTOSS bit is set to 1,
N * |        |          |0 = Keep the SPISSx line at inactive state.
N * |        |          |1 = Select the SPISSx line to be automatically driven to active state for the duration of
N * |        |          |transmission/reception, and will be driven to inactive state for the rest of the time.
N * |        |          |The active state of SPISSx is specified in SS_LVL bit.
N * |[2]     |SS_LVL    |Slave Select Active Level
N * |        |          |This bit defines the active status of slave select signal (SPISSx).
N * |        |          |0 = The slave select signal SPISSx is active at low-level/falling-edge.
N * |        |          |1 = The slave select signal SPISSx is active at high-level/rising-edge.
N * |[3]     |AUTOSS    |Automatic Slave Select (Master only)
N * |        |          |0 = If this bit is cleared, slave select signal will be asserted and de-asserted by setting
N * |        |          |and clearing SSR[0].
N * |        |          |1 = If this bit is set, SPISSx signal is generated automatically. It means that slave
N * |        |          |select signal will be asserted by the SPI controller when transmit/receive is started by
N * |        |          |setting GO_BUSY, and is de-asserted after each transmit/receive is finished.
N * |[4]     |SS_LTRIG  |Slave Select Level Trigger (Slave only)
N * |        |          |0: The input slave select signal is edge-trigger. This is default value. It depends on
N * |        |          |SS_LVL to decide the signal is active at falling-edge or rising-edge.
N * |        |          |1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the
N * |        |          |signal is active low or active high.
N * |[5]     |LTRIG_FLAG|Level Trigger Accomplish Flag
N * |        |          |When the SS_LTRIG bit is set in Slave mode, this bit can be read to indicate the
N * |        |          |received bit number is met the requirement or not.
N * |        |          |0 = The transaction number or the transferred bit length of one transaction does not
N * |        |          |meet the specified requirements.
N * |        |          |1 = The transaction number and the transferred bit length met the specified
N * |        |          |requirements which defined in TX_NUM and TX_BIT_LEN.
N * |        |          |Note: This bit is READ only and only available in Slave mode.
N * @var SPI_T::RX0
N * Offset: 0x10  Data Receive Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |RX        |Data Receive Register
N * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer. The
N * |        |          |number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For
N * |        |          |example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the
N * |        |          |received data.
N * |        |          |NOTE: The Data Receive Registers are read only registers.
N * @var SPI_T::RX1
N * Offset: 0x14  Data Receive Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |RX        |Data Receive Register
N * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer. The
N * |        |          |number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For
N * |        |          |example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the
N * |        |          |received data.
N * |        |          |NOTE: The Data Receive Registers are read only registers.
N * @var SPI_T::TX0
N * Offset: 0x20  Data Transmit Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |TX        |Data Transmit Register
N * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer. The number
N * |        |          |of valid bits depend on the transmit bit length field in the CNTRL register.
N * |        |          |For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be
N * |        |          |transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will
N * |        |          |perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).
N * @var SPI_T::TX1
N * Offset: 0x24  Data Transmit Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |TX        |Data Transmit Register
N * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer. The number
N * |        |          |of valid bits depend on the transmit bit length field in the CNTRL register.
N * |        |          |For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be
N * |        |          |transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will
N * |        |          |perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).
N * @var SPI_T::VARCLK
N * Offset: 0x34  Variable Clock Pattern Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |VARCLK    |Variable Clock Pattern
N * |        |          |The value in this field is the frequency patterns of the SPI bus clock.
N * |        |          |If the bit pattern of VARCLK is 0, the output frequency of SPI bus clock is according the value of DIVIDER.
N * |        |          |If the bit pattern of VARCLK is 1, the output frequency of SPI bus clock is according the value of DIVIDER2.
N * |        |          |If the variable clock function is disabled, this setting is unmeaning.
N * @var SPI_T::CNTRL2
N * Offset: 0x3C  SPI Control and Status Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DIV_ONE   |SPI Bus Clock Divider Control (M05xxBN Master Mode Only)
N * |        |          |0 = The SPI bus clock rate is determined by the setting of SPI_DIVIDER register.
N * |        |          |1 = Enable the DIV_ONE feature. The SPI bus clock rate equals the system clock rate.
N * |        |          |Note: When this bit is set to 1, both the REORDER field and the VARCLK_EN
N * |        |          |field must be configured as 0. In other words, the byte-reorder function, byte
N * |        |          |suspend function and variable clock function must be disabled.
N * |[8]     |NOSLVSEL  |Slave 3-Wire Mode Enable Bit
N * |        |          |This is used to ignore the slave select signal in Slave mode.
N * |        |          |The SPI controller can work with 3-wire interface including SPICLK, SPI_MISO, and SPI_MOSI.
N * |        |          |0 = 4-wire bi-direction interface.
N * |        |          |1 = 3-wire bi-direction interface. When this bit is set to 1, the controller will be ready to 
N * |        |          |transmit/receive data after the GO_BUSY bit is set to 1.
N * |        |          |Note: In Slave 3-wire mode, the SS_LTRIG (SPI_SSR[4]) shall be set as 1.
N * |[9]     |SLV_ABORT |Slave 3-Wire Mode Abort Control
N * |        |          |In normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.
N * |        |          |If the received bits are less than the requirement and there is no more serial clock input over the one transfer time in slave 3-wire mode,
N * |        |          |the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event.
N * |        |          |Note: It will be cleared to 0 automatically by hardware after it is set to 1 by software.
N * |[10]    |SSTA_INTEN|Slave 3-Wire Mode Start Interrupt Enable
N * |        |          |It is used to enable interrupt when the transfer has started in slave 3-wire mode.
N * |        |          |If there is no transfer done interrupt over the time period which is defined by user after the transfer start,
N * |        |          |user can set the SLV_ABORT bit to force the transfer done.
N * |        |          |0 = Transaction start interrupt Disabled.
N * |        |          |1 = Transaction start interrupt Enabled. It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared.
N * |[11]    |SLV_START_INTSTS|Slave 3-Wire Mode Start Interrupt Status
N * |        |          |This bit dedicates if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_STATUS[11].
N * |        |          |0 = Slave does not detect any SPI bus clock transition since the SSTA_INTEN bit was set to 1.
N * |        |          |1 = A transaction has started in Slave 3-wire mode. It will be cleared automatically when a transaction is done or by writing 1 to this bit.
N * |[16]    |SS_INT_OPT|Slave Select Inactive Interrupt Option (M05xxDN/DE Only)
N * |        |          |This setting is only available if the SPI controller is configured as level trigger slave device.
N * |        |          |0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.
N * |        |          |1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.
N * |[31]    |BCn       |Clock Configuration Backward Compatible Option (M05xxDN/DE Only)
N * |        |          |0 = The clock configuration is backward compatible to M05xxBN.
N * |        |          |1 = The clock configuration is not backward compatibleto M05xxBN.
N * @var SPI_T::FIFO_CTL
N * Offset: 0x40  SPI FIFO Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_CLR    |Clear Receive FIFO Buffer
N * |        |          |0 = No effect.
N * |        |          |1 = Clear receive FIFO buffer. The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1.
N * |        |          |This bit will be cleared to 0 by hardware after software sets it to 1 and the receive FIFO is cleared.
N * |[1]     |TX_CLR    |Clear Transmit FIFO Buffer
N * |        |          |0 = No effect.
N * |        |          |1 = Clear transmit FIFO buffer. The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1.
N * |        |          |This bit will be cleared to 0 by hardware after software sets it to 1 and the transmit FIFO is cleared.
N * |[2]     |RX_INTEN  |Receive Threshold Interrupt Enable
N * |        |          |0 = Receive threshold interrupt Disabled.
N * |        |          |1 = Receive threshold interrupt Enabled.
N * |[3]     |TX_INTEN  |Transmit Threshold Interrupt Enable
N * |        |          |0 = Transmit threshold interrupt Disabled.
N * |        |          |1 = Transmit threshold interrupt Enabled.
N * |[6]     |RXOV_INTEN|Receive FIFO Overrun Interrupt Enable Control
N * |        |          |0 = Receive FIFO overrun interrupt Disabled.
N * |        |          |1 = Receive FIFO overrun interrupt Enabled.
N * |[21]    |TIMEOUT_INTEN|Receive FIFO Time-out Interrupt Enable
N * |        |          |0 = Time-out interrupt Disabled.
N * |        |          |1 = Time-out interrupt Enabled.
N * |[25:24] |RX_THRESHOLD |Received FIFO Threshold
N * |        |          |If the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting,
N * |        |          |the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.
N * |[29:28] |TX_THRESHOLD |Transmit FIFO Threshold
N * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting,
N * |        |          |the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.
N * @var SPI_T::STATUS
N * Offset: 0x44  SPI Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_INTSTS |Receive FIFO Threshold Interrupt Status (read only)
N * |        |          |0 = That the valid data count within the RX FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD.
N * |        |          |1 = That the valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD.
N * |        |          |Note: If RX_INTEN = 1 and RX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
N * |[2]     |RX_OVERRUN|Receive FIFO Overrun Status
N * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[4]     |TX_INTSTS |Transmit FIFO Threshold Interrupt Status (read only)
N * |        |          |0 = That the valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD.
N * |        |          |1 = That the valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD.
N * |        |          |Note: If TX_INTEN = 1 and TX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
N * |[11]    |SLV_START_INTSTS|Slave Start Interrupt Status
N * |        |          |It is used to dedicate that the transfer has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_CNTRL2[11].
N * |        |          |0 = The transfer is not started.
N * |        |          |1 = The transfer has started in Slave 3-wire mode. It will be cleared as transfer done or by writing one to this bit.
N * |[15:12] |RX_FIFO_COUNT   |Receive FIFO Data Count (read only)
N * |        |          |Indicates the valid data count of receive FIFO buffer.
N * |[16]    |IF        |SPI Unit Transfer Interrupt Flag
N * |        |          |A mutual mirror bit of SPI_CNTRL[16].
N * |        |          |0 = The transfer does not finish yet.
N * |        |          |1 = The SPI controller has finished one unit transfer.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[20]    |TIMEOUT   |Time-out Interrupt Flag
N * |        |          |0 = No receive FIFO time-out event.
N * |        |          |1 = The receive FIFO buffer is not empty and it does not be read over 64 SPI
N * |        |          |clock periods in Master mode or over 576 SPI peripheral clock periods in Slave
N * |        |          |mode. When the received FIFO buffer is read by software, the time-out status
N * |        |          |will be cleared automatically.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (read only)
N * |        |          |A mutual mirror bit of SPI_CNTRL[24].
N * |        |          |0 = The receive FIFO buffer is not empty.
N * |        |          |1 = The receive FIFO buffer is empty.
N * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (read only)
N * |        |          |A mutual mirror bit of SPI_CNTRL[25].
N * |        |          |0 = The receive FIFO buffer is not full.
N * |        |          |1 = The receive FIFO buffer is full.
N * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (read only)
N * |        |          |A mutual mirror bit of SPI_CNTRL[26].
N * |        |          |0 = The transmit FIFO buffer is not empty.
N * |        |          |1 = The transmit FIFO buffer is empty.
N * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (read only)
N * |        |          |A mutual mirror bit of SPI_CNTRL[27].
N * |        |          |0 = The transmit FIFO buffer is not full.
N * |        |          |1 = The transmit FIFO buffer is full.
N * |[31:28] |TX_FIFO_COUNT   |Transmit FIFO Data Count (read only)
N * |        |          |Indicates the valid data count of transmit FIFO buffer.
N */
N
N    __IO uint32_t CNTRL;         /* Offset: 0x00  SPI Control and Status Register                                    */
X    volatile uint32_t CNTRL;          
N    __IO uint32_t DIVIDER;       /* Offset: 0x04  SPI Clock Divider Register                                         */
X    volatile uint32_t DIVIDER;        
N    __IO uint32_t SSR;           /* Offset: 0x08  SPI Slave Select Register                                          */
X    volatile uint32_t SSR;            
N    __I  uint32_t RESERVE0;     
X    volatile const  uint32_t RESERVE0;     
N    __I  uint32_t RX0;           /* Offset: 0x10  Data Receive Register                                              */
X    volatile const  uint32_t RX0;            
N    __I  uint32_t RX1;           /* Offset: 0x14  Data Receive Register                                              */
X    volatile const  uint32_t RX1;            
N    __I  uint32_t RESERVE1[2];  
X    volatile const  uint32_t RESERVE1[2];  
N    __O  uint32_t TX0;           /* Offset: 0x20  Data Transmit Register                                             */
X    volatile  uint32_t TX0;            
N    __O  uint32_t TX1;           /* Offset: 0x24  Data Transmit Register                                             */
X    volatile  uint32_t TX1;            
N    __I  uint32_t RESERVE2[3];  
X    volatile const  uint32_t RESERVE2[3];  
N    __IO uint32_t VARCLK;        /* Offset: 0x34  Variable Clock Pattern Register                                    */
X    volatile uint32_t VARCLK;         
N    __I  uint32_t RESERVE3;     
X    volatile const  uint32_t RESERVE3;     
N    __IO uint32_t CNTRL2;        /* Offset: 0x3C  SPI Control and Status Register 2                                  */
X    volatile uint32_t CNTRL2;         
N    __IO uint32_t FIFO_CTL;      /* Offset: 0x40  SPI FIFO Control Register                                          */
X    volatile uint32_t FIFO_CTL;       
N    __IO uint32_t STATUS;        /* Offset: 0x44  SPI Status Register                                                */
X    volatile uint32_t STATUS;         
N
N} SPI_T;
N
N
N
N/** @addtogroup SPI_CONST SPI Bit Field Definition
N  Constant Definitions for SPI Controller
N  @{
N */
N
N/* SPI_CNTRL Bit Field Definitions */
N#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI_T::CNTRL: TX_FULL Position */
N#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI_T::CNTRL: TX_FULL Mask     */
N
N#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI_T::CNTRL: TX_EMPTY Position */
N#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI_T::CNTRL: TX_EMPTY Mask     */
N
N#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI_T::CNTRL: RX_FULL Position */
N#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI_T::CNTRL: RX_FULL Mask     */
N
N#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI_T::CNTRL: RX_EMPTY Position */
N#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI_T::CNTRL: RX_EMPTY Mask     */
N
N#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI_T::CNTRL: VARCLK_EN Position */
N#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI_T::CNTRL: VARCLK_EN Mask     */
N
N#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI_T::CNTRL: FIFO Position */
N#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI_T::CNTRL: FIFO Mask     */
N
N#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI_T::CNTRL: REORDER Position */
N#define SPI_CNTRL_REORDER_Msk      (3ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI_T::CNTRL: REORDER Mask     */
N
N#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI_T::CNTRL: SLAVE Position */
N#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI_T::CNTRL: SLAVE Mask     */
N
N#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI_T::CNTRL: IE Position */
N#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI_T::CNTRL: IE Mask     */
N
N#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI_T::CNTRL: IF Position */
N#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI_T::CNTRL: IF Mask     */
N
N#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI_T::CNTRL: SP_CYCLE Position */
N#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI_T::CNTRL: SP_CYCLE Mask     */
N
N#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI_T::CNTRL: CLKP Position */
N#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI_T::CNTRL: CLKP Mask     */
N
N#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI_T::CNTRL: LSB Position */
N#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI_T::CNTRL: LSB Mask     */
N
N#define SPI_CNTRL_TX_NUM_Pos       8                                      /*!< SPI_T::CNTRL: TX_NUM Position */
N#define SPI_CNTRL_TX_NUM_Msk       (3ul << SPI_CNTRL_TX_NUM_Pos)          /*!< SPI_T::CNTRL: TX_NUM Mask     */
N
N#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI_T::CNTRL: TX_BIT_LEN Position */
N#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI_T::CNTRL: TX_BIT_LEN Mask     */
N
N#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI_T::CNTRL: TX_NEG Position */
N#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI_T::CNTRL: TX_NEG Mask     */
N
N#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI_T::CNTRL: RX_NEG Position */
N#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI_T::CNTRL: RX_NEG Mask     */
N
N#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI_T::CNTRL: GO_BUSY Position */
N#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI_T::CNTRL: GO_BUSY Mask     */
N
N/* SPI_DIVIDER Bit Field Definitions */
N#define SPI_DIVIDER_DIVIDER2_Pos   16                                     /*!< SPI_T::DIVIDER: DIVIDER2 Position */
N#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFFFul << SPI_DIVIDER_DIVIDER2_Pos) /*!< SPI_T::DIVIDER: DIVIDER2 Mask */
N
N#define SPI_DIVIDER_DIVIDER_Pos    0                                      /*!< SPI_T::DIVIDER: DIVIDER Position */
N#define SPI_DIVIDER_DIVIDER_Msk    (0xFFFFul << SPI_DIVIDER_DIVIDER_Pos)  /*!< SPI_T::DIVIDER: DIVIDER Mask */
N
N/* SPI_SSR Bit Field Definitions */
N#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI_T::SSR: LTRIG_FLAG Position */
N#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI_T::SSR: LTRIG_FLAG Mask */
N
N#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI_T::SSR: SS_LTRIG Position */
N#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI_T::SSR: SS_LTRIG Mask */
N
N#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI_T::SSR: AUTOSS Position */
N#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI_T::SSR: AUTOSS Mask */
N
N#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI_T::SSR: SS_LVL Position */
N#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI_T::SSR: SS_LVL Mask */
N
N#define SPI_SSR_SSR_Pos            0                                 /*!< SPI_T::SSR: SSR Position */
N#define SPI_SSR_SSR_Msk            (1ul << SPI_SSR_SSR_Pos)          /*!< SPI_T::SSR: SSR Mask */
N
N/* SPI_CNTRL2 Bit Field Definitions */
N#define SPI_CNTRL2_BCn_Pos                31                                         /*!< SPI_T::CNTRL2: BCn Position */
N#define SPI_CNTRL2_BCn_Msk                (1ul << SPI_CNTRL2_BCn_Pos)                /*!< SPI_T::CNTRL2: BCn Mask */
N
N#define SPI_CNTRL2_SS_INT_OPT_Pos         16                                         /*!< SPI_T::CNTRL2: SS_INT_OPT Position */
N#define SPI_CNTRL2_SS_INT_OPT_Msk         (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)         /*!< SPI_T::CNTRL2: SS_INT_OPT Mask */
N
N#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::CNTRL2: SLV_START_INTSTS Position */
N#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI_T::CNTRL2: SLV_START_INTSTS Mask */
N
N#define SPI_CNTRL2_SSTA_INTEN_Pos         10                                         /*!< SPI_T::CNTRL2: SSTA_INTEN Position */
N#define SPI_CNTRL2_SSTA_INTEN_Msk         (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)         /*!< SPI_T::CNTRL2: SSTA_INTEN Mask */
N
N#define SPI_CNTRL2_SLV_ABORT_Pos          9                                          /*!< SPI_T::CNTRL2: SLV_ABORT Position */
N#define SPI_CNTRL2_SLV_ABORT_Msk          (1ul << SPI_CNTRL2_SLV_ABORT_Pos)          /*!< SPI_T::CNTRL2: SLV_ABORT Mask */
N
N#define SPI_CNTRL2_NOSLVSEL_Pos           8                                          /*!< SPI_T::CNTRL2: NOSLVSEL Position */
N#define SPI_CNTRL2_NOSLVSEL_Msk           (1ul << SPI_CNTRL2_NOSLVSEL_Pos)           /*!< SPI_T::CNTRL2: NOSLVSEL Mask */
N
N#define SPI_CNTRL2_DIV_ONE_Pos            0                                          /*!< SPI_T::CNTRL2: DIV_ONE Position */
N#define SPI_CNTRL2_DIV_ONE_Msk            (1ul << SPI_CNTRL2_DIV_ONE_Pos)            /*!< SPI_T::CNTRL2: DIV_ONE Mask */
N
N/* SPI_FIFO_CTL Bit Field Definitions */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Pos     28                                         /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Position */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Msk     (3ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_RX_THRESHOLD_Pos     24                                         /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Position */
N#define SPI_FIFO_CTL_RX_THRESHOLD_Msk     (3ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos    21                                         /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Position */
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk    (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)    /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Mask */
N
N#define SPI_FIFO_CTL_RXOV_INTEN_Pos       6                                          /*!< SPI_T::FIFO_CTL: RXOV_INTEN Position */
N#define SPI_FIFO_CTL_RXOV_INTEN_Msk       (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)       /*!< SPI_T::FIFO_CTL: RXOV_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_INTEN_Pos         3                                          /*!< SPI_T::FIFO_CTL: TX_INTEN Position */
N#define SPI_FIFO_CTL_TX_INTEN_Msk         (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)         /*!< SPI_T::FIFO_CTL: TX_INTEN Mask */
N
N#define SPI_FIFO_CTL_RX_INTEN_Pos         2                                          /*!< SPI_T::FIFO_CTL: RX_INTEN Position */
N#define SPI_FIFO_CTL_RX_INTEN_Msk         (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)         /*!< SPI_T::FIFO_CTL: RX_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_CLR_Pos           1                                          /*!< SPI_T::FIFO_CTL: TX_CLR Position */
N#define SPI_FIFO_CTL_TX_CLR_Msk           (1ul << SPI_FIFO_CTL_TX_CLR_Pos)           /*!< SPI_T::FIFO_CTL: TX_CLR Mask */
N
N#define SPI_FIFO_CTL_RX_CLR_Pos           0                                          /*!< SPI_T::FIFO_CTL: RX_CLR Position */
N#define SPI_FIFO_CTL_RX_CLR_Msk           (1ul << SPI_FIFO_CTL_RX_CLR_Pos)           /*!< SPI_T::FIFO_CTL: RX_CLR Mask */
N
N/* SPI_STATUS Bit Field Definitions */
N#define SPI_STATUS_TX_FIFO_COUNT_Pos      28                                         /*!< SPI_T::STATUS: TX_FIFO_COUNT Position */
N#define SPI_STATUS_TX_FIFO_COUNT_Msk      (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)    /*!< SPI_T::STATUS: TX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_TX_FULL_Pos            27                                         /*!< SPI_T::STATUS: TX_FULL Position */
N#define SPI_STATUS_TX_FULL_Msk            (1ul << SPI_STATUS_TX_FULL_Pos)            /*!< SPI_T::STATUS: TX_FULL Mask */
N
N#define SPI_STATUS_TX_EMPTY_Pos           26                                         /*!< SPI_T::STATUS: TX_EMPTY Position */
N#define SPI_STATUS_TX_EMPTY_Msk           (1ul << SPI_STATUS_TX_EMPTY_Pos)           /*!< SPI_T::STATUS: TX_EMPTY Mask */
N
N#define SPI_STATUS_RX_FULL_Pos            25                                         /*!< SPI_T::STATUS: RX_FULL Position */
N#define SPI_STATUS_RX_FULL_Msk            (1ul << SPI_STATUS_RX_FULL_Pos)            /*!< SPI_T::STATUS: RX_FULL Mask */
N
N#define SPI_STATUS_RX_EMPTY_Pos           24                                         /*!< SPI_T::STATUS: RX_EMPTY Position */
N#define SPI_STATUS_RX_EMPTY_Msk           (1ul << SPI_STATUS_RX_EMPTY_Pos)           /*!< SPI_T::STATUS: RX_EMPTY Mask */
N
N#define SPI_STATUS_TIMEOUT_Pos            20                                         /*!< SPI_T::STATUS: TIMEOUT Position */
N#define SPI_STATUS_TIMEOUT_Msk            (1ul << SPI_STATUS_TIMEOUT_Pos)            /*!< SPI_T::STATUS: TIMEOUT Mask */
N
N#define SPI_STATUS_IF_Pos                 16                                         /*!< SPI_T::STATUS: IF Position */
N#define SPI_STATUS_IF_Msk                 (1ul << SPI_STATUS_IF_Pos)                 /*!< SPI_T::STATUS: IF Mask     */
N
N#define SPI_STATUS_RX_FIFO_COUNT_Pos      12                                         /*!< SPI_T::STATUS: RX_FIFO_COUNT Position */
N#define SPI_STATUS_RX_FIFO_COUNT_Msk      (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)    /*!< SPI_T::STATUS: RX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::STATUS: SLV_START_INTSTS Position */
N#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI_T::STATUS: SLV_START_INTSTS Mask */
N
N#define SPI_STATUS_TX_INTSTS_Pos          4                                          /*!< SPI_T::STATUS: TX_INTSTS Position */
N#define SPI_STATUS_TX_INTSTS_Msk          (1ul << SPI_STATUS_TX_INTSTS_Pos)          /*!< SPI_T::STATUS: TX_INTSTS Mask */
N
N#define SPI_STATUS_RX_OVERRUN_Pos         2                                          /*!< SPI_T::STATUS: RX_OVERRUN Position */
N#define SPI_STATUS_RX_OVERRUN_Msk         (1ul << SPI_STATUS_RX_OVERRUN_Pos)         /*!< SPI_T::STATUS: RX_OVERRUN Mask */
N
N#define SPI_STATUS_RX_INTSTS_Pos          0                                          /*!< SPI_T::STATUS: RX_INTSTS Position */
N#define SPI_STATUS_RX_INTSTS_Msk          (1ul << SPI_STATUS_RX_INTSTS_Pos)          /*!< SPI_T::STATUS: RX_INTSTS Mask */
N/**@}*/ /* SPI_CONST */
N/**@}*/ /* SPI */
N
N
N
N/*---------------------------- Global Controller -----------------------------*/
N
N/** @addtogroup GCR System Global Controller(SYS)
N  Memory Mapped Structure for System Global Controller
N  @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var GCR_T::PDID
N * Offset: 0x00  Part Device Identification Number Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDID      |This register reflects device part number code. Software can read this register to identify which device is used.
N * @var GCR_T::RSTSRC
N * Offset: 0x04  System Reset Source Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RSTS_POR  |Power-on Reset Flag
N * |        |          |The RSTS_POR flag is set by the "reset signal" from the Power-On Reset (POR) controller or bit CHIP_RST (IPRSTC1[0]) to indicate the previous reset source.
N * |        |          |0 = No reset from POR or CHIP_RST (IPRSTC1[0]).
N * |        |          |1 = Power-on Reset (POR) or CHIP_RST (IPRSTC1[0]) had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[1]     |RSTS_RESET|Reset Pin Reset Flag
N * |        |          |The RSTS_RESET flag is set by the "Reset Signal" from the /RESET pin to indicate the previous reset source.
N * |        |          |0 = No reset from /RESET pin.
N * |        |          |1 = The Pin /RESET had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[2]     |RSTS_WDT  |Watchdog Reset Flag
N * |        |          |The RSTS_WDT flag is set by The "Reset Signal" from the Watchdog Timer to indicate the previous reset source
N * |        |          |0 = No reset from watchdog timer.
N * |        |          |1 = The watchdog timer had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[3]     |RSTS_LVR  |Low Voltage Reset Flag
N * |        |          |The RSTS_LVR flag Is Set By The "Reset Signal" From The Low-Voltage-Reset Controller To Indicate The Previous Reset Source
N * |        |          |0 = No reset from LVR.
N * |        |          |1 = The LVR controller had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[4]     |RSTS_BOD  |Brown-out Detector Reset Flag
N * |        |          |The RSTS_BOD flag is set by the "Reset Signal" from the Brown-Out Detector to indicate the previous reset source.
N * |        |          |0 = No reset from BOD.
N * |        |          |1 = The BOD had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[5]     |RSTS_MCU  |MCU Reset Flag
N * |        |          |The RSTS_MCU flag is set by the "Reset Signal" from the Cortex-M0 kernel to indicate the previous reset source.
N * |        |          |0 = No reset from Cortex-M0.
N * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit SYSRESETREQ (AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 kernel.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[7]     |RSTS_CPU  |CPU Reset Flag
N * |        |          |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 CPU kernel and flash. Memory Controller (FMC)
N * |        |          |0 = No reset from CPU.
N * |        |          |1 = Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST(IPRSTC1[1]) to 1.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * @var GCR_T::IPRSTC1
N * Offset: 0x08  Peripheral Reset Control Resister 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CHIP_RST  |Chip One-shot Reset (Write Protect)
N * |        |          |Setting this bit will reset the whole chip, including Cortex-M0 core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
N * |        |          |The CHIP_RST is the same as the POR reset. All the chip controllers are reset and the chip setting from CONFIG0 are also reload.
N * |        |          |0 = Chip normal operation.
N * |        |          |1 = Chip one-shot reset.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[1]     |CPU_RST   |Cortex-M0 Core One-shot Reset (Write Protect)
N * |        |          |Setting this bit will only reset the Cortex-M0 core and Flash Memory Controller (FMC), and this bit will automatically return 0 after the two clock cycles.
N * |        |          |0 = Cortex-M0 core normal operation.
N * |        |          |1 = Cortex-M0 core one-shot reset.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[3]     |EBI_RST   |EBI Controller Reset (Write Protect)
N * |        |          |Set this bit to 1 will generate a reset signal to the EBI. User needs to set this bit to 0 to release from the reset state.
N * |        |          |0 = EBI controller normal operation.
N * |        |          |1 = EBI controller reset.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[4]     |HDIV_RST  |HDIV Controller Reset (Write Protect) 
N * |        |          |Set this bit to 1 will generate a reset signal to the hardware divider. User need to set this bit to 0 to release from the reset state.
N * |        |          |0 = Hardware divider controller normal operation.
N * |        |          |1 = Hardware divider controller reset.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register. 
N * @var GCR_T::IPRSTC2
N * Offset: 0x0C  Peripheral Reset Control Resister 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |GPIO_RST  |GPIO Controller Reset
N * |        |          |0 = GPIO controller normal operation.
N * |        |          |1 = GPIO controller reset.
N * |[2]     |TMR0_RST  |Timer0 Controller Reset
N * |        |          |0 = Timer0 controller normal operation.
N * |        |          |1 = Timer0 controller reset.
N * |[3]     |TMR1_RST  |Timer1 Controller Reset
N * |        |          |0 = Timer1 controller normal operation.
N * |        |          |1 = Timer1 controller reset.
N * |[4]     |TMR2_RST  |Timer2 Controller Reset
N * |        |          |0 = Timer2 controller normal operation.
N * |        |          |1 = Timer2 controller reset.
N * |[5]     |TMR3_RST  |Timer3 Controller Reset
N * |        |          |0 = Timer3 controller normal operation.
N * |        |          |1 = Timer3 controller reset.
N * |[8]     |I2C0_RST  |I2C0 Controller Reset
N * |        |          |0 = I2C0 controller normal operation.
N * |        |          |1 = I2C0 controller reset.
N * |[9]     |I2C1_RST  |I2C1 Controller Reset
N * |        |          |0 = I2C1 controller normal operation.
N * |        |          |1 = I2C1 controller reset.
N * |[12]    |SPI0_RST  |SPI0 Controller Reset
N * |        |          |0 = SPI0 controller normal operation.
N * |        |          |1 = SPI0 controller reset.
N * |[13]    |SPI1_RST  |SPI1 Controller Reset
N * |        |          |0 = SPI1 controller normal operation.
N * |        |          |1 = SPI1 controller reset.
N * |[16]    |UART0_RST |UART0 Controller Reset
N * |        |          |0 = UART0 controller normal operation.
N * |        |          |1 = UART0 controller reset.
N * |[17]    |UART1_RST |UART1 Controller Reset
N * |        |          |0 = UART1 controller normal operation.
N * |        |          |1 = UART1 controller reset.
N * |[20]    |PWM03_RST |PWM03 Controller Reset
N * |        |          |0 = PWM03 controller normal operation.
N * |        |          |1 = PWM03 controller reset.
N * |[21]    |PWM47_RST |PWM47 Controller Reset
N * |        |          |0 = PWM47 controller normal operation.
N * |        |          |1 = PWM47 controller reset.
N * |[22]    |ACMP01_RST|Analog Comparator A Controller Reset
N * |        |          |0 = Analog Comparator A controller normal operation.
N * |        |          |1 = Analog Comparator A controller reset.     
N * |[22]    |ACMP23_RST|Analog Comparator B Controller Reset
N * |        |          |0 = Analog Comparator B controller normal operation.
N * |        |          |1 = Analog Comparator B controller reset.         
N * |[28]    |ADC_RST   |ADC Controller Reset
N * |        |          |0 = ADC controller normal operation.
N * |        |          |1 = ADC controller reset.
N * @var GCR_T::BODCR
N * Offset: 0x18  Brown-Out Detector Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BOD_EN    |Brown-Out Detector Enable Bit (Write Protect)
N * |        |          |The default value is set by flash memory controller user configuration register CBODEN (Config0[23]) bit.
N * |        |          |0 = Brown-out Detector function Disabled.
N * |        |          |1 = Brown-out Detector function Enabled.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[2:1]   |BOD_VL    |Brown-Out Detector Threshold Voltage Selection (Write Protect)
N * |        |          |The default value is set by flash controller user configuration register CBOV (Config0[22:21]) bit.
N * |        |          |00 = Brown-out voltage is 2.2V.
N * |        |          |01 = Brown-out voltage is 2.7V.
N * |        |          |10 = Brown-out voltage is 3.7V.
N * |        |          |11 = Brown-out voltage is 4.4V.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[3]     |BOD_RSTEN |Brown-out Reset Enable Control (Write Protect)
N * |        |          |0 = Brown-out "INTERRUPT" function Enabled.
N * |        |          |While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled (BOD_RSTEN low), BOD will assert an interrupt if BOD_OUT is high.
N * |        |          |BOD interrupt will keep till to the BOD_EN set to 0. BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).
N * |        |          |1 = Brown-out "RESET" function Enabled.
N * |        |          |Note1: While the Brown-out Detector function is enabled (BOD_EN high) and BOD reset function is enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BOD_OUT high).
N * |        |          |Note2: The default value is set by flash controller user configuration register CBORST (Config0[20]) bit.
N * |        |          |Note3: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[4]     |BOD_INTF  |Brown-out Detector Interrupt Flag
N * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting.
N * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[5]     |BOD_LPM   |Brown-out Detector Low Power Mode (Write Protection)
N * |        |          |0 = BOD operated in Normal mode (default).
N * |        |          |1 = BOD Low Power mode Enabled.
N * |        |          |Note1: The BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the current to about 1/10 but slow the BOD response.
N * |        |          |Note2: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[6]     |BOD_OUT   |Brown-out Detector Output Status
N * |        |          |0 = Brown-out Detector output status is 0. It means the detected voltage is higher than BOD_VL setting or BOD_EN is 0.
N * |        |          |1 = Brown-out Detector output status is 1. It means the detected voltage is lower than BOD_VL setting. If the BOD_EN is 0, BOD function disabled, this bit always responds to 0.
N * |[7]     |LVR_EN    |Low Voltage Reset Enable Bit (Write Protect)
N * |        |          |The LVR function reset the chip when the input power voltage is lower than LVR circuit setting. LVR function is enabled by default.
N * |        |          |0 = Low Voltage Reset function Disabled.
N * |        |          |1 = Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default).
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * @var GCR_T::TEMPCR
N * Offset: 0x1C  Temperature Sensor Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |VTEMP_EN  |Temperature Sensor Enable Control
N * |        |          |This bit is used to enable/disable temperature sensor function.
N * |        |          |0 = Temperature sensor function Disabled (default).
N * |        |          |1 = Temperature sensor function Enabled.
N * |        |          |Note: After this bit is set to 1, the value of temperature sensor output can be obtained from the ADC conversion result. 
N * |        |          |Please refer to the ADC chapter for detailed ADC conversion functional description.
N * @var GCR_T::PORCR
N * Offset: 0x24  Power-On-Reset Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |POR_DIS_CODE|Power-on Reset Enable Control (Write Protect)
N * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.
N * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
N * |        |          |The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
N * |        |          |nRESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function.
N * |        |          |Note: These bits are write protected bit. Refer to the REGWRPROT register.
N * @var GCR_T::P0_MFP
N * Offset: 0x30  P0 Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |P0_MFP    |P0 multiple function Selection
N * |        |          |The pin function of P0 is depending on P0_MFP and P0_ALT.
N * |        |          |Refer to P0_ALT descriptions in detail.
N * |[8]     |P0_ALT0   |P0.0 alternate function Selection
N * |        |          |The pin function of P0.0 is depend on P0_MFP[0] and P0_ALT[0].
N * |        |          |P0_ALT[0]P0_MFP[0] = P0.0 Function
N * |        |          |00 = P0.0
N * |        |          |01 = AD0(EBI)
N * |        |          |10 = CTS1(UART1)
N * |        |          |11 = Reserved
N * |[9]     |P0_ALT1   |P0.1 alternate function Selection
N * |        |          |The pin function of P0.1 is depend on P0_MFP[1] and P0_ALT[1].
N * |        |          |P0_ALT[1] P0_MFP[1] = P0.1 Function
N * |        |          |00 = P0.1
N * |        |          |01 = AD1(EBI)
N * |        |          |10 = RTS1(UART1)
N * |        |          |11 = Reserved
N * |[10]    |P0_ALT2   |P0.2 alternate function Selection
N * |        |          |The pin function of P0.2 is depend on P0_MFP[2] and P0_ALT[2].
N * |        |          |P0_ALT[2] P0_MFP[2] = P0.2 Function
N * |        |          |00 = P0.2
N * |        |          |01 = AD2(EBI)
N * |        |          |10 = CTS0(UART0)
N * |        |          |11 = Reserved
N * |[11]    |P0_ALT3   |P0.3 alternate function Selection
N * |        |          |The pin function of P0.3 is depend on P0_MFP[3] and P0_ALT[3].
N * |        |          |P0_ALT[3] P0_MFP[3] = P0.3 Function
N * |        |          |00 = P0.3
N * |        |          |01 = AD3(EBI)
N * |        |          |10 = RTS0(UART0)
N * |        |          |11 = Reserved
N * |[12]    |P0_ALT4   |P0.4 alternate function Selection
N * |        |          |The pin function of P0.4 is depend on P0_MFP[4] and P0_ALT[4].
N * |        |          |P0_ALT[4] P0_MFP[4] = P0.4 Function
N * |        |          |00 = P0.4
N * |        |          |01 = AD4(EBI)
N * |        |          |10 = SPISS1(SPI1)
N * |        |          |11 = Reserved
N * |[13]    |P0_ALT5   |P0.5 alternate function Selection
N * |        |          |The pin function of P0.5 is depend on P0_MFP[5] and P0_ALT[5].
N * |        |          |P0_ALT[5] P0_MFP[5] = P0.5 Function
N * |        |          |00 = P0.5
N * |        |          |01 = AD5(EBI)
N * |        |          |10 = MOSI_1(SPI1)
N * |        |          |11 = Reserved
N * |[14]    |P0_ALT6   |P0.6 alternate function Selection
N * |        |          |The pin function of P0.6 is depend on P0_MFP[6] and P0_ALT[6].
N * |        |          |P0_ALT[6] P0_MFP[6] = P0.6 Function
N * |        |          |00 = P0.6
N * |        |          |01 = AD6(EBI)
N * |        |          |10 = MISO_1(SPI1)
N * |        |          |11 = Reserved
N * |[15]    |P0_ALT7   |P0.7 alternate function Selection
N * |        |          |The pin function of P0.7 is depend on P0_MFP[7] and P0_ALT[7].
N * |        |          |P0_ALT[7] P0_MFP[7] = P0.7 Function
N * |        |          |00 = P0.7
N * |        |          |01 = AD7(EBI)
N * |        |          |10 = SPICLK1(SPI1)
N * |        |          |11 = Reserved
N * |[23:16] |P0_TYPEn  |P0[7:0] input Schmitt Trigger function Enable
N * |        |          |1= P0[7:0] I/O input Schmitt Trigger function enable
N * |        |          |0= P0[7:0] I/O input Schmitt Trigger function disable
N * @var GCR_T::P1_MFP
N * Offset: 0x34  P1 Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |P1_MFP    |P1 multiple function Selection
N * |        |          |The pin function of P1 is depending on P1_MFP and P1_ALT.
N * |        |          |Refer to P1_ALT descriptions in detail.
N * |[8]     |P1_ALT0   |P1.0 alternate function Selection
N * |        |          |The pin function of P1.0 is depend on P1_MFP[0] and P1_ALT[0].
N * |        |          |P1_ALT[0] P1_MFP[0] = P1.0 Function
N * |        |          |00 = P1.0
N * |        |          |01 = AIN0(ADC)
N * |        |          |10 = T2(Timer2)
N * |        |          |11 = Reserved
N * |[9]     |P1_ALT1   |P1.1 alternate function Selection
N * |        |          |The pin function of P1.1 is depend on P1_MFP[1] and P1_ALT[1].
N * |        |          |P1_ALT[1] P1_MFP[1] = P1.1 Function
N * |        |          |00 = P1.1
N * |        |          |01 = AIN1(ADC)
N * |        |          |10 = T3(Timer3)
N * |        |          |11 = Reserved
N * |[10]    |P1_ALT2   |P1.2 alternate function Selection
N * |        |          |The pin function of P1.2 is depend on P1_MFP[2] and P1_ALT[2].
N * |        |          |P1_ALT[2] P1_MFP[2] = P1.2 Function
N * |        |          |00 = P1.2
N * |        |          |01 = AIN2(ADC)
N * |        |          |10 = RXD1(UART1)
N * |        |          |11 = Reserved
N * |[11]    |P1_ALT3   |P1.3 alternate function Selection
N * |        |          |The pin function of P1.3 is depend on P1_MFP[3] and P1_ALT[3].
N * |        |          |P1_ALT[3] P1_MFP[3] = P1.3 Function
N * |        |          |00 = P1.3
N * |        |          |01 = AIN3(ADC)
N * |        |          |10 = TXD1(UART1)
N * |        |          |11 = Reserved
N * |[12]    |P1_ALT4   |P1.4 alternate function Selection
N * |        |          |The pin function of P1.4 is depend on P1_MFP[4] and P1_ALT[4].
N * |        |          |P1_ALT[4] P1_MFP[4] = P1.4 Function
N * |        |          |00 = P1.4
N * |        |          |01 = AIN4(ADC)
N * |        |          |10 = SPISS0(SPI0)
N * |        |          |11 = Reserved
N * |[13]    |P1_ALT5   |P1.5 alternate function Selection
N * |        |          |The pin function of P1.5 is depend on P1_MFP[5] and P1_ALT[5].
N * |        |          |P1_ALT[5] P1_MFP[5] = P1.5 Function
N * |        |          |00 = P1.5
N * |        |          |01 = AIN5(ADC)
N * |        |          |10 = MOSI_0(SPI0)
N * |        |          |11 = Reserved
N * |[14]    |P1_ALT6   |P1.6 alternate function Selection
N * |        |          |The pin function of P1.6 is depend on P1_MFP[6] and P1_ALT[6].
N * |        |          |P1_ALT[6] P1_MFP[6] = P1.6 Function
N * |        |          |00 = P1.6
N * |        |          |01 = AIN6(ADC)
N * |        |          |10 = MISO_0(SPI0)
N * |        |          |11 = Reserved
N * |[15]    |P1_ALT7   |P1.7 alternate function Selection
N * |        |          |The pin function of P1.7 is depend on P1_MFP[7] and P1_ALT[7].
N * |        |          |P1_ALT[7] P1_MFP[7] = P1.7 Function
N * |        |          |00 = P1.7
N * |        |          |01 = AIN7(ADC)
N * |        |          |10 = SPICLK0(SPI0)
N * |        |          |11 = Reserved
N * |[23:16] |P1_TYPEn  |P1[7:0] input Schmitt Trigger function Enable
N * |        |          |1= P1[7:0] I/O input Schmitt Trigger function enable
N * |        |          |0= P1[7:0] I/O input Schmitt Trigger function disable
N * @var GCR_T::P2_MFP
N * Offset: 0x38  P2 Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |P2_MFP    |P2 multiple function Selection
N * |        |          |The pin function of P2 is depending on P2_MFP and P2_ALT.
N * |        |          |Refer to P2_ALT descriptions in detail.
N * |[8]     |P2_ALT0   |P2.0 alternate function Selection
N * |        |          |The pin function of P2.0 is depend on P2_MFP[0] and P2_ALT[0].
N * |        |          |P2_ALT[0] P2_MFP[0] = P2.0 Function
N * |        |          |00 = P2.0
N * |        |          |01 = AD8(EBI)
N * |        |          |10 = PWM0(PWM generator 0)
N * |        |          |11 = Reserved
N * |[9]     |P2_ALT1   |P2.1 alternate function Selection
N * |        |          |The pin function of P2.1 is depend on P2_MFP[1] and P2_ALT[1].
N * |        |          |P2_ALT[1] P2_MFP[1] = P2.1 Function
N * |        |          |00 = P2.1
N * |        |          |01 = AD9(EBI)
N * |        |          |10 = PWM1(PWM generator 0)
N * |        |          |11 = Reserved
N * |[10]    |P2_ALT2   |P2.2 alternate function Selection
N * |        |          |The pin function of P2.2 is depend on P2_MFP[2] and P2_ALT[2].
N * |        |          |P2_ALT[2] P2_MFP[2] = P2.2 Function
N * |        |          |00 = P2.2
N * |        |          |01 = AD10(EBI)
N * |        |          |10 = PWM2(PWM generator 2)
N * |        |          |11 = Reserved
N * |[11]    |P2_ALT3   |P2.3 alternate function Selection
N * |        |          |The pin function of P2.3 is depend on P2_MFP[3] and P2_ALT[3].
N * |        |          |P2_ALT[3] P2_MFP[3] = P2.3 Function
N * |        |          |00 = P2.3
N * |        |          |01 = AD11(EBI)
N * |        |          |10 = PWM3(PWM generator 2)
N * |        |          |11 = Reserved
N * |[12]    |P2_ALT4   |P2.4 alternate function Selection
N * |        |          |The pin function of P2.4 is depend on P2_MFP[4] and P2_ALT[4].
N * |        |          |P2_ALT[4] P2_MFP[4] = P0.4 Function
N * |        |          |00 = P0.4
N * |        |          |01 = AD12(EBI)
N * |        |          |10 = PWM4(PWM generator 4)
N * |        |          |11 = Reserved
N * |[13]    |P2_ALT5   |P2.5 alternate function Selection
N * |        |          |The pin function of P2.5 is depend on P2_MFP[5] and P2_ALT[5].
N * |        |          |P2_ALT[5] P2_MFP[5] = P2.5 Function
N * |        |          |00 = P2.5
N * |        |          |01 = AD13(EBI)
N * |        |          |10 = PWM5(PWM generator 4)
N * |        |          |11 = Reserved
N * |[14]    |P2_ALT6   |P2.6 alternate function Selection
N * |        |          |The pin function of P2.6 is depend on P2_MFP[6] and P2_ALT[6].
N * |        |          |P2_ALT[6] P2_MFP[6] = P2.6 Function
N * |        |          |00 = P2.6
N * |        |          |01 = AD14(EBI)
N * |        |          |10 = PWM6(PWM generator 6)
N * |        |          |11 = Reserved
N * |[15]    |P2_ALT7   |P2.7 alternate function Selection
N * |        |          |The pin function of P2.7 is depend on P2_MFP[7] and P2_ALT[7].
N * |        |          |P2_ALT[7] P2_MFP[7] = P2.7 Function
N * |        |          |00 = P2.7
N * |        |          |01 = AD15(EBI)
N * |        |          |10 = PWM7(PWM generator 6)
N * |        |          |11 = Reserved
N * |[23:16] |P2_TYPEn  |P2[7:0] input Schmitt Trigger function Enable
N * |        |          |1= P2[7:0] I/O input Schmitt Trigger function enable
N * |        |          |0= P2[7:0] I/O input Schmitt Trigger function disable
N * @var GCR_T::P3_MFP
N * Offset: 0x3C  P3 Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |P3_MFP    |P3 multiple function Selection
N * |        |          |The pin function of P3 is depending on P3_MFP and P3_ALT.
N * |        |          |Refer to P3_ALT descriptions in detail.
N * |[8]     |P3_ALT0   |P3.0 alternate function Selection
N * |        |          |The pin function of P3.0 is depend on P3_MFP[0] and P3_ALT[0].
N * |        |          |P3_ALT[0] P3_MFP[0] = P3.0 Function
N * |        |          |00 = P3.0
N * |        |          |01 = RXD(UART0)
N * |        |          |1x = Reserved
N * |[9]     |P3_ALT1   |P3.1 alternate function Selection
N * |        |          |The pin function of P3.1 is depend on P3_MFP[1] and P3_ALT[1].
N * |        |          |P3_ALT[1] P3_MFP[1] = P3.1 Function
N * |        |          |00 = P3.1
N * |        |          |01 = TXD(UART0)
N * |        |          |1x = Reserved
N * |[10]    |P3_ALT2   |P3.2 alternate function Selection
N * |        |          |The pin function of P3.2 is depend on P3_MFP[2] and P3_ALT[2].
N * |        |          |P3_ALT[2] P3_MFP[2] = P3.2 Function
N * |        |          |00 = P3.2
N * |        |          |01 = /INT0
N * |        |          |11 = Reserved
N * |[11]    |P3_ALT3   |P3.3 alternate function Selection
N * |        |          |The pin function of P3.3 is depend on P3_MFP[3] and P3_ALT[3].
N * |        |          |P3_ALT[3] P3_MFP[3] = P3.3 Function
N * |        |          |00 = P3.3
N * |        |          |01 = /INT1
N * |        |          |10 = MCLK(EBI)
N * |        |          |1x = Reserved
N * |[12]    |P3_ALT4   |P3.4 alternate function Selection
N * |        |          |The pin function of P3.4 is depend on P3_MFP[4] and P3_ALT[4].
N * |        |          |P3_ALT[4] P3_MFP[4] = P3.4 Function
N * |        |          |00 = P3.4
N * |        |          |01 = T0(Timer0)
N * |        |          |10 = SDA(I2C)
N * |        |          |11 = Reserved
N * |[13]    |P3_ALT5   |P3.5 alternate function Selection
N * |        |          |The pin function of P3.5 is depend on P3_MFP[5] and P3_ALT[5].
N * |        |          |P3_ALT[5] P3_MFP[5] = P3.5 Function
N * |        |          |00 = P3.5
N * |        |          |01 = T1(Timer1)
N * |        |          |10 = SCL(I2C)
N * |        |          |11 = Reserved
N * |[14]    |P3_ALT6   |P3.6 alternate function Selection
N * |        |          |The pin function of P3.6 is depend on P3_MFP[6] and P3_ALT[6].
N * |        |          |P3_ALT[6] P3_MFP[6] = P3.6 Function
N * |        |          |00 = P3.6
N * |        |          |01 = WR(EBI)
N * |        |          |10 = CKO(Clock Driver output)
N * |        |          |11 = Reserved
N * |[15]    |P3_ALT7   |P3.7 alternate function Selection
N * |        |          |The pin function of P3.7 is depend on P3_MFP[7] and P3_ALT[7].
N * |        |          |P3_ALT[7] P3_MFP[7] = P3.7 Function
N * |        |          |00 = P3.7
N * |        |          |01 = RD(EBI)
N * |        |          |1x = Reserved
N * |[23:16] |P3_TYPEn  |P3[7:0] input Schmitt Trigger function Enable
N * |        |          |1= P3[7:0] I/O input Schmitt Trigger function enable
N * |        |          |0= P3[7:0] I/O input Schmitt Trigger function disable
N * @var GCR_T::P4_MFP
N * Offset: 0x40  P4 Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |P4_MFP    |P4 multiple function Selection
N * |        |          |The pin function of P4 is depending on P4_MFP and P4_ALT.
N * |        |          |Refer to P4_ALT descriptions in detail.
N * |[8]     |P4_ALT0   |P4.0 alternate function Selection
N * |        |          |The pin function of P4.0 is depend on P4_MFP[0] and P4_ALT[0].
N * |        |          |P4_ALT[0] P4_MFP[0] = P4.0 Function
N * |        |          |00 = P4.0
N * |        |          |01 = PWM0(PWM generator 0)
N * |        |          |1x = Reserved
N * |[9]     |P4_ALT1   |P4.1 alternate function Selection
N * |        |          |The pin function of P4.1 is depend on P4_MFP[1] and P4_ALT[1].
N * |        |          |P4_ALT[1] P4_MFP[1] = P4.1 Function
N * |        |          |00 = P4.1
N * |        |          |01 = PWM1(PWM generator 0)
N * |        |          |1x = Reserved
N * |[10]    |P4_ALT2   |P4.2 alternate function Selection
N * |        |          |The pin function of P4.2 is depend on P4_MFP[2] and P4_ALT[2].
N * |        |          |P4_ALT[2] P4_MFP[2] = P4.2 Function
N * |        |          |00 = P4.2
N * |        |          |01 = PWM2(PWM generator 2)
N * |        |          |1x = Reserved
N * |[11]    |P4_ALT3   |P4.3 alternate function Selection
N * |        |          |The pin function of P4.3 is depend on P4_MFP[3] and P4_ALT[3].
N * |        |          |P4_ALT[3] P4_MFP[3] = P4.3 Function
N * |        |          |00 = P4.3
N * |        |          |01 = PWM3(PWM generator 2)
N * |        |          |1x = Reserved
N * |[12]    |P4_ALT4   |P4.4 alternate function Selection
N * |        |          |The pin function of P4.4 is depend on P4_MFP[4] and P4_ALT[4].
N * |        |          |P4_ALT[4] P4_MFP[4] = P4.4 Function
N * |        |          |00 = P4.4
N * |        |          |01 = /CS(EBI)
N * |        |          |1x = Reserved
N * |[13]    |P4_ALT5   |P4.5 alternate function Selection
N * |        |          |The pin function of P4.5 is depend on P4_MFP[5] and P4_ALT[5].
N * |        |          |P4_ALT[5] P4_MFP[5] = P4.5 Function
N * |        |          |00 = P4.5
N * |        |          |01 = ALE(EBI)
N * |        |          |1x = Reserved
N * |[14]    |P4_ALT6   |P4.6 alternate function Selection
N * |        |          |The pin function of P4.6 is depend on P4_MFP[6] and P4_ALT[6].
N * |        |          |P4_ALT[6] P4_MFP[6] = P4.6 Function
N * |        |          |00 = P4.6
N * |        |          |01 = ICE_CLK(ICE)
N * |        |          |1x = Reserved
N * |[15]    |P4_ALT7   |P4.7 alternate function Selection
N * |        |          |The pin function of P4.7 is depend on P4_MFP[7] and P4_ALT[7].
N * |        |          |P4_ALT[7] P4_MFP[7] = P4.7 Function
N * |        |          |00 = P4.7
N * |        |          |01 = ICE_DAT(ICE)
N * |        |          |1x = Reserved
N * |[23:16] |P4_TYPEn  |P4[7:0] input Schmitt Trigger function Enable
N * |        |          |1= P4[7:0] I/O input Schmitt Trigger function enable
N * |        |          |0= P4[7:0] I/O input Schmitt Trigger function disable
N * @var GCR_T::REGWRPROT
N * Offset: 0x100 Register Write-Protection Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |REGWRPROT |Register Write-Protected Code (Write Only)
N * |        |          |Some write-protected registers have to be disabled the protected function by writing the
N * |        |          |sequence value "59h", "16h", "88h" to this field. After this sequence is completed, the
N * |        |          |REGPROTDIS bit will be set to 1 and write-protected registers can be normal write.
N * |[0]     |REGPROTDIS|Register Write-Protected Disable index (Read only)
N * |        |          |1 = Protection is disabled for writing protected registers
N * |        |          |0 = Protection is enabled for writing protected registers. Any write to the protected register is ignored.
N * |        |          |The Write-Protected registers list are below table:
N * |        |          |Registers Address Note
N * |        |          |IPRSTC1 0x5000_0008 None
N * |        |          |BODCR 0x5000_0018 None
N * |        |          |PORCR 0x5000_001C None
N * |        |          |PWRCON 0x5000_0200 bit[6] is not protected for power, wake-up interrupt clear
N * |        |          |APBCLK bit[0] 0x5000_0208 bit[0] is watch dog clock enable
N * |        |          |CLKSEL0 0x5000_0210 HCLK and CPU STCLK clock source select
N * |        |          |CLK_SEL1 bit[1:0] 0x5000_0214 Watch dog clock source select
N * |        |          |ISPCON 0x5000_C000 Flash ISP Control register
N * |        |          |WTCR 0x4000_4000 None
N * |        |          |FATCON 0x5000_C018 None
N */
N
N    __I  uint32_t PDID;          /* Offset: 0x00  Part Device Identification Number Register.                        */
X    volatile const  uint32_t PDID;           
N    __IO uint32_t RSTSRC;        /* Offset: 0x04  System Reset Source Register                                       */
X    volatile uint32_t RSTSRC;         
N    __IO uint32_t IPRSTC1;       /* Offset: 0x08  Peripheral Reset Control Resister 1                                */
X    volatile uint32_t IPRSTC1;        
N    __IO uint32_t IPRSTC2;       /* Offset: 0x0C  Peripheral Reset Control Resister 2                                */
X    volatile uint32_t IPRSTC2;        
N    __I  uint32_t RESERVED0[2]; 
X    volatile const  uint32_t RESERVED0[2]; 
N    __IO uint32_t BODCR;         /* Offset: 0x18  Brown-Out Detector Control Register                                */
X    volatile uint32_t BODCR;          
N    __IO uint32_t TEMPCR;        /* Offset: 0x1C  Temperature Sensor Control Register                                */
X    volatile uint32_t TEMPCR;         
N    __I  uint32_t RESERVED1;    
X    volatile const  uint32_t RESERVED1;    
N    __IO uint32_t PORCR;         /* Offset: 0x24  Power-On-Reset Control Register                                    */
X    volatile uint32_t PORCR;          
N    __I  uint32_t RESERVED2[2]; 
X    volatile const  uint32_t RESERVED2[2]; 
N    __IO uint32_t P0_MFP;        /* Offset: 0x30  P0 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P0_MFP;         
N    __IO uint32_t P1_MFP;        /* Offset: 0x34  P1 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P1_MFP;         
N    __IO uint32_t P2_MFP;        /* Offset: 0x38  P2 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P2_MFP;         
N    __IO uint32_t P3_MFP;        /* Offset: 0x3C  P3 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P3_MFP;         
N    __IO uint32_t P4_MFP;        /* Offset: 0x40  P4 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P4_MFP;         
N    __I  uint32_t RESERVED3[47];
X    volatile const  uint32_t RESERVED3[47];
N    __IO uint32_t REGWRPROT;     /* Offset: 0x100 Register Write-Protection Register                                 */
X    volatile uint32_t REGWRPROT;      
N
N} GCR_T;
N
N
N
N
N/** @addtogroup GCR_CONST GCR Bit Field Definition
N  Constant Definitions for GCR Controller
N  @{
N */
N
N/* GCR RSTSRC Bit Field Definitions */
N#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                       /*!< GCR_T::RSTSRC: RSTS_CPU Position */
N#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)        /*!< GCR_T::RSTSRC: RSTS_CPU Mask */
N
N#define SYS_RSTSRC_RSTS_MCU_Pos                 5                                       /*!< GCR_T::RSTSRC: RSTS_MCU Position */
N#define SYS_RSTSRC_RSTS_MCU_Msk                 (1ul << SYS_RSTSRC_RSTS_MCU_Pos)        /*!< GCR_T::RSTSRC: RSTS_MCU Mask */
N
N#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                       /*!< GCR_T::RSTSRC: RSTS_BOD Position */
N#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)        /*!< GCR_T::RSTSRC: RSTS_BOD Mask */
N
N#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                       /*!< GCR_T::RSTSRC: RSTS_LVR Position */
N#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)        /*!< GCR_T::RSTSRC: RSTS_LVR Mask */
N
N#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                       /*!< GCR_T::RSTSRC: RSTS_WDT Position */
N#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)        /*!< GCR_T::RSTSRC: RSTS_WDT Mask */
N
N#define SYS_RSTSRC_RSTS_RESET_Pos               1                                       /*!< GCR_T::RSTSRC: RSTS_RESET Position */
N#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)      /*!< GCR_T::RSTSRC: RSTS_RESET Mask */
N
N#define SYS_RSTSRC_RSTS_POR_Pos                 0                                       /*!< GCR_T::RSTSRC: RSTS_POR Position */
N#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)        /*!< GCR_T::RSTSRC: RSTS_POR Mask */
N
N/* GCR IPRSTC1 Bit Field Definitions */
N#define SYS_IPRSTC1_HDIV_RST_Pos                4                                       /*!< GCR_T::IPRSTC1: DIV_RST Position */
N#define SYS_IPRSTC1_HDIV_RST_Msk                (1ul << SYS_IPRSTC1_HDIV_RST_Pos)        /*!< GCR_T::IPRSTC1: DIV_RST Mask */
N
N#define SYS_IPRSTC1_EBI_RST_Pos                 3                                       /*!< GCR_T::IPRSTC1: EBI_RST Position */
N#define SYS_IPRSTC1_EBI_RST_Msk                 (1ul << SYS_IPRSTC1_EBI_RST_Pos)        /*!< GCR_T::IPRSTC1: EBI_RST Mask */
N
N#define SYS_IPRSTC1_CPU_RST_Pos                 1                                       /*!< GCR_T::IPRSTC1: CPU_RST Position */
N#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)        /*!< GCR_T::IPRSTC1: CPU_RST Mask */
N
N#define SYS_IPRSTC1_CHIP_RST_Pos                0                                       /*!< GCR_T::IPRSTC1: CHIP_RST Position */
N#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)       /*!< GCR_T::IPRSTC1: CHIP_RST Mask */
N
N/* GCR IPRSTC2 Bit Field Definitions */
N#define SYS_IPRSTC2_ADC_RST_Pos                 28                                      /*!< GCR_T::IPRSTC2: ADC_RST Position */
N#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)        /*!< GCR_T::IPRSTC2: ADC_RST Mask */
N
N#define SYS_IPRSTC2_ACMP23_RST_Pos              23                                      /*!< GCR_T::IPRSTC2: ACMP23_RST Position */
N#define SYS_IPRSTC2_ACMP23_RST_Msk              (1ul << SYS_IPRSTC2_ACMP23_RST_Pos)     /*!< GCR_T::IPRSTC2: ACMP23_RST Mask */
N
N#define SYS_IPRSTC2_ACMP01_RST_Pos              22                                      /*!< GCR_T::IPRSTC2: ACMP01_RST Position */
N#define SYS_IPRSTC2_ACMP01_RST_Msk              (1ul << SYS_IPRSTC2_ACMP01_RST_Pos)     /*!< GCR_T::IPRSTC2: ACMP01_RST Mask */
N
N#define SYS_IPRSTC2_PWM47_RST_Pos               21                                      /*!< GCR_T::IPRSTC2: PWM47_RST Position */
N#define SYS_IPRSTC2_PWM47_RST_Msk               (1ul << SYS_IPRSTC2_PWM47_RST_Pos)      /*!< GCR_T::IPRSTC2: PWM47_RST Mask */
N
N#define SYS_IPRSTC2_PWM03_RST_Pos               20                                      /*!< GCR_T::IPRSTC2: PWM03_RST Position */
N#define SYS_IPRSTC2_PWM03_RST_Msk               (1ul << SYS_IPRSTC2_PWM03_RST_Pos)      /*!< GCR_T::IPRSTC2: PWM03_RST Mask */
N
N#define SYS_IPRSTC2_UART1_RST_Pos               17                                      /*!< GCR_T::IPRSTC2: UART1_RST Position */
N#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)      /*!< GCR_T::IPRSTC2: UART1_RST Mask */
N
N#define SYS_IPRSTC2_UART0_RST_Pos               16                                      /*!< GCR_T::IPRSTC2: UART0_RST Position */
N#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)      /*!< GCR_T::IPRSTC2: UART0_RST Mask */
N
N#define SYS_IPRSTC2_SPI1_RST_Pos                13                                      /*!< GCR_T::IPRSTC2: SPI1_RST Position */
N#define SYS_IPRSTC2_SPI1_RST_Msk                (1ul << SYS_IPRSTC2_SPI1_RST_Pos)       /*!< GCR_T::IPRSTC2: SPI1_RST Mask */
N
N#define SYS_IPRSTC2_SPI0_RST_Pos                12                                      /*!< GCR_T::IPRSTC2: SPI0_RST Position */
N#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)       /*!< GCR_T::IPRSTC2: SPI0_RST Mask */
N
N#define SYS_IPRSTC2_I2C1_RST_Pos                9                                       /*!< GCR_T::IPRSTC2: I2C1_RST Position */
N#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)       /*!< GCR_T::IPRSTC2: I2C1_RST Mask */
N
N#define SYS_IPRSTC2_I2C0_RST_Pos                8                                       /*!< GCR_T::IPRSTC2: I2C0_RST Position */
N#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)       /*!< GCR_T::IPRSTC2: I2C0_RST Mask */
N#define SYS_IPRSTC2_I2C_RST_Pos                 8                                       /*!< GCR_T::IPRSTC2: I2C_RST Position */
N#define SYS_IPRSTC2_I2C_RST_Msk                 (1ul << SYS_IPRSTC2_I2C_RST_Pos)        /*!< GCR_T::IPRSTC2: I2C_RST Mask */
N
N#define SYS_IPRSTC2_TMR3_RST_Pos                5                                       /*!< GCR_T::IPRSTC2: TMR3_RST Position */
N#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)       /*!< GCR_T::IPRSTC2: TMR3_RST Mask */
N
N#define SYS_IPRSTC2_TMR2_RST_Pos                4                                       /*!< GCR_T::IPRSTC2: TMR2_RST Position */
N#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)       /*!< GCR_T::IPRSTC2: TMR2_RST Mask */
N
N#define SYS_IPRSTC2_TMR1_RST_Pos                3                                       /*!< GCR_T::IPRSTC2: TMR1_RST Position */
N#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)       /*!< GCR_T::IPRSTC2: TMR1_RST Mask */
N
N#define SYS_IPRSTC2_TMR0_RST_Pos                2                                       /*!< GCR_T::IPRSTC2: TMR0_RST Position */
N#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)       /*!< GCR_T::IPRSTC2: TMR0_RST Mask */
N
N#define SYS_IPRSTC2_GPIO_RST_Pos                1                                       /*!< GCR_T::IPRSTC2: GPIO_RST Position */
N#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)       /*!< GCR_T::IPRSTC2: GPIO_RST Mask */
N
N/* GCR BODCR Bit Field Definitions */
N#define SYS_BODCR_LVR_EN_Pos                    7                                       /*!< GCR_T::BODCR: LVR_EN Position */
N#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)           /*!< GCR_T::BODCR: LVR_EN Mask */
N
N#define SYS_BODCR_BOD_OUT_Pos                   6                                       /*!< GCR_T::BODCR: BOD_OUT Position */
N#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)          /*!< GCR_T::BODCR: BOD_OUT Mask */
N
N#define SYS_BODCR_BOD_LPM_Pos                   5                                       /*!< GCR_T::BODCR: BOD_LPM Position */
N#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)          /*!< GCR_T::BODCR: BOD_LPM Mask */
N
N#define SYS_BODCR_BOD_INTF_Pos                  4                                       /*!< GCR_T::BODCR: BOD_INTF Position */
N#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)         /*!< GCR_T::BODCR: BOD_INTF Mask */
N
N#define SYS_BODCR_BOD_RSTEN_Pos                 3                                       /*!< GCR_T::BODCR: BOD_RSTEN Position */
N#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)        /*!< GCR_T::BODCR: BOD_RSTEN Mask */
N
N#define SYS_BODCR_BOD_VL_Pos                    1                                       /*!< GCR_T::BODCR: BOD_VL Position */
N#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)           /*!< GCR_T::BODCR: BOD_VL Mask */
N
N#define SYS_BODCR_BOD_EN_Pos                    0                                       /*!< GCR_T::BODCR: BOD_EN Position */
N#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)           /*!< GCR_T::BODCR: BOD_EN Mask */
N
N/* GCR TEMPCR Bit Field Definitions */
N#define SYS_TEMPCR_VTEMP_EN_Pos                 0                                       /*!< GCR_T::TEMPCR: VTEMP_EN Position */
N#define SYS_TEMPCR_VTEMP_EN_Msk                 (1ul << SYS_TEMPCR_VTEMP_EN_Pos)        /*!< GCR_T::TEMPCR: VTEMP_EN Mask */
N
N/* GCR PORCR Bit Field Definitions */
N#define SYS_PORCR_POR_DIS_CODE_Pos              0                                       /*!< GCR_T::PORCR: POR_DIS_CODE Position */
N#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)/*!< GCR_T::PORCR: POR_DIS_CODE Mask */
N
N/* GCR P0_MFP Bit Field Definitions */
N#define SYS_P0_MFP_P0_ALT1_Pos                  24                                      /*!< GCR_T::P0_MFP: P0_ALT1 Position */
N#define SYS_P0_MFP_P0_ALT1_Msk                  (3ul << SYS_P0_MFP_P0_ALT1_Pos)         /*!< GCR_T::P0_MFP: P0_ALT1 Mask */
N
N#define SYS_P0_MFP_P0_TYPE_Pos                  16                                      /*!< GCR_T::P0_MFP: P0_TYPE Position */
N#define SYS_P0_MFP_P0_TYPE_Msk                  (0xFFul << SYS_P0_MFP_P0_TYPE_Pos)      /*!< GCR_T::P0_MFP: P0_TYPE Mask */
N
N#define SYS_P0_MFP_P0_ALT_Pos                   8                                       /*!< GCR_T::P0_MFP: P0_ALT Position */
N#define SYS_P0_MFP_P0_ALT_Msk                   (0xFFul << SYS_P0_MFP_P0_ALT_Pos)       /*!< GCR_T::P0_MFP: P0_ALT Mask */
N
N#define SYS_P0_MFP_P0_MFP_Pos                   0                                       /*!< GCR_T::P0_MFP: P0_MFP Position */
N#define SYS_P0_MFP_P0_MFP_Msk                   (0xFFul << SYS_P0_MFP_P0_MFP_Pos)       /*!< GCR_T::P0_MFP: P0_MFP Mask */
N
N/* GCR P1_MFP Bit Field Definitions */
N#define SYS_P1_MFP_P1_TYPE_Pos                  16                                      /*!< GCR_T::P1_MFP: P1_TYPE Position */
N#define SYS_P1_MFP_P1_TYPE_Msk                  (0xFFul << SYS_P1_MFP_P1_TYPE_Pos)      /*!< GCR_T::P1_MFP: P1_TYPE Mask */
N
N#define SYS_P1_MFP_P1_ALT_Pos                   8                                       /*!< GCR_T::P1_MFP: P1_ALT Position */
N#define SYS_P1_MFP_P1_ALT_Msk                   (0xFFul << SYS_P1_MFP_P1_ALT_Pos)       /*!< GCR_T::P1_MFP: P1_ALT Mask */
N
N#define SYS_P1_MFP_P1_MFP_Pos                   0                                       /*!< GCR_T::P1_MFP: P1_MFP Position */
N#define SYS_P1_MFP_P1_MFP_Msk                   (0xFFul << SYS_P1_MFP_P1_MFP_Pos)       /*!< GCR_T::P1_MFP: P1_MFP Mask */
N
N/* GCR P2_MFP Bit Field Definitions */
N#define SYS_P2_MFP_P2_TYPE_Pos                  16                                      /*!< GCR_T::P2_MFP: P2_TYPE Position */
N#define SYS_P2_MFP_P2_TYPE_Msk                  (0xFFul << SYS_P2_MFP_P2_TYPE_Pos)      /*!< GCR_T::P2_MFP: P2_TYPE Mask */
N
N#define SYS_P2_MFP_P2_ALT_Pos                   8                                       /*!< GCR_T::P2_MFP: P2_ALT Position */
N#define SYS_P2_MFP_P2_ALT_Msk                   (0xFFul << SYS_P2_MFP_P2_ALT_Pos)       /*!< GCR_T::P2_MFP: P2_ALT Mask */
N
N#define SYS_P2_MFP_P2_MFP_Pos                   0                                       /*!< GCR_T::P2_MFP: P2_MFP Position */
N#define SYS_P2_MFP_P2_MFP_Msk                   (0xFFul << SYS_P2_MFP_P2_MFP_Pos)       /*!< GCR_T::P2_MFP: P2_MFP Mask */
N
N/* GCR P3_MFP Bit Field Definitions */
N#define SYS_P3_MFP_P3_TYPE_Pos                  16                                      /*!< GCR_T::P3_MFP: P3_TYPE Position */
N#define SYS_P3_MFP_P3_TYPE_Msk                  (0xFFul << SYS_P3_MFP_P3_TYPE_Pos)      /*!< GCR_T::P3_MFP: P3_TYPE Mask */
N
N#define SYS_P3_MFP_P3_ALT_Pos                   8                                       /*!< GCR_T::P3_MFP: P3_ALT Position */
N#define SYS_P3_MFP_P3_ALT_Msk                   (0xFFul << SYS_P3_MFP_P3_ALT_Pos)       /*!< GCR_T::P3_MFP: P3_ALT Mask */
N
N#define SYS_P3_MFP_P3_MFP_Pos                   0                                       /*!< GCR_T::P3_MFP: P3_MFP Position */
N#define SYS_P3_MFP_P3_MFP_Msk                   (0xFFul << SYS_P3_MFP_P3_MFP_Pos)       /*!< GCR_T::P3_MFP: P3_MFP Mask */
N
N/* GCR P4_MFP Bit Field Definitions */
N#define SYS_P4_MFP_P4_TYPE_Pos                  16                                      /*!< GCR_T::P4_MFP: P4_TYPE Position */
N#define SYS_P4_MFP_P4_TYPE_Msk                  (0xFFul << SYS_P4_MFP_P4_TYPE_Pos)      /*!< GCR_T::P4_MFP: P4_TYPE Mask */
N
N#define SYS_P4_MFP_P4_ALT_Pos                   8                                       /*!< GCR_T::P4_MFP: P4_ALT Position */
N#define SYS_P4_MFP_P4_ALT_Msk                   (0xFFul << SYS_P4_MFP_P4_ALT_Pos)       /*!< GCR_T::P4_MFP: P4_ALT Mask */
N
N#define SYS_P4_MFP_P4_MFP_Pos                   0                                       /*!< GCR_T::P4_MFP: P4_MFP Position */
N#define SYS_P4_MFP_P4_MFP_Msk                   (0xFFul << SYS_P4_MFP_P4_MFP_Pos)       /*!< GCR_T::P4_MFP: P4_MFP Mask */
N
N/* GCR REGWRPROT Bit Field Definitions */
N#define SYS_REGWRPROT_REGWRPROT_Pos             0                                       /*!< GCR_T::REGWRPROT: REGWRPROT Position */
N#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos) /*!< GCR_T::REGWRPROT: REGWRPROT Mask */
N
N#define SYS_REGWRPROT_REGPROTDIS_Pos            0                                       /*!< GCR_T::REGWRPROT: REGPROTDIS Position */
N#define SYS_REGWRPROT_REGPROTDIS_Msk            (1ul << SYS_REGWRPROT_REGPROTDIS_Pos)   /*!< GCR_T::REGWRPROT: REGPROTDIS Mask */
N/**@}*/ /* GCR_CONST */
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var GCR_INT_T::IRQSRC
N * Offset: 0x00-0x7C MCU IRQn(n=0~31) Interrupt Source Identity Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |INT_SRC   |Interrupt Source Identity
N * |        |          |IRQSRC[0].0 - BOD INT
N * |        |          |IRQSRC[0].1 - 0
N * |        |          |IRQSRC[0].2 - 0
N * |        |          |IRQSRC[1].0 - WDT INT
N * |        |          |IRQSRC[1].1 - 0
N * |        |          |IRQSRC[1].2 - 0
N * |        |          |IRQSRC[2].0 - EINT0, external interrupt 0 from P3.2
N * |        |          |IRQSRC[2].1 - 0
N * |        |          |IRQSRC[2].2 - 0
N * |        |          |IRQSRC[3].0 - EINT1, external interrupt 1 from P3.3
N * |        |          |IRQSRC[3].1 - 0
N * |        |          |IRQSRC[3].2 - 0
N * |        |          |IRQSRC[4].0 - P0 INT
N * |        |          |IRQSRC[4].1 - P1 INT
N * |        |          |IRQSRC[4].2 - 0
N * |        |          |IRQSRC[5].0 - P2 INT
N * |        |          |IRQSRC[5].1 - P3 INT
N * |        |          |IRQSRC[5].2 - P4 INT
N * |        |          |IRQSRC[6].0 - PWM0 INT
N * |        |          |IRQSRC[6].1 - PWM1 INT
N * |        |          |IRQSRC[6].2 - PWM2 INT
N * |        |          |IRQSRC[6].3 - PWM3 INT
N * |        |          |IRQSRC[7].0 - PWM4 INT
N * |        |          |IRQSRC[7].1 - PWM5 INT
N * |        |          |IRQSRC[7].2 - PWM6 INT
N * |        |          |IRQSRC[7].3 - PWM7 INT
N * |        |          |IRQSRC[8].0 - TIMER0 INT
N * |        |          |IRQSRC[8].1 - 0
N * |        |          |IRQSRC[8].2 - 0
N * |        |          |IRQSRC[9].0 - TIMER1 INT
N * |        |          |IRQSRC[9].1 - 0
N * |        |          |IRQSRC[9].2 - 0
N * |        |          |IRQSRC[10].0 - TIMER2 INT
N * |        |          |IRQSRC[10].1 - 0
N * |        |          |IRQSRC[10].2 - 0
N * |        |          |IRQSRC[11].0 - TIMER3 INT
N * |        |          |IRQSRC[11].1 - 0
N * |        |          |IRQSRC[11].2 - 0
N * |        |          |IRQSRC[12].0 - UART0 INT
N * |        |          |IRQSRC[12].1 - 0
N * |        |          |IRQSRC[12].2 - 0
N * |        |          |IRQSRC[13].0 - UART1 INT
N * |        |          |IRQSRC[13].1 - 0
N * |        |          |IRQSRC[13].2 - 0
N * |        |          |IRQSRC[14].0 - SPI0 INT
N * |        |          |IRQSRC[14].1 - 0
N * |        |          |IRQSRC[14].2 - 0
N * |        |          |IRQSRC[15].0 - SPI1 INT
N * |        |          |IRQSRC[15].1 - 0
N * |        |          |IRQSRC[15].2 - 0
N * |        |          |IRQSRC[16].0 - 0
N * |        |          |IRQSRC[16].1 - 0
N * |        |          |IRQSRC[16].2 - 0
N * |        |          |IRQSRC[17].0 - 0
N * |        |          |IRQSRC[17].1 - 0
N * |        |          |IRQSRC[17].2 - 0
N * |        |          |IRQSRC[18].0 - I2C0 INT
N * |        |          |IRQSRC[18].1 - 0
N * |        |          |IRQSRC[18].2 - 0
N * |        |          |IRQSRC[19].0 - I2C1 INT
N * |        |          |IRQSRC[19].1 - 0
N * |        |          |IRQSRC[19].2 - 0
N * |        |          |IRQSRC[20].0 - 0
N * |        |          |IRQSRC[20].1 - 0
N * |        |          |IRQSRC[20].2 - 0
N * |        |          |IRQSRC[21].0 - 0
N * |        |          |IRQSRC[21].1 - 0
N * |        |          |IRQSRC[21].2 - 0
N * |        |          |IRQSRC[22].0 - 0
N * |        |          |IRQSRC[22].1 - 0
N * |        |          |IRQSRC[22].2 - 0
N * |        |          |IRQSRC[23].0 - 0
N * |        |          |IRQSRC[23].1 - 0
N * |        |          |IRQSRC[23].2 - 0
N * |        |          |IRQSRC[24].0 - 0
N * |        |          |IRQSRC[24].1 - 0
N * |        |          |IRQSRC[24].2 - 0
N * |        |          |IRQSRC[25].0 - ACMP0 INT
N * |        |          |IRQSRC[25].1 - 0
N * |        |          |IRQSRC[25].2 - 0
N * |        |          |IRQSRC[26].0 - ACMP1 INT
N * |        |          |IRQSRC[26].1 - 0
N * |        |          |IRQSRC[26].2 - 0
N * |        |          |IRQSRC[27].0 - 0
N * |        |          |IRQSRC[27].1 - 0
N * |        |          |IRQSRC[27].2 - 0
N * |        |          |IRQSRC[28].0 - Power Down Wake up INT
N * |        |          |IRQSRC[28].1 - 0
N * |        |          |IRQSRC[28].2 - 0
N * |        |          |IRQSRC[29].0 - ADC INT
N * |        |          |IRQSRC[29].1 - 0
N * |        |          |IRQSRC[29].2 - 0
N * |        |          |IRQSRC[30].0 - 0
N * |        |          |IRQSRC[30].1 - 0
N * |        |          |IRQSRC[30].2 - 0
N * |        |          |IRQSRC[31].0 - 0
N * |        |          |IRQSRC[31].1 - 0
N * |        |          |IRQSRC[31].2 - 0
N * @var GCR_INT_T::NMISEL
N * Offset: 0x80 NMI Interrupt Source Select Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[4:0]   |NMI_SEL   |NMI interrupt source selection
N * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of the interrupt[31:0]
N * |        |          |The NMI_SEL bit[4:0] used to select the NMI interrupt source
N * |[8]     |NMI_EN    |NMI interrupt enable (write-protection bit)
N * |        |          |1 = Enable NMI interrupt
N * |        |          |0 = Disable NMI interrupt
N * |        |          |This bit is the protected bit.
N * |        |          |It means programming this needs to write "59h", "16h", "88h"to address 0x5000_0100 to disable register protection.
N * |        |          |Reference the register REGWRPROT at address GCR_BA+0x100
N */
N
N    __I  uint32_t IRQSRC[32];    /* Offset: 0x00-0x7C MCU IRQn(n=0~31) Interrupt Source Identity Register            */
X    volatile const  uint32_t IRQSRC[32];     
N    __IO uint32_t NMISEL;        /* Offset: 0x80 NMI Interrupt Source Select Control Register                        */
X    volatile uint32_t NMISEL;         
N
N} GCR_INT_T;
N
N
N
N/** @addtogroup INT_CONST INT Bit Field Definition
N  Constant Definitions for INT Controller
N  @{
N */
N
N/* INT IRQSRC Bit Field Definitions */
N#define INT_IRQSRC_INT_SRC_Pos                  0                                       /*!< GCR_INT_T::IRQSRC: INT_SRC Position */
N#define INT_IRQSRC_INT_SRC_Msk                  (0xFul << INT_IRQSRC_INT_SRC_Pos)       /*!< GCR_INT_T::IRQSRC: INT_SRC Mask */
N
N/* INT NMI_SEL Bit Field Definitions */
N#define INT_NMI_SEL_NMI_EN_Pos                  8                                       /*!< GCR_INT_T::NMISEL: NMI_EN Position */
N#define INT_NMI_SEL_NMI_EN_Msk                  (1ul << INT_NMI_SEL_NMI_EN_Pos)         /*!< GCR_INT_T::NMISEL: NMI_EN Mask */
N
N#define INT_NMI_SEL_NMI_SEL_Pos                 0                                       /*!< GCR_INT_T::NMISEL: NMI_SEL Position */
N#define INT_NMI_SEL_NMI_SEL_Msk                 (0x1Ful << INT_NMI_SEL_NMI_SEL_Pos)     /*!< GCR_INT_T::NMISEL: NMI_SEL Mask */
N/**@}*/ /* INT_CONST */
N/**@}*/ /* GCR */
N
N
N
N/*----------------------------- TIMER Controller -----------------------------*/
N/** @addtogroup TIMER TIMER Controller(TIMER)
N  Memory Mapped Structure for Timer Controller
N  @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var TIMER_T::TCSR
N * Offset: 0x00  Timer Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |PRESCALE  |Pre-scale Counter
N * |        |          |Clock input is divided by PRESCALE+1 before it is fed to the counter. If
N * |        |          |PRESCALE=0, then there is no scaling.
N * |[16]    |TDR_EN    |Data Load Enable
N * |        |          |When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with
N * |        |          |the 24-bit up-timer value as the timer is counting.
N * |        |          |1 = Timer Data Register update enable.
N * |        |          |0 = Timer Data Register update disable.
N * |[25]    |CACT      |Timer Active Status Bit (Read only)
N * |        |          |This bit indicates the up-timer status.
N * |        |          |0 = Timer is not active.
N * |        |          |1 = Timer is active.
N * |[26]    |CRST      |Timer Reset Bit
N * |        |          |Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to
N * |        |          |0.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.
N * |[28:27] |MODE      |Timer Operating Mode
N * |        |          |00 =
N * |        |          |The timer is operating in the one-shot mode. The associated
N * |        |          |interrupt signal is generated once (if IE is enabled) and CEN is
N * |        |          |automatically cleared by hardware.
N * |        |          |01 =
N * |        |          |The timer is operating in the periodic mode. The associated
N * |        |          |interrupt signal is generated periodically (if IE is enabled).
N * |        |          |10 =
N * |        |          |The timer is operating in the toggle mode. The interrupt signal is
N * |        |          |generated periodically (if IE is enabled). And the associated
N * |        |          |signal (tout) is changing back and forth with 50% duty cycle.
N * |        |          |11 =
N * |        |          |Reserved
N * |[29]    |IE        |Interrupt Enable Bit
N * |        |          |1 = Enable timer Interrupt.
N * |        |          |0 = Disable timer Interrupt.
N * |        |          |If timer interrupt is enabled, the timer asserts its interrupt signal when the associated
N * |        |          |up-timer value is equal to TCMPR.
N * |[30]    |CEN       |Timer Enable Bit
N * |        |          |1 = Starts counting
N * |        |          |0 = Stops/Suspends counting
N * |        |          |Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up
N * |        |          |counting from the last stop counting value.
N * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00)
N * |        |          |when the associated timer interrupt is generated (IE[29]=1).
N * @var TIMER_T::TCMPR
N * Offset: 0x04  Timer Compare Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TCMP      |Timer Compared Value
N * |        |          |TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value
N * |        |          |is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with
N * |        |          |TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
N * |        |          |Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
N * |        |          |NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
N * |        |          |NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register,
N * |        |          |TIMER will restart counting using this new value and abort previous count.
N * @var TIMER_T::TISR
N * Offset: 0x08  Timer Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TIF       |Timer Interrupt Flag
N * |        |          |This bit indicates the interrupt status of Timer.
N * |        |          |TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer
N * |        |          |compared value (TCMP). It is cleared by writing 1 to this bit.
N * @var TIMER_T::TDR
N * Offset: 0x0C  Timer Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TDR       |Timer Data Register
N * |        |          |When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR.
N * |        |          |User can read this register for the up-timer value.
N * @var TIMER_T::TCAP
N * ===================================================================================================
N * Offset: 0x10  Timer Capture Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TCAP      |Timer Capture Data Register
N * |        |          |When TEXEN (TEXCON[3]) is set, RSTCAPSEL (TTXCON[4]) is 0, and the transition on the TEX pins associated TEX_EDGE(TEXCON[2:1]) setting is occurred,
N * |        |          |the internal 24-bit up-timer value will be loaded into TCAP. User can read this register for the counter value.
N * @var TIMER_T::TEXCON
N * Offset: 0x14  Timer External Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TX_PHASE  |Timer External Count Phase
N * |        |          |This bit indicates the external count pin phase.
N * |        |          |1 = A rising edge of external count pin will be counted.
N * |        |          |0 = A falling edge of external count pin will be counted.
N * |[2:1]   |TEX_EDGE  |Timer External Pin Edge Detect
N * |        |          |00 = a 1 to 0 transition on TEX will be detected.
N * |        |          |01 = a 0 to 1 transition on TEX will be detected.
N * |        |          |10 = either 1 to 0 or 0 to 1 transition on TEX will be detected.
N * |        |          |11 = Reserved.
N * |[3]     |TEXEN     |Timer External Pin Enable.
N * |        |          |This bit enables the reset/capture function on the TEX pin.
N * |        |          |1 = The transition detected on the TEX pin will result in capture or reset of timer counter.
N * |        |          |0 = The TEX pin will be ignored.
N * |[4]     |RSTCAPSEL |Timer External Reset Counter / Capture mode select
N * |        |          |1 = TEX transition is using as the timer counter reset function.
N * |        |          |0 = TEX transition is using as the timer capture function.
N * |[5]     |TEXIEN    |Timer External interrupt Enable Bit
N * |        |          |1 = Enable timer External Interrupt
N * |        |          |0 = Disable timer External Interrupt
N * |        |          |If timer external interrupt is enabled, the timer asserts its external interrupt signal and sent to NVIC to inform CPU
N * |        |          |when the transition on the TEX pins associated with TEX_EDGE(TEXCON[2:1]) setting is happened.
N * |        |          |For example, while TEXIEN = 1, TEXEN = 1, and TEX_EDGE = 00,
N * |        |          |a 1 to 0 transition on the TEX pin will cause the TEXIF(TEXISR[0]) interrupt flag to be set then the interrupt signal is generated and sent to NVIC to inform CPU.
N * |[6]     |TEXDB     |Timer External Capture pin De-bounce enable bit
N * |        |          |1 = Enable De-bounce
N * |        |          |0 = Disable De-bounce
N * |        |          |If this bit is enabled, the edge of T0EX~T3EX pin is detected with de-bounce circuit.
N * |[7]     |TCDB      |Timer Counter pin De-bounce enable bit
N * |        |          |1 = Enable De-bounce
N * |        |          |0 = Disable De-bounce
N * |        |          |If this bit is enabled, the edge of T0~T3 pin is detected with de-bounce circuit.
N * @var TIMER_T::TEXISR
N * Offset: 0x18  Timer External Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TEXIF     |Timer External Interrupt Flag
N * |        |          |This bit indicates the external interrupt status of Timer.
N * |        |          |This bit is set by hardware when TEXEN (TEXCON[3]) is to 1,and the transition on the TEX pins associated TEX_EDGE(TEXCON[2:1]) setting is occurred.
N * |        |          |It is cleared by writing 1 to this bit.
N * |        |          |For example, while TEXEN = 1, and TEX_EDGE = 00, a 1 to 0 transition on the TEX pin will cause the TEXIF to be set.
N */
N
N    __IO uint32_t TCSR;          /* Offset: 0x00  Timer Control Register                                             */
X    volatile uint32_t TCSR;           
N    __IO uint32_t TCMPR;         /* Offset: 0x04  Timer Compare Register                                             */
X    volatile uint32_t TCMPR;          
N    __IO uint32_t TISR;          /* Offset: 0x08  Timer Interrupt Status Register                                    */
X    volatile uint32_t TISR;           
N    __IO uint32_t TDR;           /* Offset: 0x0C  Timer Data Register                                                */
X    volatile uint32_t TDR;            
N    __IO uint32_t TCAP;          /* Offset: 0x10  Timer Capture Data Register                                        */
X    volatile uint32_t TCAP;           
N    __IO uint32_t TEXCON;        /* Offset: 0x14  Timer External Control Register                                    */
X    volatile uint32_t TEXCON;         
N    __IO uint32_t TEXISR;        /* Offset: 0x18  Timer External Interrupt Status Register                           */
X    volatile uint32_t TEXISR;         
N
N} TIMER_T;
N
N
N
N/** @addtogroup TMR_CONST Timer Bit Field Definition
N  Constant Definitions for Timer Controller
N  @{
N */
N
N/* TIMER TCSR Bit Field Definitions */
N#define TIMER_TCSR_DBGACK_TMR_Pos   31                                          /*!< TIMER_T::TCSR: DBGACK_TMR Position */
N#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER_T::TCSR: DBGACK_TMR Mask */
N
N#define TIMER_TCSR_CEN_Pos          30                                          /*!< TIMER_T::TCSR: CEN Position */
N#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)                 /*!< TIMER_T::TCSR: CEN Mask */
N
N#define TIMER_TCSR_IE_Pos           29                                          /*!< TIMER_T::TCSR: IE Position */
N#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)                  /*!< TIMER_T::TCSR: IE Mask */
N
N#define TIMER_TCSR_MODE_Pos         27                                          /*!< TIMER_T::TCSR: MODE Position */
N#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)              /*!< TIMER_T::TCSR: MODE Mask */
N
N#define TIMER_TCSR_CRST_Pos         26                                          /*!< TIMER_T::TCSR: CRST Position */
N#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)                /*!< TIMER_T::TCSR: CRST Mask */
N
N#define TIMER_TCSR_CACT_Pos         25                                          /*!< TIMER_T::TCSR: CACT Position */
N#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)                /*!< TIMER_T::TCSR: CACT Mask */
N
N#define TIMER_TCSR_CTB_Pos          24                                          /*!< TIMER_T::TCSR: CTB Position */
N#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)                 /*!< TIMER_T::TCSR: CTB Mask */
N
N#define TIMER_TCSR_WAKE_EN_Pos      23                                          /*!< TIMER_T::TCSR: WAKE_EN Position */
N#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)             /*!< TIMER_T::TCSR: WAKE_EN Mask */
N
N#define TIMER_TCSR_CAP_SRC_Pos      22                                          /*!< TIMER_T::TCSR: CAP_SRC Position */
N#define TIMER_TCSR_CAP_SRC_Msk      (1ul << TIMER_TCSR_CAP_SRC_Pos)             /*!< TIMER_T::TCSR: CAP_SRC Mask */
N
N#define TIMER_TCSR_TOUT_SEL_Pos     21                                          /*!< TIMER_T::TCSR: TOUT_SEL Position */
N#define TIMER_TCSR_TOUT_SEL_Msk     (1ul << TIMER_TCSR_TOUT_SEL_Pos)            /*!< TIMER_T::TCSR: TOUT_SEL Mask */
N
N#define TIMER_TCSR_ERIODIC_SEL_Pos  20                                          /*!< TIMER_T::TCSR: PERIODIC_SEL Position */
N#define TIMER_TCSR_ERIODIC_SEL_Msk  (1ul << TIMER_TCSR_ERIODIC_SEL_Pos)         /*!< TIMER_T::TCSR: PERIODIC_SEL Mask */
N
N#define TIMER_TCSR_INTR_TRG_EN_Pos  19                                          /*!< TIMER_T::TCSR: INTR_TRG_EN Position */
N#define TIMER_TCSR_INTR_TRG_EN_Msk  (1ul << TIMER_TCSR_INTR_TRG_EN_Pos)         /*!< TIMER_T::TCSR: INTR_TRG_EN Mask */
N
N#define TIMER_TCSR_TDR_EN_Pos       16                                          /*!< TIMER_T::TCSR: TDR_EN Position */
N#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)              /*!< TIMER_T::TCSR: TDR_EN Mask */
N
N#define TIMER_TCSR_PRESCALE_Pos     0                                           /*!< TIMER_T::TCSR: PRESCALE Position */
N#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)         /*!< TIMER_T::TCSR: PRESCALE Mask */
N
N/* TIMER TCMPR Bit Field Definitions */
N#define TIMER_TCMP_TCMP_Pos         0                                           /*!< TIMER_T::TCMPR: TCMP Position */
N#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)         /*!< TIMER_T::TCMPR: TCMP Mask */
N
N/* TIMER TISR Bit Field Definitions */
N#define TIMER_TISR_TWF_Pos          1                                           /*!< TIMER_T::TISR: TWF Position */
N#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)                 /*!< TIMER_T::TISR: TWF Mask */
N
N#define TIMER_TISR_TIF_Pos          0                                           /*!< TIMER_T::TISR: TIF Position */
N#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)                 /*!< TIMER_T::TISR: TIF Mask */
N
N/* TIMER TDR Bit Field Definitions */
N#define TIMER_TDR_TDR_Pos           0                                           /*!< TIMER_T::TDR: TDR Position */
N#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)           /*!< TIMER_T::TDR: TDR Mask */
N
N/* TIMER TCAP Bit Field Definitions */
N#define TIMER_TCAP_TCAP_Pos         0                                           /*!< TIMER_T::TCAP: TCAP Position */
N#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER_T::TCAP: TCAP Mask */
N
N/* TIMER TEXCON Bit Field Definitions */
N#define TIMER_TEXCON_TCDB_Pos       7                                           /*!< TIMER_T::TEXCON: TCDB Position */
N#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)              /*!< TIMER_T::TEXCON: TCDB Mask */
N
N#define TIMER_TEXCON_TEXDB_Pos      6                                           /*!< TIMER_T::TEXCON: TEXDB Position */
N#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)             /*!< TIMER_T::TEXCON: TEXDB Mask */
N
N#define TIMER_TEXCON_TEXIEN_Pos     5                                           /*!< TIMER_T::TEXCON: TEXIEN Position */
N#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)            /*!< TIMER_T::TEXCON: TEXIEN Mask */
N
N#define TIMER_TEXCON_RSTCAPSEL_Pos  4                                           /*!< TIMER_T::TEXCON: RSTCAPSEL Position */
N#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)         /*!< TIMER_T::TEXCON: RSTCAPSEL Mask */
N
N#define TIMER_TEXCON_TEXEN_Pos      3                                           /*!< TIMER_T::TEXCON: TEXEN Position */
N#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)             /*!< TIMER_T::TEXCON: TEXEN Mask */
N
N#define TIMER_TEXCON_TEX_EDGE_Pos   1                                           /*!< TIMER_T::TEXCON: TEX_EDGE Position */
N#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)        /*!< TIMER_T::TEXCON: TEX_EDGE Mask */
N
N#define TIMER_TEXCON_TX_PHASE_Pos   0                                           /*!< TIMER_T::TEXCON: TX_PHASE Position */
N#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)          /*!< TIMER_T::TEXCON: TX_PHASE Mask */
N
N/* TIMER TEXISR Bit Field Definitions */
N#define TIMER_TEXISR_TEXIF_Pos      0                                           /*!< TIMER_T::TEXISR: TEXIF Position */
N#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)             /*!< TIMER_T::TEXISR: TEXIF Mask */
N/**@}*/ /* TMR_CONST */
N/**@}*/ /* TIMER */
N
N
N
N/*------------------------- UART Interface Controller ------------------------*/
N
N/** @addtogroup UART UART Controller(UART)
N  Memory Mapped Structure for UART Serial Interface Controller
N  @{
N */
N
Ntypedef struct
N{
N
N
N
N/**
N * @var UART_T::DATA
N * Offset: 0x00 UART Data Transmit/Receive Holding Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DATA      |Data Register
N * |        |          |By writing to this register, the UART will send out an 8-bit data through the UART_TXD pin (LSB first).
N * |        |          |By reading this register, the UART will return an 8-bit data received from UART_RXD pin (LSB first).
N * @var UART_T::THR
N * Offset: 0x00 UART Transmit Holding Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |THR       |Transmit Holding Register
N * |        |          |By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB first).
N * @var UART_T::RBR
N * Offset: 0x00  UART Receive Buffer Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |RBR       |Receive Buffer Register (Read Only)
N * |        |          |By reading this register, the UART will return the 8-bit data received from RX pin (LSB first).
N * @var UART_T::IER
N * Offset: 0x04  UART Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable
N * |        |          |0 = Receive data available interrupt Disabled.
N * |        |          |1 = Receive data available interrupt Enabled.    
N * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable
N * |        |          |0 = Transmit holding register empty interrupt Disabled.
N * |        |          |1 = Transmit holding register empt interrupt Enabled.    
N * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable
N * |        |          |0 = Receive Line Status interrupt Disabled.
N * |        |          |1 = Receive Line Status interrupt Enabled.    
N * |[3]     |MODEM_IEN |Modem Status Interrupt Enable
N * |        |          |0 = Modem status interrupt Disabled.
N * |        |          |1 = Modem status interrupt Enabled.    
N * |[4]     |RTO_IEN   |RX Time-out Interrupt Enable
N * |        |          |0 = RX time-out interrupt Disabled.
N * |        |          |1 = RX time-out interrupt Enabled.     
N * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable
N * |        |          |0 = Buffer error interrupt Disabled.
N * |        |          |1 = Buffer error interrupt Enabled.   
N * |[6]     |WAKE_EN   |UART Wake-up Function Enable
N * |        |          |0 = UART wake-up function Disabled.
N * |        |          |1 = UART wake-up function Enabled, when chip is in Power-down mode, an external CTS change will wake up chip from Power-down mode.     
N * |[8]     |LIN_RX_BRK_IEN|LIN RX Break Field Detected Interrupt Enable Control
N * |        |          |0 = LIN bus RX break filed interrupt Disabled.
N * |        |          |1 = LIN bus RX break filed interrupt Enabled.
N * |        |          |Note: This bit is used for LIN function mode.     
N * |[11]    |TIME_OUT_EN|Time-out Counter Enable
N * |        |          |0 = Time-out counter Disabled.
N * |        |          |1 = Time-out counter Enabled.     
N * |[12]    |AUTO_RTS_EN|RTS Auto Flow Control Enable
N * |        |          |0 = RTS auto flow control Disabled.
N * |        |          |1 = RTS auto flow control Enabled.
N * |        |          |Note: When RTS auto-flow is enabled, if the number of bytes in the RX FIFO is equal to the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.    
N * |[13]    |AUTO_CTS_EN|CTS Auto Flow Control Enable
N * |        |          |0 = CTS auto flow control Disabled.
N * |        |          |1 = CTS auto flow control Enabled.
N * |        |          |Note: When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).
N * @var UART_T::FCR
N * Offset: 0x08  UART FIFO Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |RFR       |RX Field Software Reset
N * |        |          |When RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the RX internal state machine and pointers.
N * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
N * |[2]     |TFR       |TX Field Software Reset
N * |        |          |When TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the TX internal state machine and pointers.
N * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
N * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
N * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if RDA_IEN(UA_IER[0]) enabled, and an interrupt will be generated).
N * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
N * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
N * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
N * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
N * |[8]     |RX_DIS    |Receiver Disable 
N * |        |          |The receiver is disabled or not (set 1 to disable receiver)
N * |        |          |0 = Receiver Enabled.
N * |        |          |1 = Receiver Disabled.
N * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS485_NMM(UA_ALT_CSR [8]) is programmed.
N * |[19:16] |RTS_TRI_LEV|RTS Trigger Level For Auto-Flow Control Use
N * |        |          |0000 = RTS Trigger Level is 1 byte.
N * |        |          |0001 = RTS Trigger Level is 4 bytes.
N * |        |          |0010 = RTS Trigger Level is 8 bytes.
N * |        |          |0011 = RTS Trigger Level is 14 bytes.
N * |        |          |Note: This field is used for RTS auto-flow control.
N * @var UART_T::LCR
N * Offset: 0x0C  UART Line Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |WLS       |Word Length Select
N * |        |          |This field sets UART word length.    
N * |        |          |00 = 5 bits.
N * |        |          |01 = 6 bits.
N * |        |          |10 = 7 bits.
N * |        |          |11 = 8 bits.
N * |[2]     |NSB       |Number of "STOP bit"
N * |        |          |0 = One "STOP bit" is generated in the transmitted data.
N * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data. When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.     
N * |[3]     |PBE       |Parity Bit Enable
N * |        |          |0 = No parity bit.
N * |        |          |1 = Parity bit generated Enabled.
N * |        |          |Note : Parity bit is generated on each outgoing character and is checked on each incoming data.     
N * |[4]     |EPE       |Even Parity Enable
N * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
N * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
N * |        |          |Note: This bit has effect only when PBE (UA_LCR[3]) is set.     
N * |[5]     |SPE       |Stick Parity Enable
N * |        |          |0 = Stick parity Disabled.
N * |        |          |1 = Stick parity Enabled.
N * |        |          |Note: If PBE (UA_LCR[3]) and EPE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EPE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1.     
N * |[6]     |BCB       |Break Control Bit
N * |        |          |0 = Break Control Disabled.
N * |        |          |1 = Break Control Enabled.
N * |        |          |Note: When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.
N * @var UART_T::MCR
N * Offset: 0x10  UART Modem Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |RTS       |RTS (Request-To-Send) Signal Control
N * |        |          |This bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.
N * |        |          |0 = RTS signal is active.
N * |        |          |1 = RTS signal is inactive.
N * |        |          |Note1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.
N * |        |          |Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
N * |[9]     |LEV_RTS   |RTS Pin Active Level 
N * |        |          |This bit defines the active level state of RTS pin output.
N * |        |          |0 = RTS pin output is high level active.
N * |        |          |1 = RTS pin output is low level active.
N * |[13]    |RTS_ST    |RTS Pin State (Read Only)
N * |        |          |This bit mirror from RTS pin output of voltage logic status.
N * |        |          |0 = RTS pin output is low level voltage logic state.
N * |        |          |1 = RTS pin output is high level voltage logic state.
N * @var UART_T::MSR
N * Offset: 0x14  UART Modem Status Register 
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DCTSF     |Detect CTS State Change Flag (Read Only)
N * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.
N * |        |          |0 = CTS input has not change state.
N * |        |          |1 = CTS input has change state.
N * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N * |[4]     |CTS_ST    |CTS Pin Status (Read Only) 
N * |        |          |This bit mirror from CTS pin input of voltage logic status.
N * |        |          |0 = CTS pin input is low level voltage logic state.
N * |        |          |1 = CTS pin input is high level voltage logic state.
N * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected
N * |[8]     |LEV_CTS   |CTS Pin Active Level
N * |        |          |This bit defines the active level state of CTS pin input.
N * |        |          |0 = CTS pin input is high level active.
N * |        |          |1 = CTS pin input is low level active.
N * @var UART_T::FSR
N * Offset: 0x18  UART FIFO Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_OVER_IF|RX Overflow Error Interrupt Flag
N * |        |          |This bit is set when RX FIFO overflow.
N * |        |          |If the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, this bit will be set.
N * |        |          |0 = RX FIFO is not overflow.
N * |        |          |1 = RX FIFO is overflow.
N * |        |          |Note: This bit can be cleared by writing "1" to it.     
N * |[3]     |RS485_ADD_DETF|RS-485 Address Byte Detection Flag
N * |        |          |0 = Receiver detects a data that is not an address byte (bit 9 = "0").
N * |        |          |1 = Receiver detects a data that is an address byte (bit 9 = "1").
N * |        |          |Note1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode .
N * |        |          |Note2: This bit can be cleared by writing "1" to it.     
N * |[4]     |PEF       |Parity Error Flag
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
N * |        |          |0 = No parity error is generated.
N * |        |          |1 = Parity error is generated.
N * |        |          |Note: This bit can be cleared by writing "1" to it.
N * |[5]     |FEF       |Framing Error Flag
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.
N * |        |          |0 = No framing error is generated.
N * |        |          |1 = Framing error is generated.
N * |        |          |Note: This bit can be cleared by writing "1" to it.
N * |[6]     |BIF       |Break Interrupt Flag
N * |        |          |This bit is set to logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
N * |        |          |0 = No Break interrupt is generated.
N * |        |          |1 = Break interrupt is generated.
N * |        |          |Note: This bit can be cleared by writing "1" to it.
N * |[13:8]  |RX_POINTER|RX FIFO Pointer     
N * |        |          |This field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, RX_POINTER increases one. When one byte of RX FIFO is read by CPU, RX_POINTER decreases one.
N * |        |          |The Maximum value shown in RX_POINTER is 15. When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RXPTR will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15.     
N * |[14]    |RX_EMPTY  |Receiver FIFO Empty (Read Only)
N * |        |          |This bit initiate RX FIFO empty or not.
N * |        |          |0 = RX FIFO is not empty.
N * |        |          |1 = RX FIFO is empty.
N * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.     
N * |[15]    |RX_FULL   |Receiver FIFO Full (Read Only)
N * |        |          |This bit indicates RX FIFO full or not.
N * |        |          |0 = RX FIFO is not full.
N * |        |          |1 = RX FIFO is full.
N * |        |          |Note: This bit is set when the using level of RX FIFO Buffer equal to 16; otherwise, it is cleared by hardware. 
N * |[21:16] |TX_POINTER|TX FIFO Pointer (Read Only)     
N * |        |          |This field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, TX_POINTER decreases one.
N * |        |          |The Maximum value shown in TX_POINTER is 15. When the using level of TX FIFO Buffer equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15.     
N * |[22]    |TX_EMPTY  |Transmitter FIFO Empty (Read Only)
N * |        |          |This bit indicates TX FIFO is empty or not.
N * |        |          |0 = TX FIFO is not empty.     
N * |        |          |1 = TX FIFO is empty.
N * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into UA_THR (TX FIFO not empty).     
N * |[23]    |TX_FULL   |Transmitter FIFO Full (Read Only)
N * |        |          |This bit indicates TX FIFO full or not.
N * |        |          |0 = TX FIFO is not full.
N * |        |          |1 = TX FIFO is full.
N * |        |          |Note: This bit is set when the using level of TX FIFO Buffer equal to 16; otherwise, it is cleared by hardware.     
N * |[24]    |TX_OVER_IF|Tx Overflow Error Interrupt Flag     
N * |        |          |If TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1.
N * |        |          |0 = TX FIFO is not overflow.
N * |        |          |1 = TX FIFO is overflow.
N * |        |          |Note: This bit can be cleared by writing "1" to it.     
N * |[28]    |TE_FLAG   |Transmitter Empty Flag (Read Only)
N * |        |          |This bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.
N * |        |          |0 = TX FIFO is not empty or the STOP bit of the last byte has been not transmitted.
N * |        |          |1 = TX FIFO is empty and the STOP bit of the last byte has been transmitted.
N * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
N * @var UART_T::ISR
N * Offset: 0x1C  UART Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only)
N * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set.
N * |        |          |If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.
N * |        |          |0 = No RDA interrupt flag is generated.
N * |        |          |1 = RDA interrupt flag is generated.
N * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4])).
N * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only)
N * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
N * |        |          |If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.
N * |        |          |0 = No THRE interrupt flag is generated.
N * |        |          |1 = THRE interrupt flag is generated.
N * |        |          |Note: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).
N * |[2]     |RLS_IF    |Receive Line Interrupt Flag (Read Only)
N * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set).
N * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
N * |        |          |0 = No RLS interrupt flag is generated.
N * |        |          |1 = RLS interrupt flag is generated.
N * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received address byte character (bit9 = '1') bit.
N * |        |          |At the same time, the bit of UA_FSR[RS485_ADD_DETF] is also set.
N * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.
N * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.
N * |[3]     |MODEM_IF  |MODEM Interrupt Flag (Read Only) 
N * |        |          |This bit is set when the CTS pin has state change (DCTSF (UA_MSR[0]) = 1).
N * |        |          |If MODEM_IEN (UA_IER [3]) is enabled, the Modem interrupt will be generated.
N * |        |          |0 = No Modem interrupt flag is generated.
N * |        |          |1 = Modem interrupt flag is generated.
N * |        |          |Note: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).
N * |[4]     |TOUT_IF   |Time-Out Interrupt Flag (Read Only)
N * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
N * |        |          |If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.
N * |        |          |0 = No Time-out interrupt flag is generated.
N * |        |          |1 = Time-out interrupt flag is generated.
N * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it
N * |[5]     |BUF_ERR_IF|Buffer Error Interrupt Flag (Read Only)
N * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set).
N * |        |          |When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct.
N * |        |          |If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.
N * |        |          |0 = No buffer error interrupt flag is generated.
N * |        |          |1 = Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is generated.
N * |        |          |1 = Buffer error interrupt flag is generated.
N * |        |          |Note: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared
N * |[7]     |LIN_RX_BREAK_IF|LIN Bus RX Break Field Detected Flag
N * |        |          |This bit is set when RX received LIN Break Field. If LIN_RX_BRK_IEN(UA_IER[8]) is enabled the LIN RX Break interrupt will be generated.
N * |        |          |0 = No LIN RX Break received.
N * |        |          |1 = LIN RX Break received.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.
N * |        |          |0 = No RDA interrupt is generated.
N * |        |          |1 = RDA interrupt is generated.
N * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator (Read Only)
N * |        |          |This bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.
N * |        |          |0 = No THRE interrupt is generated.
N * |        |          |1 = THRE interrupt is generated.
N * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.
N * |        |          |0 = No RLS interrupt is generated.
N * |        |          |1 = RLS interrupt is generated
N * |[11]    |MODEM_INT |MODEM Status Interrupt Indicator (Read Only)
N * |        |          |This bit is set if MODEM_IEN(UA_IER[3]) and MODEM_IF(UA_ISR[4]) are both set to 1
N * |        |          |0 = No Modem interrupt is generated.
N * |        |          |1 = Modem interrupt is generated.
N * |[12]    |TOUT_INT  |Time-Out Interrupt Indicator (Read Only)
N * |        |          |This bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.
N * |        |          |0 = No Tout interrupt is generated.
N * |        |          |1 = Tout interrupt is generated.
N * |[13]    |BUF_ERR_INT|Buffer Error Interrupt Indicator (Read Only)
N * |        |          |This bit is set if BUF_ERR_IEN(UA_IER[5]) and BUF_ERR_IF(UA_ISR[5]) are both set to 1.
N * |        |          |0 = No buffer error interrupt is generated.
N * |        |          |1 = Buffer error interrupt is generated.
N * |[15]    |LIN_RX_BREAK_INT|LIN Bus RX Break Field Detected Interrupt Indicator (Read Only)
N * |        |          |This bit is set if LIN_RX_BRK_IEN(UA_IER[8]) and LIN_RX_BRK_IFLIN_IF(UA_ISR[7]) are both set to 1.
N * |        |          |0 = No LIN RX Break interrupt is generated.
N * |        |          |1 = LIN RX Break interrupt is generated.
N * @var UART_T::TOR
N * Offset: 0x20  UART Time-out Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TOIC      |Time-Out Interrupt Comparator
N * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.
N * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UA_TOR[7:0])), a receiver time-out interrupt (INT_TOUT) is generated if TOUT_IEN (UA_IER [4]) enabled.
N * |        |          |A new incoming data word or RX FIFO empty will clear TOUT_INT(UA_IER[9]).
N * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC (UA_TOR[7:0]) value should be set between 40 and 255.
N * |        |          |So, for example, if TOIC (UA_TOR[7:0]) is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
N * |[15:8]  |DLY       |TX Delay Time Value
N * |        |          |This field is used to programming the transfer delay time between the last stop bit and next start bit.
N * @var UART_T::BAUD
N * Offset: 0x24  UART Baud Rate Divisor Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |BRD       |Baud Rate Divider
N * |        |          |The field indicates the baud rate divider.
N * |[27:24] |DIVIDER_X |Divider X
N * |        |          |The baud rate divider M = X+1.
N * |[28]    |DIV_X_ONE |Divider X Equal To 1
N * |        |          |0 = Divider M is X+1 (the equation of M = X+1, but DIVIDER_X[27:24] must >= 8).
N * |        |          |1 = Divider M is 1 (the equation of M = 1, but BRD [15:0] must >= 3).  
N * |[29]    |DIV_X_EN  |Divider X Enable
N * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is
N * |        |          |Baud Rate = Clock / [M * (BRD + 2)]; The default value of M is 16.
N * |        |          |0 = Divider X Disabled (the equation of M = 16).
N * |        |          |1 = Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must >= 8).
N * |        |          |Note: In IrDA mode, this bit must disable.
N * @var UART_T::IRCR
N * Offset: 0x28  UART IrDA Control Register 
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |TX_SELECT |TX_SELECT
N * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled.
N * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
N * |[5]     |INV_TX    |IrDA inverse Transmitting Output Signal Control
N * |        |          |0 = None inverse transmitting signal.
N * |        |          |1 = Inverse transmitting output signal.
N * |[6]     |INV_RX    |IrDA inverse Receive Input Signal Control
N * |        |          |0 = None inverse receiving input signal.
N * |        |          |1 = Inverse receiving input signal.
N * @var UART_T::ALT_CSR
N * Offset: 0x2C  UART Alternate Control/Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |LIN_BKFL  |UART LIN Break Field Length
N * |        |          |This field indicates a 4-bit LIN TX break field count.
N * |        |          |Note1: This break field length is UA_LIN_BKFL + 1.
N * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
N * |[6]     |LIN_RX_EN |LIN RX Enable
N * |        |          |0 = LIN RX mode Disabled.
N * |        |          |1 = LIN RX mode Enabled.
N * |[7]     |LIN_TX_EN |LIN TX Break Mode Enable
N * |        |          |0 = LIN TX Break mode Disabled.
N * |        |          |1 = LIN TX Break mode Enabled.
N * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
N * |[8]     |RS485_NMM |RS-485 Normal Multi-Drop Operation Mode (NMM)
N * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
N * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
N * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
N * |[9]     |RS485_AAD |RS-485 Auto Address Detection Operation Mode (AAD)
N * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
N * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
N * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
N * |[10]    |RS485_AUD |RS-485 Auto Direction Mode (AUD)
N * |        |          |0 = RS-485 Auto Direction Operation mode (AUO) Disabled.
N * |        |          |1 = RS-485 Auto Direction Operation mode (AUO) Enabled.
N * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
N * |[15]    |RS485_ADD_EN|RS-485 Address Detection Enable
N * |        |          |This bit is used to enable RS-485 Address Detection mode.
N * |        |          |0 = Address detection mode Disabled.
N * |        |          |1 = Address detection mode Enabled.
N * |        |          |Note: This bit is used for RS-485 any operation mode.
N * |[31:24] |ADDR_MATCH|Address Match Value
N * |        |          |This field contains the RS-485 address match values.
N * |        |          |Note: This field is used for RS-485 auto address detection mode.
N * @var UART_T::FUN_SEL
N * Offset: 0x30  UART Function Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |FUN_SEL   |Function Select Enable
N * |        |          |00 = UART Function.
N * |        |          |01 = LIN Function.
N * |        |          |10 = IrDA Function.
N * |        |          |11 = RS-485 Function.
N */
N
N    union {
N        __IO uint32_t DATA;          /* Offset: 0x00 UART Transmit Holding Register                                      */
X        volatile uint32_t DATA;           
N        __IO uint32_t THR;           /* Offset: 0x00 UART Transmit Holding Register                                      */
X        volatile uint32_t THR;            
N        __IO uint32_t RBR;           /* Offset: 0x00 UART Receive Buffer Register                                        */
X        volatile uint32_t RBR;            
N    };
N    __IO uint32_t IER;           /* Offset: 0x04  UART Interrupt Enable Register                                     */
X    volatile uint32_t IER;            
N    __IO uint32_t FCR;           /* Offset: 0x08  UART FIFO Control Register                                         */
X    volatile uint32_t FCR;            
N    __IO uint32_t LCR;           /* Offset: 0x0C  UART Line Control Register                                         */
X    volatile uint32_t LCR;            
N    __IO uint32_t MCR;           /* Offset: 0x10  UART Modem Control Register                                        */
X    volatile uint32_t MCR;            
N    __IO uint32_t MSR;           /* Offset: 0x14  UART Modem Status Register                                         */
X    volatile uint32_t MSR;            
N    __IO uint32_t FSR;           /* Offset: 0x18  UART FIFO Status Register                                          */
X    volatile uint32_t FSR;            
N    __IO uint32_t ISR;           /* Offset: 0x1C  UART Interrupt Status Register                                     */
X    volatile uint32_t ISR;            
N    __IO uint32_t TOR;           /* Offset: 0x20  UART Time-out Register                                             */
X    volatile uint32_t TOR;            
N    __IO uint32_t BAUD;          /* Offset: 0x24  UART Baud Rate Divisor Register                                    */
X    volatile uint32_t BAUD;           
N    __IO uint32_t IRCR;          /* Offset: 0x28  UART IrDA Control Register                                         */
X    volatile uint32_t IRCR;           
N    __IO uint32_t ALT_CSR;       /* Offset: 0x2C  UART Alternate Control/Status Register                             */
X    volatile uint32_t ALT_CSR;        
N    __IO uint32_t FUN_SEL;       /* Offset: 0x30  UART Function Select Register                                      */
X    volatile uint32_t FUN_SEL;        
N} UART_T;
N
N
N
N/** @addtogroup UART_CONST UART Bit Field Definition
N  Constant Definitions for UART Controller
N  @{
N */
N
N/* UART THR Bit Field Definitions */
N#define UART_THR_THR_Pos            0                                       /*!< UART_T::THR: THR Position  */
N#define UART_THR_THR_Msk            (0xFul << UART_THR_THR_Pos)             /*!< UART_T::THR: THR Mask      */
N
N/* UART RBR Bit Field Definitions */
N#define UART_RBR_RBR_Pos            0                                       /*!< UART_T::RBR: RBR Position */
N#define UART_RBR_RBR_Msk            (0xFul << UART_RBR_RBR_Pos)             /*!< UART_T::RBR: RBR Mask      */
N
N/* UART IER Bit Field Definitions */
N#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART_T::IER: AUTO_CTS_EN Position      */
N#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART_T::IER: AUTO_CTS_EN Mask           */
N
N#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART_T::IER: AUTO_RTS_EN Position      */
N#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART_T::IER: AUTO_RTS_EN Mask           */
N
N#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART_T::IER: TIME_OUT_EN Position      */
N#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART_T::IER: TIME_OUT_EN Mask           */
N
N#define UART_IER_LIN_RX_BRK_IEN_Pos 8                                       /*!< UART_T::IER: LIN_RX_BRK_IEN Position   */
N#define UART_IER_LIN_RX_BRK_IEN_Msk (1ul << UART_IER_LIN_RX_BRK_IEN_Pos)    /*!< UART_T::IER: LIN_RX_BRK_IEN Mask        */
N
N#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART_T::IER: WAKE_EN Position          */
N#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART_T::IER: WAKE_EN Mask               */
N
N#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART_T::IER: BUF_ERR_IEN Position      */
N#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART_T::IER: BUF_ERR_IEN Mask           */
N
N#define UART_IER_RTO_IEN_Pos        4                                       /*!< UART_T::IER: RTO_IEN Position          */
N#define UART_IER_RTO_IEN_Msk        (1ul << UART_IER_RTO_IEN_Pos)           /*!< UART_T::IER: RTO_IEN Mask               */
N
N#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART_T::IER: MODEM_IEN Position        */
N#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART_T::IER: MODEM_IEN Mask             */
N
N#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART_T::IER: RLS_IEN Position          */
N#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART_T::IER: RLS_IEN Mask               */
N
N#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART_T::IER: THRE_IEN Position         */
N#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART_T::IER: THRE_IEN Mask              */
N
N#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART_T::IER: RDA_IEN Position           */
N#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART_T::IER: RDA_IEN Mask               */
N
N/* UART FCR Bit Field Definitions */
N#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART_T::FCR: RTS_TRI_LEV Position       */
N#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART_T::FCR: RTS_TRI_LEV Mask           */
N
N#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART_T::FCR: RX_DIS Position            */
N#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART_T::FCR: RX_DIS Mask                */
N
N#define UART_FCR_RFITL_Pos          4                                       /*!< UART_T::FCR: RFITL Position             */
N#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART_T::FCR: RFITL Mask                 */
N
N#define UART_FCR_TFR_Pos            2                                       /*!< UART_T::FCR: TFR Position               */
N#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART_T::FCR: TFR Mask                   */
N
N#define UART_FCR_RFR_Pos            1                                       /*!< UART_T::FCR: RFR Position               */
N#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART_T::FCR: RFR Mask                   */
N
N/* UART LCR Bit Field Definitions */
N#define UART_LCR_BCB_Pos            6                                       /*!< UART_T::LCR: BCB Position               */
N#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART_T::LCR: BCB Mask                   */
N
N#define UART_LCR_SPE_Pos            5                                       /*!< UART_T::LCR: SPE Position               */
N#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART_T::LCR: SPE Mask                   */
N
N#define UART_LCR_EPE_Pos            4                                       /*!< UART_T::LCR: EPE Position               */
N#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART_T::LCR: EPE Mask                   */
N
N#define UART_LCR_PBE_Pos            3                                       /*!< UART_T::LCR: PBE Position               */
N#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART_T::LCR: PBE Mask                   */
N
N#define UART_LCR_NSB_Pos            2                                       /*!< UART_T::LCR: NSB Position               */
N#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART_T::LCR: NSB Mask                   */
N
N#define UART_LCR_WLS_Pos            0                                       /*!< UART_T::LCR: WLS Position               */
N#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART_T::LCR: WLS Mask                   */
N
N/* UART MCR Bit Field Definitions */
N#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART_T::MCR: RTS_ST Position            */
N#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART_T::MCR: RTS_ST Mask                */
N
N#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART_T::MCR: LEV_RTS Position           */
N#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART_T::MCR: LEV_RTS Mask               */
N
N#define UART_MCR_RTS_Pos            1                                       /*!< UART_T::MCR: RTS Position               */
N#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART_T::MCR: RTS Mask                   */
N
N/* UART MSR Bit Field Definitions */
N#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART_T::MSR: LEV_CTS Position           */
N#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART_T::MSR: LEV_CTS Mask               */
N
N#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART_T::MSR: CTS_ST Position            */
N#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART_T::MSR: CTS_ST Mask                */
N
N#define UART_MSR_DCTSF_Pos          0                                       /*!< UART_T::MSR: DCTST Position             */
N#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART_T::MSR: DCTST Mask                 */
N
N/* UART FSR Bit Field Definitions */
N#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART_T::FSR: TE_FLAG Position           */
N#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART_T::FSR: TE_FLAG Mask               */
N
N#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART_T::FSR: TX_OVER_IF Position        */
N#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART_T::FSR: TX_OVER_IF Mask            */
N
N#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART_T::FSR: TX_FULL Position           */
N#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART_T::FSR: TX_FULL Mask               */
N
N#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART_T::FSR: TX_EMPTY Position          */
N#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART_T::FSR: TX_EMPTY Mask              */
N
N#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART_T::FSR: TX_POINTER Position        */
N#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART_T::FSR: TX_POINTER Mask            */
N
N#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART_T::FSR: RX_FULL Position           */
N#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART_T::FSR: RX_FULL Mask               */
N
N#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART_T::FSR: RX_EMPTY Position          */
N#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART_T::FSR: RX_EMPTY Mask              */
N
N#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART_T::FSR: RX_POINTERS Position       */
N#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART_T::FSR: RX_POINTER Mask            */
N
N#define UART_FSR_BIF_Pos            6                                       /*!< UART_T::FSR: BIF Position               */
N#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART_T::FSR: BIF Mask                   */
N
N#define UART_FSR_FEF_Pos            5                                       /*!< UART_T::FSR: FEF Position               */
N#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART_T::FSR: FEF Mask                   */
N
N#define UART_FSR_PEF_Pos            4                                       /*!< UART_T::FSR: PEF Position               */
N#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART_T::FSR: PEF Mask                   */
N
N#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART_T::FSR: RS485_ADD_DETF Position    */
N#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART_T::FSR: RS485_ADD_DETF Mask        */
N
N#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART_T::FSR: RX_OVER_IF Position        */
N#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART_T::FSR: RX_OVER_IF Mask            */
N
N/* UART ISR Bit Field Definitions */
N#define UART_ISR_LIN_RX_BREAK_INT_Pos    15                                      /*!< UART_T::ISR: LIN_RX_BREAK_INT Position       */
N#define UART_ISR_LIN_RX_BREAK_INT_Msk    (1ul << UART_ISR_LIN_RX_BREAK_INT_Pos)  /*!< UART_T::ISR: LIN_RX_BREAK_INT Mask           */
N
N#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART_T::ISR: BUF_ERR_INT Position       */
N#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART_T::ISR: BUF_ERR_INT Mask           */
N
N#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART_T::ISR: TOUT_INT Position          */
N#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART_T::ISR: TOUT_INT Mask              */
N
N#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART_T::ISR: MODEM_INT Position         */
N#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART_T::ISR: MODEM_INT Mask             */
N
N#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART_T::ISR: RLS_INT Position           */
N#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART_T::ISR: RLS_INT Mask               */
N
N#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART_T::ISR: THRE_INT Position          */
N#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART_T::ISR: THRE_INT Mask              */
N
N#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART_T::ISR: RDA_INT Position           */
N#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART_T::ISR: RDA_INT Mask               */
N
N#define UART_ISR_LIN_RX_BREAK_IF_Pos 7                                      /*!< UART_T::ISR: LIN RX BREAK IF Position   */
N#define UART_ISR_LIN_RX_BREAK_IF_Msk (1ul << UART_ISR_LIN_RX_BREAK_IF_Pos)  /*!< UART_T::ISR: LIN RX BREAK IF Mask       */
N
N#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART_T::ISR: BUF_ERR_IF Position        */
N#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART_T::ISR: BUF_ERR_IF Mask            */
N
N#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART_T::ISR: TOUT_IF Position           */
N#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART_T::ISR: TOUT_IF Mask               */
N
N#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART_T::ISR: MODEM_IF Position          */
N#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART_T::ISR: MODEM_IF Mask              */
N
N#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART_T::ISR: RLS_IF Position            */
N#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART_T::ISR: RLS_IF Mask                */
N
N#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART_T::ISR: THRE_IF Position           */
N#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART_T::ISR: THRE_IF Mask               */
N
N#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART_T::ISR: RDA_IF Position            */
N#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART_T::ISR: RDA_IF Mask                */
N
N/* UART TOR Bit Field Definitions */
N#define UART_TOR_DLY_Pos            8                                       /*!< UART_T::TOR: DLY Position               */
N#define UART_TOR_DLY_Msk            (0xFFul << UART_TOR_DLY_Pos)            /*!< UART_T::TOR: DLY Mask                   */
N
N#define UART_TOR_TOIC_Pos           0                                       /*!< UART_T::TOR: TOIC Position              */
N#define UART_TOR_TOIC_Msk           (0xFFul << UART_TOR_TOIC_Pos)           /*!< UART_T::TOR: TOIC Mask                  */
N
N/* UART BAUD Bit Field Definitions */
N#define UART_BAUD_DIV_X_EN_Pos      29                                      /*!< UART_T::BAUD: DIV_X_EN Position         */
N#define UART_BAUD_DIV_X_EN_Msk      (1ul << UART_BAUD_DIV_X_EN_Pos)         /*!< UART_T::BAUD: DIV_X_EN Mask             */
N
N#define UART_BAUD_DIV_X_ONE_Pos     28                                      /*!< UART_T::BAUD: DIV_X_ONE Position        */
N#define UART_BAUD_DIV_X_ONE_Msk     (1ul << UART_BAUD_DIV_X_ONE_Pos)        /*!< UART_T::BAUD: DIV_X_ONE Mask            */
N
N#define UART_BAUD_DIVIDER_X_Pos     24                                      /*!< UART_T::BAUD: DIVIDER_X Position        */
N#define UART_BAUD_DIVIDER_X_Msk     (0xFul << UART_BAUD_DIVIDER_X_Pos)      /*!< UART_T::BAUD: DIVIDER_X Mask            */
N
N#define UART_BAUD_BRD_Pos           0                                       /*!< UART_T::BAUD: BRD Position              */
N#define UART_BAUD_BRD_Msk           (0xFFFFul << UART_BAUD_BRD_Pos)         /*!< UART_T::BAUD: BRD Mask                  */
N
N/* UART IRCR Bit Field Definitions */
N#define UART_IRCR_INV_RX_Pos        6                                       /*!< UART_T::IRCR: INV_RX Position           */
N#define UART_IRCR_INV_RX_Msk        (1ul << UART_IRCR_INV_RX_Pos)           /*!< UART_T::IRCR: INV_RX Mask               */
N
N#define UART_IRCR_INV_TX_Pos        5                                       /*!< UART_T::IRCR: INV_TX Position           */
N#define UART_IRCR_INV_TX_Msk        (1ul << UART_IRCR_INV_TX_Pos)           /*!< UART_T::IRCR: INV_TX Mask               */
N
N#define UART_IRCR_TX_SELECT_Pos     1                                       /*!< UART_T::IRCR: TX_SELECT Position        */
N#define UART_IRCR_TX_SELECT_Msk     (1ul << UART_IRCR_TX_SELECT_Pos)        /*!< UART_T::IRCR: TX_SELECT Mask            */
N
N/* UART ALT_CSR Bit Field Definitions */
N#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART_T::ALT_CSR: ADDR_MATCH Position    */
N#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART_T::ALT_CSR: ADDR_MATCH Mask        */
N
N#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART_T::ALT_CSR: RS485_ADD_EN Position  */
N#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART_T::ALT_CSR: RS485_ADD_EN Mask      */
N
N#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART_T::ALT_CSR: RS485_AUD Position     */
N#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART_T::ALT_CSR: RS485_AUD Mask         */
N
N#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART_T::ALT_CSR: RS485_AAD Position     */
N#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART_T::ALT_CSR: RS485_AAD Mask         */
N
N#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART_T::ALT_CSR: RS485_NMM Position     */
N#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART_T::ALT_CSR: RS485_NMM Mask         */
N
N#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Position     */
N#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Mask         */
N
N#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART_T::ALT_CSR: LIN RX Enable Position     */
N#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN RX Enable Mask         */
N
N#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART_T::ALT_CSR: UART LIN Break Field Length Position     */
N#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART_T::ALT_CSR: UART LIN Break Field Length Mask         */
N
N/* UART FUN_SEL Bit Field Definitions */
N#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART_T::FUN_SEL: FUN_SEL Position       */
N#define UART_FUN_SEL_FUN_SEL_Msk        (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)      /*!< UART_T::FUN_SEL: FUN_SEL Mask           */
N/**@}*/ /* UART_CONST */
N/**@}*/ /* UART */
N
N
N
N/*----------------------------- WDT Controller -----------------------------*/
N/** @addtogroup WDT WDT Controller(WDT)
N  Memory Mapped Structure for Watchdog Timer
N  @{
N */
N
Ntypedef struct
N{
N
N
N/**
N * @var WDT_T::WTCR
N * Offset: 0x00  Watchdog Timer Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WTR       |Clear Watchdog Timer
N * |        |          |Set this bit will clear the Watchdog timer.
N * |        |          |0= Writing 0 to this bit has no effect
N * |        |          |1= Reset the contents of the Watchdog timer
N * |        |          |NOTE: This bit will auto clear after few clock cycle
N * |[1]     |WTRE      |Watchdog Timer Reset Enable
N * |        |          |Setting this bit will enable the Watchdog timer reset function.
N * |        |          |0= Disable Watchdog timer reset function
N * |        |          |1= Enable Watchdog timer reset function
N * |[2]     |WTRF      |Watchdog Timer Reset Flag
N * |        |          |When the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by
N * |        |          |software to determine the source of reset. Software is responsible to clear it manually by writing 1 to
N * |        |          |it. If WTRE is disabled, then the Watchdog timer has no effect on this bit.
N * |        |          |0= Watchdog timer reset does not occur
N * |        |          |1= Watchdog timer reset occurs
N * |        |          |NOTE: This bit is cleared by writing 1 to this bit.
N * |[3]     |WTIF      |Watchdog Timer Interrupt Flag
N * |        |          |If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the
N * |        |          |Watchdog timer interrupt has occurred. If the Watchdog timer interrupt is not enabled, then this bit
N * |        |          |indicates that a timeout period has elapsed.
N * |        |          |0= Watchdog timer interrupt does not occur
N * |        |          |1= Watchdog timer interrupt occurs
N * |        |          |NOTE: Write 1 to clear this bit to zero.
N * |[4]     |WTWKE     |Watchdog Timer Wakeup Function Enable bit
N * |        |          |0 = Disable Watchdog timer Wakeup CPU function.
N * |        |          |1 = Enable the Wakeup function that Watchdog timer timeout can wake up CPU from power-down
N * |        |          |mode.
N * |[5]     |WTWKF     |Watchdog Timer Wakeup Flag
N * |        |          |If Watchdog timer causes CPU wakes up from power-down mode, this bit will be set to high. It must
N * |        |          |be cleared by software with a write 1 to this bit.
N * |        |          |1 = CPU wake up from sleep or power-down mode by Watchdog timeout.
N * |        |          |0 = Watchdog timer does not cause CPU wakeup.
N * |        |          |NOTE: Write 1 to clear this bit to zero.
N * |[6]     |WTIE      |Watchdog Timer Interrupt Enable
N * |        |          |0= Disable the Watchdog timer interrupt
N * |        |          |1= Enable the Watchdog timer interrupt
N * |[7]     |WTE       |Watchdog Timer Enable
N * |        |          |0= Disable the Watchdog timer (This action will reset the internal counter)
N * |        |          |1= Enable the Watchdog timer
N * |[10:8]  |WTIS      |Watchdog Timer Interval Select (write protection bit)
N * |        |          |These three bits select the timeout interval for the Watchdog timer.
N * @var WDT_T::WTCRALT
N * Offset: 0x04  Watchdog Timer Alternative Control Register
N * ---------------------------------------------------------------------------------------------------
N */
N
N    __IO uint32_t WTCR;          /* Offset: 0x00  Watchdog Timer Control Register                                    */
X    volatile uint32_t WTCR;           
N    __IO uint32_t WTCRALT;       /* Offset: 0x04  Watchdog Timer Alternative Control Register                        */
X    volatile uint32_t WTCRALT;        
N
N} WDT_T;
N
N
N
N/** @addtogroup WDT_CONST WDT Bit Field Definition
N  Constant Definitions for WDT Controller
N  @{
N */
N
N/* WDT WTCR Bit Field Definitions */
N#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT_T::WTCR: DBGACK_WDT Position */
N#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT_T::WTCR: DBGACK_WDT Mask */
N
N#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT_T::WTCR: WTIS Position */
N#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT_T::WTCR: WTIS Mask */
N
N#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT_T::WTCR: WTE Position */
N#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT_T::WTCR: WTE Mask */
N
N#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT_T::WTCR: WTIE Position */
N#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT_T::WTCR: WTIE Mask */
N
N#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT_T::WTCR: WTWKF Position */
N#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT_T::WTCR: WTWKF Mask */
N
N#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT_T::WTCR: WTWKE Position */
N#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT_T::WTCR: WTWKE Mask */
N
N#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT_T::WTCR: WTIF Position */
N#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT_T::WTCR: WTIF Mask */
N
N#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT_T::WTCR: WTRF Position */
N#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT_T::WTCR: WTRF Mask */
N
N#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT_T::WTCR: WTRE Position */
N#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT_T::WTCR: WTRE Mask */
N
N#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT_T::WTCR: WTR Position */
N#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT_T::WTCR: WTR Mask */
N
N/* WDT WTCRALT Bit Field Definitions */
N#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT_T::WTCRALT: WTRDSEL Position */
N#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT_T::WTCRALT: WTRDSEL Mask */
N/**@}*/ /* WDT_CONST */
N/**@}*/ /* WDT */
N
N
N/*----------------------------- WWDT Controller -----------------------------*/
N/** @addtogroup WWDT Window Watchdog Timer (WWDT)
N  Register data structure of Window Watchdog Timer and relative constant definitions.
N  @{
N */
N
Ntypedef struct
N{
N
N
N
N/**
N * @var WWDT_T::WWDTRLD
N * ===================================================================================================
N * Offset: 0x00  WWDT Reload Counter Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |WWDTRLD   |WWDT Reload Counter Register
N * |        |          |Writing 0x00005AA5 to this register will reload the Window Watchdog Timer counter value to 0x3F.
N * |        |          |Note: Software can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP.
N * |        |          |If software writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal will generate immediately.
N * @var WWDT_T::WWDTCR
N * Offset: 0x04  Window Watchdog Timer Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WWDTEN    |WWDT Enable
N * |        |          |Set this bit to enable Window Watchdog Timer counter counting.
N * |        |          |0 = Window Watchdog Timer counter is stopped.
N * |        |          |1 = Window Watchdog Timer counter is starting counting.
N * |[1]     |WWDTIE    |WWDT Interrupt Enable
N * |        |          |Setting this bit to enable the Window Watchdog Timer time-out interrupt function.
N * |        |          |0 = WWDT time-out interrupt function Disabled if WWDTIF (WWDTSR[0] WWDT compare match interrupt flag) is 1.
N * |        |          |1 = WWDT time-out interrupt function Enabled if WWDTIF (WWDTSR[0] WWDT compare match interrupt flag) is 1.
N * |[11:8]  |PERIODSEL |WWDT Pre-scale Period Select
N * |        |          |These 4-bit select the pre-scale period for the WWDT counter period.
N * |        |          |PERIODSEL Pre-scale Value Time out Period Max. Time out Interval (WWDT_CLK=10 kHz)
N * |        |          |Timeout period = Pre-scale * 64 * WWDT_CLK.
N * |        |          |PERIODSEL={0,1,2,3, 4, 5, 6,  7,  8,  9, 10, 11, 12,  13,  14,  15}
N * |        |          |Pre-scale={1,2,4,8,16,32,64,128,192,256,384,512,768,1024,1536,2048}
N * |[21:16] |WINCMP    |WWDT Window Compare Register
N * |        |          |Set this register to adjust the valid reload window.
N * |        |          |Note: Software can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP.
N * |        |          |If Software writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal will generate immediately.
N * |[31]    |DBGACK_WWDT|ICE debug mode acknowledge Disable
N * |        |          |0 = WWDT counter stopped if system is in Debug mode.
N * |        |          |1 = WWDT still counted even system is in Debug mode.
N * @var WWDT_T::WWDTSR
N * Offset: 0x08  Window Watchdog Timer Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
N * |        |          |When current WWDT counter value matches to WWCMP, this bit is set to 1. This bit will be cleared by writing 1 to itself.
N * |[1]     |WWDTRF    |WWDT Reset Flag
N * |        |          |When WWDT counter counts down to 0 or writes WWDTRLD during current WWDT counter value larger than WINCMP,
N * |        |          |chip will be reset and this bit is set to 1. This bit will be cleared to 0 by writing 1 to itself.
N * @var WWDT_T::WWDTCVR
N * Offset: 0x0C  Watchdog Timer Alternative Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |WWDTCVAL  |WWDT Counter Value
N * |        |          |This register reflects the current WWDT counter value and this register is read only.
N */
N
N    __IO uint32_t WWDTRLD;       /* Offset: 0x00  WWDT Reload Counter Register                                       */
X    volatile uint32_t WWDTRLD;        
N    __IO uint32_t WWDTCR;        /* Offset: 0x04  Window Watchdog Timer Control Register                             */
X    volatile uint32_t WWDTCR;         
N    __IO uint32_t WWDTSR;        /* Offset: 0x08  Window Watchdog Timer Status Register                              */
X    volatile uint32_t WWDTSR;         
N    __IO uint32_t WWDTCVR;       /* Offset: 0x0C  Watchdog Timer Alternative Control Register                        */
X    volatile uint32_t WWDTCVR;        
N
N} WWDT_T;
N
N
N
N/** @addtogroup WWDT_CONST WWDT Bit Field Definition
N  Constant Definitions for WWDT Controller
N  @{
N */
N
N/* WWDT WWDTRLD Bit Field Definitions */
N#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT_T::WWDTRLD: WWDTRLD Position */
N#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT_T::WWDTRLD: WWDTRLD Mask */
N
N/* WWDT WWDTCR Bit Field Definitions */
N#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT_T::WWDTCR: DBGACK_WWDT Position */
N#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT_T::WWDTCR: DBGACK_WWDT Mask */
N
N#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT_T::WWDTCR: WINCMP Position */
N#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT_T::WWDTCR: WINCMP Mask */
N
N#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT_T::WWDTCR: PERIODSEL Position */
N#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT_T::WWDTCR: PERIODSEL Mask */
N
N#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT_T::WWDTCR: WWDTIE Position */
N#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT_T::WWDTCR: WWDTIE Mask */
N
N#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT_T::WWDTCR: WWDTEN Position */
N#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_WWDTEN_Pos)             /*!< WWDT_T::WWDTCR: WWDTEN Mask */
N
N/* WWDT WWDTSR Bit Field Definitions */
N#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT_T::WWDTSR: WWDTRF Position */
N#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT_T::WWDTSR: WWDTRF Mask */
N
N#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT_T::WWDTSR: WWDTIF Position */
N#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT_T::WWDTSR: WWDTIF Mask */
N
N/* WWDT WWDTCVR Bit Field Definitions */
N#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT_T::WWDTCVR: WWDTRF Position */
N#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT_T::WWDTCVR: WWDTRF Mask */
N/**@}*/ /* end of group WWDT_CONST */
N/**@}*/ /* end of group WWDT */
N/**@}*/ /* end of group REGISTER */
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup PERIPHERAL_BASE Peripheral Memory Base
N  Memory Mapped Structure for Series Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE          ((     uint32_t)0x00000000)
N#define SRAM_BASE           ((     uint32_t)0x20000000)
N#define AHB_BASE            ((     uint32_t)0x50000000)
N#define APB1_BASE           ((     uint32_t)0x40000000)
N#define APB2_BASE           ((     uint32_t)0x40100000)
N
N/* Peripheral memory map */
N#define GPIO_BASE           (AHB_BASE       + 0x4000)                   /*!< GPIO Base Address                                   */
N#define P0_BASE             (GPIO_BASE              )                   /*!< GPIO P0 Base Address                                */
N#define P1_BASE             (GPIO_BASE      + 0x0040)                   /*!< GPIO P1 Base Address                                */
N#define P2_BASE             (GPIO_BASE      + 0x0080)                   /*!< GPIO P2 Base Address                                */
N#define P3_BASE             (GPIO_BASE      + 0x00C0)                   /*!< GPIO P3 Base Address                                */
N#define P4_BASE             (GPIO_BASE      + 0x0100)                   /*!< GPIO P4 Base Address                                */
N#define GPIO_DBNCECON_BASE  (GPIO_BASE      + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
N#define GPIO_PIN_DATA_BASE  (GPIO_BASE      + 0x0200)                   /*!< GPIO Pin Data Input/Output Control Base Address     */
N
N#define UART0_BASE          (APB1_BASE      + 0x50000)                  /*!< UART0 Base Address                               */
N#define UART1_BASE          (APB2_BASE      + 0x50000)                  /*!< UART1 Base Address                               */
N
N#define TIMER0_BASE         (APB1_BASE      + 0x10000)                  /*!< Timer0 Base Address                              */
N#define TIMER1_BASE         (APB1_BASE      + 0x10020)                  /*!< Timer1 Base Address                              */
N#define TIMER2_BASE         (APB2_BASE      + 0x10000)                  /*!< Timer2 Base Address                              */
N#define TIMER3_BASE         (APB2_BASE      + 0x10020)                  /*!< Timer3 Base Address                              */
N
N#define WDT_BASE            (APB1_BASE      + 0x4000)                   /*!< Watch Dog Timer Base Address                     */
N
N#define WWDT_BASE           (APB1_BASE      + 0x4100)                   /*!< Window Watch Dog Timer Base Address              */
N
N#define SPI0_BASE           (APB1_BASE      + 0x30000)                  /*!< SPI0 Base Address                                */
N#define SPI1_BASE           (APB1_BASE      + 0x34000)                  /*!< SPI1 Base Address                                */
N
N#define I2C0_BASE           (APB1_BASE      + 0x20000)                  /*!< I2C0 Base Address                                */
N#define I2C1_BASE           (APB2_BASE      + 0x20000)                  /*!< I2C1 Base Address                                */
N
N#define RTC_BASE            (APB1_BASE      + 0x08000)                  /*!< RTC Base Address                                 */
N
N#define ADC_BASE            (APB1_BASE      + 0xE0000)                  /*!< ADC Base Address                                 */
N
N#define ACMP01_BASE         (APB1_BASE      + 0xD0000)                  /*!< ACMP01 Base Address                              */
N#define ACMP23_BASE         (APB2_BASE      + 0xD0000)                  /*!< ACMP23 Base Address                              */
N
N#define CLK_BASE            (AHB_BASE       + 0x00200)                  /*!< System Clock Controller Base Address             */
N
N#define GCR_BASE            (AHB_BASE       + 0x00000)                  /*!< System Global Controller Base Address            */
N
N#define INT_BASE            (AHB_BASE       + 0x00300)                  /*!< Interrupt Source Controller Base Address         */
N
N#define FMC_BASE            (AHB_BASE       + 0x0C000)                  /*!< Flash Memory Controller Base Address             */
N
N#define PWMA_BASE           (APB1_BASE      + 0x40000)                  /*!< PWMA Base Address                                */
N#define PWMB_BASE           (APB2_BASE      + 0x40000)                  /*!< PWMB Base Address                                */
N
N#define EBI_BASE            (AHB_BASE       + 0x10000)                  /*!< EBI Base Address                                 */
N
N#define HDIV_BASE           (AHB_BASE       + 0x14000)                  /*!< HDIV Base Address                                */
N
N/**@}*/ /* PERIPHERAL */
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N
N/** @addtogroup PMODULE Peripheral Pointer
N  The Declaration of Peripheral Pointer
N  @{
N */
N#define P0                  ((GPIO_T *) P0_BASE)                        /*!< GPIO PORT0 Configuration Struct                        */
N#define P1                  ((GPIO_T *) P1_BASE)                        /*!< GPIO PORT1 Configuration Struct                        */
N#define P2                  ((GPIO_T *) P2_BASE)                        /*!< GPIO PORT2 Configuration Struct                        */
N#define P3                  ((GPIO_T *) P3_BASE)                        /*!< GPIO PORT3 Configuration Struct                        */
N#define P4                  ((GPIO_T *) P4_BASE)                        /*!< GPIO PORT4 Configuration Struct                        */
N#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */
N
N#define UART0               ((UART_T *) UART0_BASE)                     /*!< UART0 Configuration Struct                       */
N#define UART1               ((UART_T *) UART1_BASE)                     /*!< UART1 Configuration Struct                       */
N
N#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< TIMER0 Configuration Struct                      */
N#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< TIMER1 Configuration Struct                      */
N#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< TIMER2 Configuration Struct                      */
N#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< TIMER3 Configuration Struct                      */
N
N#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watch Dog Timer Configuration Struct             */
N
N#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watch Dog Timer Configuration Struct      */
N
N#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
N#define SPI1                ((SPI_T *) SPI1_BASE)                       /*!< SPI1 Configuration Struct                        */
N
N#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
N#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
N
N#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
N
N#define ACMP01              ((ACMP_T *) ACMP01_BASE)                    /*!< ACMP01 Configuration Struct                      */
N#define ACMP23              ((ACMP_T *) ACMP23_BASE)                    /*!< ACMP23 Configuration Struct                      */
N
N#define CLK                 ((CLK_T *) CLK_BASE)                        /*!< System Clock Controller Configuration Struct     */
N
N#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
N
N#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
N
N#define FMC                 ((FMC_T *) FMC_BASE)                        /*!< Flash Memory Controller */
N
N#define PWMA                ((PWM_T *) PWMA_BASE)                       /*!< PWMA Configuration Struct                        */
N#define PWMB                ((PWM_T *) PWMB_BASE)                       /*!< PWMB Configuration Struct                        */
N
N#define EBI                 ((EBI_T *) EBI_BASE)                        /*!< EBI Configuration Struct                         */
N
N#define HDIV                ((HDIV_T *) HDIV_BASE)                      /*!< HDIV Configuration Struct                         */
N
N/**@}*/ /* end of group PMODULE */
N
N
N//=============================================================================
Ntypedef volatile unsigned char  vu8;
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
N#define M8(adr)  (*((vu8  *) (adr)))
N#define M16(adr) (*((vu16 *) (adr)))
N#define M32(adr) (*((vu32 *) (adr)))
N
N#define outpw(port,value)   (*((volatile unsigned int *)(port))=(value))
N#define inpw(port)          ((*((volatile unsigned int *)(port))))
N#define outpb(port,value)   (*((volatile unsigned char *)(port))=(value))
N#define inpb(port)          ((*((volatile unsigned char *)(port))))
N#define outps(port,value)   (*((volatile unsigned short *)(port))=(value))
N#define inps(port)          ((*((volatile unsigned short *)(port))))
N
N#define outp32(port,value)  (*((volatile unsigned int *)(port))=(value))
N#define inp32(port)         ((*((volatile unsigned int *)(port))))
N#define outp8(port,value)   (*((volatile unsigned char *)(port))=(value))
N#define inp8(port)          ((*((volatile unsigned char *)(port))))
N#define outp16(port,value)  (*((volatile unsigned short *)(port))=(value))
N#define inp16(port)         ((*((volatile unsigned short *)(port))))
N
N
N#define E_SUCCESS   0
N#ifndef NULL
S#define NULL        0
N#endif
N
N#define TRUE        1
N#define FALSE       0
N
N#define ENABLE      1
N#define DISABLE     0
N
N/* Bit Mask Definitions */
N#define BIT0    0x00000001
N#define BIT1    0x00000002
N#define BIT2    0x00000004
N#define BIT3    0x00000008
N#define BIT4    0x00000010
N#define BIT5    0x00000020
N#define BIT6    0x00000040
N#define BIT7    0x00000080
N#define BIT8    0x00000100
N#define BIT9    0x00000200
N#define BIT10   0x00000400
N#define BIT11   0x00000800
N#define BIT12   0x00001000
N#define BIT13   0x00002000
N#define BIT14   0x00004000
N#define BIT15   0x00008000
N#define BIT16   0x00010000
N#define BIT17   0x00020000
N#define BIT18   0x00040000
N#define BIT19   0x00080000
N#define BIT20   0x00100000
N#define BIT21   0x00200000
N#define BIT22   0x00400000
N#define BIT23   0x00800000
N#define BIT24   0x01000000
N#define BIT25   0x02000000
N#define BIT26   0x04000000
N#define BIT27   0x08000000
N#define BIT28   0x10000000
N#define BIT29   0x20000000
N#define BIT30   0x40000000
N#define BIT31   0x80000000
N
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk               (0x000000FF)
N#define BYTE1_Msk               (0x0000FF00)
N#define BYTE2_Msk               (0x00FF0000)
N#define BYTE3_Msk               (0xFF000000)
N
N#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/
N#include "sys.h"
L 1 "..\..\..\..\Library\StdDriver\inc\sys.h" 1
N/**************************************************************************//**
N * @file     SYS.h
N * @version  V3
N * $Revision: 26 $
N * $Date: 15/05/22 4:48p $
N * @brief    M051 Series Global Control and Clock Control Driver Header File
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYS_H__
N#define __SYS_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_RST     ((0x0<<24) | SYS_IPRSTC1_EBI_RST_Pos    ) /*!< EBI reset is one of the SYS_ResetModule parameter */
N#define HDIV_RST    ((0x0<<24) | SYS_IPRSTC1_HDIV_RST_Pos   ) /*!< HDIV reset is one of the SYS_ResetModule parameter */
N#define GPIO_RST    ((0x4<<24) | SYS_IPRSTC2_GPIO_RST_Pos   ) /*!< GPIO reset is one of the SYS_ResetModule parameter */
N#define TMR0_RST    ((0x4<<24) | SYS_IPRSTC2_TMR0_RST_Pos   ) /*!< TMR0 reset is one of the SYS_ResetModule parameter */
N#define TMR1_RST    ((0x4<<24) | SYS_IPRSTC2_TMR1_RST_Pos   ) /*!< TMR1 reset is one of the SYS_ResetModule parameter */
N#define TMR2_RST    ((0x4<<24) | SYS_IPRSTC2_TMR2_RST_Pos   ) /*!< TMR2 reset is one of the SYS_ResetModule parameter */
N#define TMR3_RST    ((0x4<<24) | SYS_IPRSTC2_TMR3_RST_Pos   ) /*!< TMR3 reset is one of the SYS_ResetModule parameter */
N#define I2C0_RST    ((0x4<<24) | SYS_IPRSTC2_I2C0_RST_Pos   ) /*!< I2C0 reset is one of the SYS_ResetModule parameter */
N#define I2C1_RST    ((0x4<<24) | SYS_IPRSTC2_I2C1_RST_Pos   ) /*!< I2C1 reset is one of the SYS_ResetModule parameter */
N#define SPI0_RST    ((0x4<<24) | SYS_IPRSTC2_SPI0_RST_Pos   ) /*!< SPI0 reset is one of the SYS_ResetModule parameter */
N#define SPI1_RST    ((0x4<<24) | SYS_IPRSTC2_SPI1_RST_Pos   ) /*!< SPI1 reset is one of the SYS_ResetModule parameter */
N#define UART0_RST   ((0x4<<24) | SYS_IPRSTC2_UART0_RST_Pos  ) /*!< UART0 reset is one of the SYS_ResetModule parameter */
N#define UART1_RST   ((0x4<<24) | SYS_IPRSTC2_UART1_RST_Pos  ) /*!< UART1 reset is one of the SYS_ResetModule parameter */
N#define PWM03_RST   ((0x4<<24) | SYS_IPRSTC2_PWM03_RST_Pos  ) /*!< PWM03 reset is one of the SYS_ResetModule parameter */
N#define PWM47_RST   ((0x4<<24) | SYS_IPRSTC2_PWM47_RST_Pos  ) /*!< PWM47 reset is one of the SYS_ResetModule parameter */
N#define ACMP01_RST  ((0x4<<24) | SYS_IPRSTC2_ACMP01_RST_Pos ) /*!< ACMP01 reset is one of the SYS_ResetModule parameter */
N#define ACMP23_RST  ((0x4<<24) | SYS_IPRSTC2_ACMP23_RST_Pos ) /*!< ACMP23 reset is one of the SYS_ResetModule parameter */
N#define ADC_RST     ((0x4<<24) | SYS_IPRSTC2_ADC_RST_Pos    ) /*!< ADC reset is one of the SYS_ResetModule parameter */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCR_BOD_RST_EN            (1UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Reset Enable */
N#define SYS_BODCR_BOD_INTERRUPT_EN      (0UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Interrupt Enable */
N#define SYS_BODCR_BOD_VL_4_4V           (3UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 4.4V */
N#define SYS_BODCR_BOD_VL_3_7V           (2UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 3.7V */
N#define SYS_BODCR_BOD_VL_2_7V           (1UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCR_BOD_VL_2_2V           (0UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* How to use below #define?
NExample: If user want to set P0.2 as TXD and P0.3 as RXD in initial function,
N         user can issue following command to achieve it.
N
N         SYS->P0_MFP &= ~(SYS_MFP_P02_Msk | SYS_MFP_P03_Msk);
N         SYS->P0_MFP |= (SYS_MFP_P02_TXD | SYS_MFP_P03_RXD);
N*/
N
N#define SYS_MFP_TYPE_Msk(bit)       (1UL << ((bit) +16))
N#define SYS_MFP_ALT_Msk(bit)        (1UL << ((bit) + 8))
N#define SYS_MFP_MFP_Msk(bit)        (1UL << ((bit)    ))
N
N#define SYS_MFP_P00_GPIO        0x00000000UL /*!< P0_MFP pin 0 setting for GPIO */
N#define SYS_MFP_P00_AD0         0x00000001UL /*!< P0_MFP pin 0 setting for AD0  */
N#define SYS_MFP_P00_CTS1        0x00000100UL /*!< P0_MFP pin 0 setting for CTS1 */
N#define SYS_MFP_P00_TXD1        0x00000101UL /*!< P0_MFP pin 0 setting for TXD1 */
N#define SYS_MFP_P00_ACMP3_P     0x01000000UL /*!< P0_MFP pin 0 setting for ACMP3_P */
N#define SYS_MFP_P00_Msk         0x01000101UL /*!< P0_MFP pin 0 mask             */
N
N#define SYS_MFP_P01_GPIO        0x00000000UL /*!< P0_MFP pin 1 setting for GPIO */
N#define SYS_MFP_P01_AD1         0x00000002UL /*!< P0_MFP pin 1 setting for AD1  */
N#define SYS_MFP_P01_RTS1        0x00000200UL /*!< P0_MFP pin 1 setting for RTS1 */
N#define SYS_MFP_P01_RXD1        0x00000202UL /*!< P0_MFP pin 1 setting for RXD1 */
N#define SYS_MFP_P01_ACMP3_N     0x02000000UL /*!< P0_MFP pin 1 setting for ACMP3_N */
N#define SYS_MFP_P01_Msk         0x02000202UL /*!< P0_MFP pin 1 mask             */
N
N#define SYS_MFP_P02_GPIO    0x00000000UL /*!< P0_MFP pin 2 setting for GPIO */
N#define SYS_MFP_P02_AD2     0x00000004UL /*!< P0_MFP pin 2 setting for AD2  */
N#define SYS_MFP_P02_CTS0    0x00000400UL /*!< P0_MFP pin 2 setting for CTS0 */
N#define SYS_MFP_P02_TXD0    0x00000404UL /*!< P0_MFP pin 2 setting for TXD0 */
N#define SYS_MFP_P02_TXD     0x00000404UL /*!< P0_MFP pin 2 setting for TXD  */
N#define SYS_MFP_P02_Msk     0x00000404UL /*!< P0_MFP pin 2 mask             */
N
N#define SYS_MFP_P03_GPIO    0x00000000UL /*!< P0_MFP pin 3 setting for GPIO */
N#define SYS_MFP_P03_AD3     0x00000008UL /*!< P0_MFP pin 3 setting for AD3  */
N#define SYS_MFP_P03_RTS0    0x00000800UL /*!< P0_MFP pin 3 setting for RTS0 */
N#define SYS_MFP_P03_RXD0    0x00000808UL /*!< P0_MFP pin 3 setting for RXD0 */
N#define SYS_MFP_P03_RXD     0x00000808UL /*!< P0_MFP pin 3 setting for RXD  */
N#define SYS_MFP_P03_Msk     0x00000808UL /*!< P0_MFP pin 3 mask             */
N
N#define SYS_MFP_P04_GPIO    0x00000000UL /*!< P0_MFP pin 4 setting for GPIO   */
N#define SYS_MFP_P04_AD4     0x00000010UL /*!< P0_MFP pin 4 setting for AD4    */
N#define SYS_MFP_P04_SPISS1  0x00001000UL /*!< P0_MFP pin 4 setting for SPISS1 */
N#define SYS_MFP_P04_Msk     0x00001010UL /*!< P0_MFP pin 4 mask               */
N
N#define SYS_MFP_P05_GPIO    0x00000000UL /*!< P0_MFP pin 5 setting for GPIO   */
N#define SYS_MFP_P05_AD5     0x00000020UL /*!< P0_MFP pin 5 setting for AD5    */
N#define SYS_MFP_P05_MOSI_1  0x00002000UL /*!< P0_MFP pin 5 setting for MOSI_1 */
N#define SYS_MFP_P05_Msk     0x00002020UL /*!< P0_MFP pin 5 mask               */
N
N#define SYS_MFP_P06_GPIO    0x00000000UL /*!< P0_MFP pin 6 setting for GPIO   */
N#define SYS_MFP_P06_AD6     0x00000040UL /*!< P0_MFP pin 6 setting for AD6    */
N#define SYS_MFP_P06_MISO_1  0x00004000UL /*!< P0_MFP pin 6 setting for MISO_1 */
N#define SYS_MFP_P06_Msk     0x00004040UL /*!< P0_MFP pin 6 mask               */
N
N#define SYS_MFP_P07_GPIO    0x00000000UL /*!< P0_MFP pin 7 setting for GPIO    */
N#define SYS_MFP_P07_AD7     0x00000080UL /*!< P0_MFP pin 7 setting for AD7     */
N#define SYS_MFP_P07_SPICLK1 0x00008000UL /*!< P0_MFP pin 7 setting for SPICLK1 */
N#define SYS_MFP_P07_Msk     0x00008080UL /*!< P0_MFP pin 7 mask                */
N
N#define SYS_MFP_P10_GPIO    0x00000000UL /*!< P1_MFP pin 0 setting for GPIO */
N#define SYS_MFP_P10_AIN0    0x00000001UL /*!< P1_MFP pin 0 setting for AIN0 */
N#define SYS_MFP_P10_T2      0x00000100UL /*!< P1_MFP pin 0 setting for T2   */
N#define SYS_MFP_P10_nWRL    0x00000101UL /*!< P1_MFP pin 0 setting for nWRL */
N#define SYS_MFP_P10_Msk     0x00000101UL /*!< P1_MFP pin 0 mask             */
N
N#define SYS_MFP_P11_GPIO    0x00000000UL /*!< P1_MFP pin 1 setting for GPIO */
N#define SYS_MFP_P11_AIN1    0x00000002UL /*!< P1_MFP pin 1 setting for AIN1 */
N#define SYS_MFP_P11_T3      0x00000200UL /*!< P1_MFP pin 1 setting for T3   */
N#define SYS_MFP_P11_nWRH    0x00000202UL /*!< P1_MFP pin 1 setting for nWRH */
N#define SYS_MFP_P11_Msk     0x00000202UL /*!< P1_MFP pin 1 mask             */
N
N#define SYS_MFP_P12_GPIO    0x00000000UL /*!< P1_MFP pin 2 setting for GPIO */
N#define SYS_MFP_P12_AIN2    0x00000004UL /*!< P1_MFP pin 2 setting for AIN2 */
N#define SYS_MFP_P12_RXD1    0x00000400UL /*!< P1_MFP pin 2 setting for RXD1 */
N#define SYS_MFP_P12_Msk     0x00000404UL /*!< P1_MFP pin 2 mask             */
N
N#define SYS_MFP_P13_GPIO    0x00000000UL /*!< P1_MFP pin 3 setting for GPIO */
N#define SYS_MFP_P13_AIN3    0x00000008UL /*!< P1_MFP pin 3 setting for AIN3 */
N#define SYS_MFP_P13_TXD1    0x00000800UL /*!< P1_MFP pin 3 setting for TXD1 */
N#define SYS_MFP_P13_Msk     0x00000808UL /*!< P1_MFP pin 3 mask             */
N
N#define SYS_MFP_P14_GPIO    0x00000000UL /*!< P1_MFP pin 4 setting for GPIO   */
N#define SYS_MFP_P14_AIN4    0x00000010UL /*!< P1_MFP pin 4 setting for AIN4   */
N#define SYS_MFP_P14_SPISS0  0x00001000UL /*!< P1_MFP pin 4 setting for SPISS0 */
N#define SYS_MFP_P14_CPN0    0x00001010UL /*!< P1_MFP pin 4 setting for CPN0   */
N#define SYS_MFP_P14_ACMP0_N 0x00001010UL /*!< P1_MFP pin 4 setting for ACMP0_N */
N#define SYS_MFP_P14_Msk     0x00001010UL /*!< P1_MFP pin 4 mask               */
N
N#define SYS_MFP_P15_GPIO    0x00000000UL /*!< P1_MFP pin 5 setting for GPIO   */
N#define SYS_MFP_P15_AIN5    0x00000020UL /*!< P1_MFP pin 5 setting for AIN5   */
N#define SYS_MFP_P15_MOSI_0  0x00002000UL /*!< P1_MFP pin 5 setting for MOSI_0 */
N#define SYS_MFP_P15_CPP0    0x00002020UL /*!< P1_MFP pin 5 setting for CPP0   */
N#define SYS_MFP_P15_ACMP0_P 0x00002020UL /*!< P1_MFP pin 5 setting for ACMP0_P */
N#define SYS_MFP_P15_Msk     0x00002020UL /*!< P1_MFP pin 5 mask               */
N
N#define SYS_MFP_P16_GPIO    0x00000000UL /*!< P1_MFP pin 6 setting for GPIO   */
N#define SYS_MFP_P16_AIN6    0x00000040UL /*!< P1_MFP pin 6 setting for AIN6   */
N#define SYS_MFP_P16_MISO_0  0x00004000UL /*!< P1_MFP pin 6 setting for MISO_0 */
N#define SYS_MFP_P16_ACMP2_N 0x00004040UL /*!< P1_MFP pin 6 setting for ACMP2_N */
N#define SYS_MFP_P16_Msk     0x00004040UL /*!< P1_MFP pin 6 mask               */
N
N#define SYS_MFP_P17_GPIO    0x00000000UL /*!< P1_MFP pin 7 setting for GPIO    */
N#define SYS_MFP_P17_AIN7    0x00000080UL /*!< P1_MFP pin 7 setting for AIN7    */
N#define SYS_MFP_P17_SPICLK0 0x00008000UL /*!< P1_MFP pin 7 setting for SPICLK0 */
N#define SYS_MFP_P17_ACMP2_P 0x00008080UL /*!< P1_MFP pin 7 setting for ACMP2_P */
N#define SYS_MFP_P17_Msk     0x00008080UL /*!< P1_MFP pin 7 mask                */
N
N#define SYS_MFP_P20_GPIO    0x00000000UL /*!< P2_MFP pin 0 setting for GPIO */
N#define SYS_MFP_P20_AD8     0x00000001UL /*!< P2_MFP pin 0 setting for AD8  */
N#define SYS_MFP_P20_PWM0    0x00000100UL /*!< P2_MFP pin 0 setting for PWM0 */
N#define SYS_MFP_P20_Msk     0x00000101UL /*!< P2_MFP pin 0 mask             */
N
N#define SYS_MFP_P21_GPIO    0x00000000UL /*!< P2_MFP pin 1 setting for GPIO */
N#define SYS_MFP_P21_AD9     0x00000002UL /*!< P2_MFP pin 1 setting for AD9  */
N#define SYS_MFP_P21_PWM1    0x00000200UL /*!< P2_MFP pin 1 setting for PWM1 */
N#define SYS_MFP_P21_Msk     0x00000202UL /*!< P2_MFP pin 1 mask             */
N
N#define SYS_MFP_P22_GPIO    0x00000000UL /*!< P2_MFP pin 2 setting for GPIO */
N#define SYS_MFP_P22_AD10    0x00000004UL /*!< P2_MFP pin 2 setting for AD10 */
N#define SYS_MFP_P22_PWM2    0x00000400UL /*!< P2_MFP pin 2 setting for PWM2 */
N#define SYS_MFP_P22_Msk     0x00000404UL /*!< P2_MFP pin 2 mask             */
N
N#define SYS_MFP_P23_GPIO    0x00000000UL /*!< P2_MFP pin 3 setting for GPIO */
N#define SYS_MFP_P23_AD11    0x00000008UL /*!< P2_MFP pin 3 setting for AD11 */
N#define SYS_MFP_P23_PWM3    0x00000800UL /*!< P2_MFP pin 3 setting for PWM3 */
N#define SYS_MFP_P23_Msk     0x00000808UL /*!< P2_MFP pin 3 mask             */
N
N#define SYS_MFP_P24_GPIO    0x00000000UL /*!< P2_MFP pin 4 setting for GPIO */
N#define SYS_MFP_P24_AD12    0x00000010UL /*!< P2_MFP pin 4 setting for AD12 */
N#define SYS_MFP_P24_PWM4    0x00001000UL /*!< P2_MFP pin 4 setting for PWM4 */
N#define SYS_MFP_P24_SCL1    0x00001010UL /*!< P2_MFP pin 4 setting for SCL1 */
N#define SYS_MFP_P24_Msk     0x00001010UL /*!< P2_MFP pin 4 mask             */
N
N#define SYS_MFP_P25_GPIO    0x00000000UL /*!< P2_MFP pin 5 setting for GPIO */
N#define SYS_MFP_P25_AD13    0x00000020UL /*!< P2_MFP pin 5 setting for AD13 */
N#define SYS_MFP_P25_PWM5    0x00002000UL /*!< P2_MFP pin 5 setting for PWM5 */
N#define SYS_MFP_P25_SDA1    0x00002020UL /*!< P2_MFP pin 5 setting for SDA1 */
N#define SYS_MFP_P25_Msk     0x00002020UL /*!< P2_MFP pin 5 mask             */
N
N#define SYS_MFP_P26_GPIO    0x00000000UL /*!< P2_MFP pin 6 setting for GPIO */
N#define SYS_MFP_P26_AD14    0x00000040UL /*!< P2_MFP pin 6 setting for AD14 */
N#define SYS_MFP_P26_PWM6    0x00004000UL /*!< P2_MFP pin 6 setting for PWM6 */
N#define SYS_MFP_P26_CPO1    0x00004040UL /*!< P2_MFP pin 6 setting for CPO1 */
N#define SYS_MFP_P26_ACMP1_O 0x00004040UL /*!< P2_MFP pin 6 setting for ACMP1_O */
N#define SYS_MFP_P26_Msk     0x00004040UL /*!< P2_MFP pin 6 mask             */
N
N#define SYS_MFP_P27_GPIO    0x00000000UL /*!< P2_MFP pin 7 setting for GPIO */
N#define SYS_MFP_P27_AD15    0x00000080UL /*!< P2_MFP pin 7 setting for AD15 */
N#define SYS_MFP_P27_PWM7    0x00008000UL /*!< P2_MFP pin 7 setting for PWM7 */
N#define SYS_MFP_P27_Msk     0x00008080UL /*!< P2_MFP pin 7 mask             */
N
N#define SYS_MFP_P30_GPIO    0x00000000UL /*!< P3_MFP pin 0 setting for GPIO */
N#define SYS_MFP_P30_RXD0    0x00000001UL /*!< P3_MFP pin 0 setting for RXD0 */
N#define SYS_MFP_P30_RXD     0x00000001UL /*!< P3_MFP pin 0 setting for RXD  */
N#define SYS_MFP_P30_CPN1    0x00000100UL /*!< P3_MFP pin 0 setting for CPN1 */
N#define SYS_MFP_P30_ACMP1_N 0x00000100UL /*!< P3_MFP pin 0 setting for ACMP1_N */
N#define SYS_MFP_P30_Msk     0x00000101UL /*!< P3_MFP pin 0 mask             */
N
N#define SYS_MFP_P31_GPIO    0x00000000UL /*!< P3_MFP pin 1 setting for GPIO */
N#define SYS_MFP_P31_TXD0    0x00000002UL /*!< P3_MFP pin 1 setting for TXD0 */
N#define SYS_MFP_P31_TXD     0x00000002UL /*!< P3_MFP pin 1 setting for TXD  */
N#define SYS_MFP_P31_CPP1    0x00000200UL /*!< P3_MFP pin 1 setting for CPP1 */
N#define SYS_MFP_P31_ACMP1_P 0x00000200UL /*!< P3_MFP pin 1 setting for ACMP1_P */
N#define SYS_MFP_P31_Msk     0x00000202UL /*!< P3_MFP pin 1 mask             */
N
N#define SYS_MFP_P32_GPIO    0x00000000UL /*!< P3_MFP pin 2 setting for GPIO  */
N#define SYS_MFP_P32_INT0    0x00000004UL /*!< P3_MFP pin 2 setting for /INT0 */
N#define SYS_MFP_P32_nINT0   0x00000004UL /*!< P3_MFP pin 2 setting for /INT0 */
N#define SYS_MFP_P32_T0EX    0x00000400UL /*!< P3_MFP pin 2 setting for T0EX  */
N#define SYS_MFP_P32_Msk     0x00000404UL /*!< P3_MFP pin 2 mask              */
N
N#define SYS_MFP_P33_GPIO    0x00000000UL /*!< P3_MFP pin 3 setting for GPIO  */
N#define SYS_MFP_P33_INT1    0x00000008UL /*!< P3_MFP pin 3 setting for /INT1 */
N#define SYS_MFP_P33_nINT1   0x00000008UL /*!< P3_MFP pin 3 setting for /INT1 */
N#define SYS_MFP_P33_MCLK    0x00000800UL /*!< P3_MFP pin 3 setting for MCLK  */
N#define SYS_MFP_P33_T1EX    0x00000808UL /*!< P3_MFP pin 3 setting for T1EX  */
N#define SYS_MFP_P33_Msk     0x00000808UL /*!< P3_MFP pin 3 mask              */
N
N#define SYS_MFP_P34_GPIO    0x00000000UL /*!< P3_MFP pin 4 setting for GPIO */
N#define SYS_MFP_P34_T0      0x00000010UL /*!< P3_MFP pin 4 setting for T0   */
N#define SYS_MFP_P34_SDA0    0x00001000UL /*!< P3_MFP pin 4 setting for SDA0 */
N#define SYS_MFP_P34_Msk     0x00001010UL /*!< P3_MFP pin 4 mask             */
N
N#define SYS_MFP_P35_GPIO    0x00000000UL /*!< P3_MFP pin 5 setting for GPIO */
N#define SYS_MFP_P35_T1      0x00000020UL /*!< P3_MFP pin 5 setting for T1   */
N#define SYS_MFP_P35_SCL0    0x00002000UL /*!< P3_MFP pin 5 setting for SCL0 */
N#define SYS_MFP_P35_CKO     0x00002020UL /*!< P3_MFP pin 5 setting for CKO  */
N#define SYS_MFP_P35_Msk     0x00002020UL /*!< P3_MFP pin 5 mask             */
N
N#define SYS_MFP_P36_GPIO    0x00000000UL /*!< P3_MFP pin 6 setting for GPIO */
N#define SYS_MFP_P36_nWR     0x00000040UL /*!< P3_MFP pin 6 setting for nWR  */
N#define SYS_MFP_P36_CKO     0x00004000UL /*!< P3_MFP pin 6 setting for CKO  */
N#define SYS_MFP_P36_CPO0    0x00004040UL /*!< P3_MFP pin 6 setting for CPO0 */
N#define SYS_MFP_P36_ACMP0_O 0x00004040UL /*!< P3_MFP pin 6 setting for ACMP0_O */
N#define SYS_MFP_P36_Msk     0x00004040UL /*!< P3_MFP pin 6 mask             */
N
N#define SYS_MFP_P37_GPIO    0x00000000UL /*!< P3_MFP pin 7 setting for GPIO */
N#define SYS_MFP_P37_nRD     0x00000080UL /*!< P3_MFP pin 7 setting for nWR  */
N#define SYS_MFP_P37_Msk     0x00008080UL /*!< P3_MFP pin 7 mask             */
N
N#define SYS_MFP_P40_GPIO    0x00000000UL /*!< P4_MFP pin 0 setting for GPIO */
N#define SYS_MFP_P40_PWM0    0x00000001UL /*!< P4_MFP pin 0 setting for PWM0 */
N#define SYS_MFP_P40_T2EX    0x00000100UL /*!< P4_MFP pin 0 setting for T2EX */
N#define SYS_MFP_P40_Msk     0x00000101UL /*!< P4_MFP pin 0 mask             */
N
N#define SYS_MFP_P41_GPIO    0x00000000UL /*!< P4_MFP pin 1 setting for GPIO */
N#define SYS_MFP_P41_PWM1    0x00000002UL /*!< P4_MFP pin 1 setting for PWM1 */
N#define SYS_MFP_P41_T3EX    0x00000200UL /*!< P4_MFP pin 1 setting for T3EX */
N#define SYS_MFP_P41_Msk     0x00000202UL /*!< P4_MFP pin 1 mask             */
N
N#define SYS_MFP_P42_GPIO    0x00000000UL /*!< P4_MFP pin 2 setting for GPIO */
N#define SYS_MFP_P42_PWM2    0x00000004UL /*!< P4_MFP pin 2 setting for PWM2 */
N#define SYS_MFP_P42_Msk     0x00000404UL /*!< P4_MFP pin 2 mask             */
N
N#define SYS_MFP_P43_GPIO    0x00000000UL /*!< P4_MFP pin 3 setting for GPIO */
N#define SYS_MFP_P43_PWM3    0x00000008UL /*!< P4_MFP pin 3 setting for PWM3 */
N#define SYS_MFP_P43_Msk     0x00000808UL /*!< P4_MFP pin 3 mask             */
N
N#define SYS_MFP_P44_GPIO    0x00000000UL /*!< P4_MFP pin 4 setting for GPIO */
N#define SYS_MFP_P44_nCS     0x00000010UL /*!< P4_MFP pin 4 setting for nCS  */
N#define SYS_MFP_P44_SCL1    0x00001000UL /*!< P4_MFP pin 4 setting for SCL1  */
N#define SYS_MFP_P44_Msk     0x00001010UL /*!< P4_MFP pin 4 mask             */
N
N#define SYS_MFP_P45_GPIO    0x00000000UL /*!< P4_MFP pin 5 setting for GPIO */
N#define SYS_MFP_P45_ALE     0x00000020UL /*!< P4_MFP pin 5 setting for ALE  */
N#define SYS_MFP_P45_SDA1    0x00002000UL /*!< P4_MFP pin 5 setting for SDA1  */
N#define SYS_MFP_P45_Msk     0x00002020UL /*!< P4_MFP pin 5 mask             */
N
N#define SYS_MFP_P46_GPIO    0x00000000UL /*!< P4_MFP pin 6 setting for GPIO    */
N#define SYS_MFP_P46_ICE_CLK 0x00000040UL /*!< P4_MFP pin 6 setting for ICE_CLK */
N#define SYS_MFP_P46_Msk     0x00004040UL /*!< P4_MFP pin 6 mask                */
N
N#define SYS_MFP_P47_GPIO    0x00000000UL /*!< P4_MFP pin 7 setting for GPIO    */
N#define SYS_MFP_P47_ICE_DAT 0x00000080UL /*!< P4_MFP pin 7 setting for ICE_DAT */
N#define SYS_MFP_P47_Msk     0x00008080UL /*!< P4_MFP pin 7 mask                */
N
N
N
N/*@}*/ /* end of group SYS_EXPORTED_CONSTANTS */
N
N/** @addtogroup SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Clear Brown-out detector interrupt flag
N  * @param      None  
N  * @return     None
N  * @details    This macro clear Brown-out detector interrupt flag.
N  */
N#define SYS_CLEAR_BOD_INT_FLAG()        (SYS->BODCR |= SYS_BODCR_BOD_INTF_Msk)
N
N/**
N  * @brief      Set Brown-out detector function to normal mode
N  * @param      None  
N  * @return     None
N  * @details    This macro set Brown-out detector to normal mode.
N  *             The register write-protection function should be disabled before using this macro.  
N  */
N#define SYS_CLEAR_BOD_LPM()             (SYS->BODCR &= ~SYS_BODCR_BOD_LPM_Msk)
N
N/**
N  * @brief      Disable Brown-out detector function
N  * @param      None  
N  * @return     None
N  * @details    This macro disable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this macro.  
N  */
N#define SYS_DISABLE_BOD()               (SYS->BODCR &= ~SYS_BODCR_BOD_EN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector function
N  * @param      None  
N  * @return     None
N  * @details    This macro enable Brown-out detector function.  
N  *             The register write-protection function should be disabled before using this macro.  
N  */
N#define SYS_ENABLE_BOD()                (SYS->BODCR |= SYS_BODCR_BOD_EN_Msk)
N
N/**
N  * @brief      Get Brown-out detector interrupt flag
N  * @param      None    
N  * @retval     0   Brown-out detect interrupt flag is not set.
N  * @retval     >=1 Brown-out detect interrupt flag is set.
N  * @details    This macro get Brown-out detector interrupt flag.    
N  */
N#define SYS_GET_BOD_INT_FLAG()          (SYS->BODCR & SYS_BODCR_BOD_INTF_Msk)
N
N/**
N  * @brief      Get Brown-out detector status
N  * @param      None 
N  * @retval     0   System voltage is higher than BOD_VL setting or BOD_EN is 0.
N  * @retval     >=1 System voltage is lower than BOD_VL setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD_EN is 0, this function always return 0.
N  */
N#define SYS_GET_BOD_OUTPUT()            (SYS->BODCR & SYS_BODCR_BOD_OUT_Msk)
N
N/**
N  * @brief      Enable Brown-out detector interrupt function
N  * @param      None   
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  *             The register write-protection function should be disabled before using this macro.  
N  */
N#define SYS_DISABLE_BOD_RST()           (SYS->BODCR &= ~SYS_BODCR_BOD_RSTEN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector reset function
N  * @param      None     
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.  
N  *             The register write-protection function should be disabled before using this macro.  
N  */
N#define SYS_ENABLE_BOD_RST()            (SYS->BODCR |= SYS_BODCR_BOD_RSTEN_Msk)
N
N/**
N  * @brief      Set Brown-out detector function low power mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to low power mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LPM()               (SYS->BODCR |= SYS_BODCR_BOD_LPM_Msk)
N
N/**
N  * @brief      Set Brown-out detector voltage level
N  * @param[in]  u32Level is Brown-out voltage level. Including :
N  *             - \ref SYS_BODCR_BOD_VL_4_4V
N  *             - \ref SYS_BODCR_BOD_VL_3_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_2V
N  * @return     None
N  * @details    This macro set Brown-out detector voltage level.
N  *             The register write-protection function should be disabled before using this macro.  
N  */
N#define SYS_SET_BOD_LEVEL(u32Level)     (SYS->BODCR = (SYS->BODCR & ~SYS_BODCR_BOD_VL_Msk) | (u32Level))
N
N/**
N  * @brief      Get reset source is from Brown-out detector reset
N  * @param      None    
N  * @retval     0   Previous reset source is not from Brown-out detector reset
N  * @retval     >=1 Previous reset source is from Brown-out detector reset
N  * @details    This macro get previous reset source is from Brown-out detect reset or not.    
N  */
N#define SYS_IS_BOD_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_BOD_Msk)
N
N/**
N  * @brief      Get reset source is from CPU reset
N  * @param      None     
N  * @retval     0   Previous reset source is not from CPU reset
N  * @retval     >=1 Previous reset source is from CPU reset
N  * @details    This macro get previous reset source is from CPU reset. 
N  */
N#define SYS_IS_CPU_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_CPU_Msk)
N
N/**
N  * @brief      Get reset source is from Low-Voltage-Reset
N  * @param      None     
N  * @retval     0   Previous reset source is not from Low-Voltage-Reset
N  * @retval     >=1 Previous reset source is from Low-Voltage-Reset
N  * @details    This macro get previous reset source is from Low-Voltage-Reset.   
N  */
N#define SYS_IS_LVR_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_LVR_Msk)
N
N
N/**
N  * @brief      Get reset source is from Power-on Reset
N  * @param      None     
N  * @retval     0   Previous reset source is not from Power-on Reset
N  * @retval     >=1 Previous reset source is from Power-on Reset
N  * @details    This macro get previous reset source is from Power-on Reset.   
N  */
N#define SYS_IS_POR_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_POR_Msk)
N
N/**
N  * @brief      Get reset source is from reset pin reset
N  * @param      None     
N  * @retval     0   Previous reset source is not from reset pin reset
N  * @retval     >=1 Previous reset source is from reset pin reset
N  * @details    This macro get previous reset source is from reset pin reset.  
N  */
N#define SYS_IS_RSTPIN_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_RESET_Msk)
N
N/**
N  * @brief      Get reset source is from system reset
N  * @param      None     
N  * @retval     0   Previous reset source is not from system reset
N  * @retval     >=1 Previous reset source is from system reset
N  * @details    This macro get previous reset source is from system reset.   
N  */
N#define SYS_IS_SYSTEM_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_MCU_Msk)
N
N/**
N  * @brief      Get reset source is from window watch dog reset
N  * @param      None
N  * @retval     0   Previous reset source is not from window watch dog reset
N  * @retval     >=1 Previous reset source is from window watch dog reset
N  * @details    This macro get previous reset source is from window watch dog reset.    
N  */
N#define SYS_IS_WDT_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_WDT_Msk)
N
N/**
N  * @brief      Disable Low-Voltage-Reset function
N  * @param      None  
N  * @return     None
N  * @details    This macro disable Low-Voltage-Reset function.
N  *             The register write-protection function should be disabled before using this macro.  
N  */
N#define SYS_DISABLE_LVR()               (SYS->BODCR &= ~SYS_BODCR_LVR_EN_Msk)
N
N/**
N  * @brief      Enable Low-Voltage-Reset function
N  * @param      None  
N  * @return     None
N  * @details    This macro enable Low-Voltage-Reset function.
N  *             The register write-protection function should be disabled before using this macro.  
N  */
N#define SYS_ENABLE_LVR()                (SYS->BODCR |= SYS_BODCR_LVR_EN_Msk)
N
N/**
N  * @brief      Disable Power-on Reset function
N  * @param      None  
N  * @return     None
N  * @details    This macro disable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.  
N  */
N#define SYS_DISABLE_POR()               (SYS->PORCR = 0x5AA5)
N
N/**
N  * @brief      Enable Power-on Reset function
N  * @param      None  
N  * @return     None
N  * @details    This macro enable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.  
N  */
N#define SYS_ENABLE_POR()                (SYS->PORCR = 0)
N
N/**
N  * @brief      Clear reset source flag
N  * @param[in]  u32RstSrc is reset source. Including:
N  *             - \ref SYS_RSTSRC_RSTS_CPU_Msk
N  *             - \ref SYS_RSTSRC_RSTS_MCU_Msk
N  *             - \ref SYS_RSTSRC_RSTS_BOD_Msk
N  *             - \ref SYS_RSTSRC_RSTS_LVR_Msk
N  *             - \ref SYS_RSTSRC_RSTS_WDT_Msk 
N  *             - \ref SYS_RSTSRC_RSTS_RESET_Msk 
N  *             - \ref SYS_RSTSRC_RSTS_POR_Msk   
N  * @return     None
N  * @details    This macro clear reset source flag.   
N  */
N#define SYS_CLEAR_RST_SOURCE(u32RstSrc) (SYS->RSTSRC = (u32RstSrc) )
N
N/**
N  * @brief      Enable register write-protection function
N  * @param      None    
N  * @return     None
N  * @details    This function enable register write-protection function.
N  *             To lock the protected register to forbid write access.
N  */
N__STATIC_INLINE void SYS_LockReg(void)
Xstatic __inline void SYS_LockReg(void)
N{
N    SYS->REGWRPROT = 0;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0;
N}
N
N/**
N  * @brief      Disable register write-protection function
N  * @param      None    
N  * @return     None
N  * @details    This function disable register write-protection function.
N  *             To unlock the protected register to allow write access.           
N  */
N__STATIC_INLINE void SYS_UnlockReg(void)
Xstatic __inline void SYS_UnlockReg(void)
N{
N    while(SYS->REGWRPROT != SYS_REGWRPROT_REGPROTDIS_Msk)
X    while(((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT != (1ul << 0))
N    {
N        SYS->REGWRPROT = 0x59;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x59;
N        SYS->REGWRPROT = 0x16;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x16;
N        SYS->REGWRPROT = 0x88;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x88;
N    }
N}
N
N
N
N
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetBODStatus(void);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nuint32_t SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
Nvoid SYS_DisableBOD(void);
N
N
N/*@}*/ /* end of group SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SYS_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SYS_H__
L 5965 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "clk.h"
L 1 "..\..\..\..\Library\StdDriver\inc\clk.h" 1
N/**************************************************************************//**
N * @file     clk.h
N * @version  V3.0
N * $Revision: 33 $
N * $Date: 17/07/24 1:30p $
N * @brief    M051 Series Clock Control Driver Header File
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __CLK_H__
N#define __CLK_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CLK_Driver CLK Driver
N  @{
N*/
N
N/** @addtogroup CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N#define FREQ_25MHZ         25000000
N#define FREQ_50MHZ         50000000
N#define FREQ_100MHZ       100000000
N#define FREQ_200MHZ       200000000
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL0_HCLK_S_HXT          0x00UL /*!< Setting HCLK clock source as HXT */
N#define CLK_CLKSEL0_HCLK_S_PLL          0x02UL /*!< Setting HCLK clock source as PLL */
N#define CLK_CLKSEL0_HCLK_S_LIRC         0x03UL /*!< Setting HCLK clock source as LIRC */
N#define CLK_CLKSEL0_HCLK_S_HIRC         0x07UL /*!< Setting HCLK clock source as HIRC */
N#define CLK_CLKSEL0_STCLK_S_HXT         0x00UL /*!< Setting SysTick clock source as HXT */
N#define CLK_CLKSEL0_STCLK_S_HXT_DIV2    0x10UL /*!< Setting SysTick clock source as HXT/2 */
N#define CLK_CLKSEL0_STCLK_S_HCLK_DIV2   0x18UL /*!< Setting SysTick clock source as HCLK/2 */
N#define CLK_CLKSEL0_STCLK_S_HIRC_DIV2   0x38UL /*!< Setting SysTick clock source as HIRC/2 */
N#define CLK_CLKSEL0_STCLK_S_HCLK        0x04UL /*!< Setting SysTick clock source as HCLK */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL1_WDT_S_HCLK_DIV2048  0x00000002UL /*!< Setting WDT clock source as HCLK/2048 */
N#define CLK_CLKSEL1_WDT_S_LIRC          0x00000003UL /*!< Setting WDT clock source as LIRC */
N#define CLK_CLKSEL1_ADC_S_HXT           0x00000000UL /*!< Setting ADC clock source as HXT */
N#define CLK_CLKSEL1_ADC_S_PLL           0x00000004UL /*!< Setting ADC clock source as PLL */
N#define CLK_CLKSEL1_ADC_S_HCLK          0x00000008UL /*!< Setting ADC clock source as HCLK */
N#define CLK_CLKSEL1_ADC_S_HIRC          0x0000000CUL /*!< Setting ADC clock source as HIRC */
N#define CLK_CLKSEL1_SPI0_S_PLL          0x00000000UL /*!< Setting SPI0 clock source as PLL */
N#define CLK_CLKSEL1_SPI0_S_HCLK         0x00000010UL /*!< Setting SPI0 clock source as HCLK */
N#define CLK_CLKSEL1_SPI1_S_PLL          0x00000000UL /*!< Setting SPI1 clock source as PLL */
N#define CLK_CLKSEL1_SPI1_S_HCLK         0x00000020UL /*!< Setting SPI1 clock source as HCLK */
N#define CLK_CLKSEL1_TMR0_S_HXT          0x00000000UL /*!< Setting Timer 0 clock source as HXT */
N#define CLK_CLKSEL1_TMR0_S_HCLK         0x00000200UL /*!< Setting Timer 0 clock source as HCLK */
N#define CLK_CLKSEL1_TMR0_S_T0           0x00000300UL /*!< Setting Timer 0 clock source as T0 */
N#define CLK_CLKSEL1_TMR0_S_LIRC         0x00000500UL /*!< Setting Timer 0 clock source as LIRC */
N#define CLK_CLKSEL1_TMR0_S_HIRC         0x00000700UL /*!< Setting Timer 0 clock source as HIRC */
N#define CLK_CLKSEL1_TMR1_S_HXT          0x00000000UL /*!< Setting Timer 1 clock source as HXT */
N#define CLK_CLKSEL1_TMR1_S_HCLK         0x00002000UL /*!< Setting Timer 1 clock source as HCLK */
N#define CLK_CLKSEL1_TMR1_S_T1           0x00003000UL /*!< Setting Timer 1 clock source as T1 */
N#define CLK_CLKSEL1_TMR1_S_LIRC         0x00005000UL /*!< Setting Timer 1 clock source as LIRC */
N#define CLK_CLKSEL1_TMR1_S_HIRC         0x00007000UL /*!< Setting Timer 1 clock source as HIRC */
N#define CLK_CLKSEL1_TMR2_S_HXT          0x00000000UL /*!< Setting Timer 2 clock source as HXT */
N#define CLK_CLKSEL1_TMR2_S_HCLK         0x00020000UL /*!< Setting Timer 2 clock source as HCLK */
N#define CLK_CLKSEL1_TMR2_S_T2           0x00030000UL /*!< Setting Timer 2 clock source as T2 */
N#define CLK_CLKSEL1_TMR2_S_LIRC         0x00050000UL /*!< Setting Timer 2 clock source as LIRC */
N#define CLK_CLKSEL1_TMR2_S_HIRC         0x00070000UL /*!< Setting Timer 2 clock source as HIRC */
N#define CLK_CLKSEL1_TMR3_S_HXT          0x00000000UL /*!< Setting Timer 3 clock source as HXT */
N#define CLK_CLKSEL1_TMR3_S_HCLK         0x00200000UL /*!< Setting Timer 3 clock source as HCLK */
N#define CLK_CLKSEL1_TMR3_S_T3           0x00300000UL /*!< Setting Timer 3 clock source as T3 */
N#define CLK_CLKSEL1_TMR3_S_LIRC         0x00500000UL /*!< Setting Timer 3 clock source as LIRC */
N#define CLK_CLKSEL1_TMR3_S_HIRC         0x00700000UL /*!< Setting Timer 3 clock source as HIRC */
N#define CLK_CLKSEL1_UART_S_HXT          0x00000000UL /*!< Setting UART clock source as HXT */
N#define CLK_CLKSEL1_UART_S_PLL          0x01000000UL /*!< Setting UART clock source as PLL */
N#define CLK_CLKSEL1_UART_S_HIRC         0x03000000UL /*!< Setting UART clock source as HIRC */
N#define CLK_CLKSEL1_PWM01_S_HXT         0x00000000UL /*!< Setting PWM01 clock source as HXT */
N#define CLK_CLKSEL1_PWM01_S_LIRC        0x10000000UL /*!< Setting PWM01 clock source as LIRC */
N#define CLK_CLKSEL1_PWM01_S_HCLK        0x20000000UL /*!< Setting PWM01 clock source as HCLK */
N#define CLK_CLKSEL1_PWM01_S_HIRC        0x30000000UL /*!< Setting PWM01 clock source as HIRC */
N#define CLK_CLKSEL1_PWM23_S_HXT         0x00000000UL /*!< Setting PWM23 clock source as HXT */
N#define CLK_CLKSEL1_PWM23_S_LIRC        0x40000000UL /*!< Setting PWM23 clock source as LIRC */
N#define CLK_CLKSEL1_PWM23_S_HCLK        0x80000000UL /*!< Setting PWM23 clock source as HCLK */
N#define CLK_CLKSEL1_PWM23_S_HIRC        0xC0000000UL /*!< Setting PWM23 clock source as HIRC */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL2_FRQDIV_S_HXT        0x00000000UL /*!< Setting FRQDIV clock source as HXT */
N#define CLK_CLKSEL2_FRQDIV_S_LIRC       0x00000004UL /*!< Setting FRQDIV clock source as LIRC */
N#define CLK_CLKSEL2_FRQDIV_S_HCLK       0x00000008UL /*!< Setting FRQDIV clock source as HCLK */
N#define CLK_CLKSEL2_FRQDIV_S_HIRC       0x0000000CUL /*!< Setting FRQDIV clock source as HIRC */
N#define CLK_CLKSEL2_PWM45_S_HXT         0x00000000UL /*!< Setting PWM45 clock source as HXT */
N#define CLK_CLKSEL2_PWM45_S_LIRC        0x00000010UL /*!< Setting PWM45 clock source as LIRC */
N#define CLK_CLKSEL2_PWM45_S_HCLK        0x00000020UL /*!< Setting PWM45 clock source as HCLK */
N#define CLK_CLKSEL2_PWM45_S_HIRC        0x00000030UL /*!< Setting PWM45 clock source as HIRC */
N#define CLK_CLKSEL2_PWM67_S_HXT         0x00000000UL /*!< Setting PWM67 clock source as HXT */
N#define CLK_CLKSEL2_PWM67_S_LIRC        0x00000040UL /*!< Setting PWM67 clock source as LIRC */
N#define CLK_CLKSEL2_PWM67_S_HCLK        0x00000080UL /*!< Setting PWM67 clock source as HCLK */
N#define CLK_CLKSEL2_PWM67_S_HIRC        0x000000C0UL /*!< Setting PWM67 clock source as HIRC */
N#define CLK_CLKSEL2_WWDT_S_HCLK_DIV2048 0x00020000UL /*!< Setting WWDT clock source as HCLK/2048 */
N#define CLK_CLKSEL2_WWDT_S_LIRC         0x00030000UL /*!< Setting WWDT clock source as LIRC */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV_ADC(x)  (((x)-1) << 16) /*!< CLKDIV Setting for ADC clock divider. It could be 1~256 */
N#define CLK_CLKDIV_UART(x) (((x)-1) <<  8) /*!< CLKDIV Setting for UART clock divider. It could be 1~16 */
N#define CLK_CLKDIV_HCLK(x)  ((x)-1)        /*!< CLKDIV Setting for HCLK clock divider. It could be 1~16 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLLCON constant definitions. PLL = FIN * NF / NR / NO                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PLLCON_PLL_SRC_HXT   0x00000000UL    /*!< For PLL clock source is HXT.  4MHz < FIN < 24MHz */
N#define CLK_PLLCON_PLL_SRC_HIRC  0x00080000UL    /*!< For PLL clock source is HIRC. 4MHz < FIN < 24MHz */
N
N#define CLK_PLLCON_NR(x)         (((x)-2)<<9)    /*!< x must be constant and 2 <= x <= 33.  1.6MHz < FIN/NR < 15MHz */
N#define CLK_PLLCON_NF(x)          ((x)-2)        /*!< x must be constant and 2 <= x <= 513. 100MHz < FIN*NF/NR < 200MHz. (120MHz < FIN*NF/NR < 200MHz is preferred.) */
N
N#define CLK_PLLCON_NO_1          0x0000UL         /*!< For output divider is 1 */
N#define CLK_PLLCON_NO_2          0x4000UL         /*!< For output divider is 2 */
N#define CLK_PLLCON_NO_4          0xC000UL         /*!< For output divider is 4 */
N
N#define CLK_PLLCON_50MHz_HXT     (CLK_PLLCON_PLL_SRC_HXT  | CLK_PLLCON_NR(3)  | CLK_PLLCON_NF( 25) | CLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_50MHz_HIRC    (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(13) | CLK_PLLCON_NF( 59) | CLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50.1918MHz PLL output with 22.1184MHz IRC */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define MODULE_APBCLK(x)         (((x) >>30) & 0x3)    /*!< Calculate APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK */
N#define MODULE_CLKSEL(x)         (((x) >>28) & 0x3)    /*!< Calculate CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x3:CLKSEL2 */
N#define MODULE_CLKSEL_Msk(x)     (((x) >>25) & 0x7)    /*!< Calculate CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos(x)     (((x) >>20) & 0x1f)   /*!< Calculate CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV(x)         (((x) >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV on MODULE index, 0x0:CLKDIV */
N#define MODULE_CLKDIV_Msk(x)     (((x) >>10) & 0xff)   /*!< Calculate CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos(x)     (((x) >>5 ) & 0x1f)   /*!< Calculate CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos(x)      (((x) >>0 ) & 0x1f)   /*!< Calculate APBCLK offset on MODULE index */
N#define MODULE_NoMsk             0x0                 /*!< Not mask on MODULE index */
N/*-------------------------------------------------------------------------------------------------------------------------------------------------*/
N/*                     APBCLK(31:30)|CLKSEL(29:28)|CLKSEL_Msk(27:25)|CLKSEL_Pos(24:20)|CLKDIV(19:18)|CLKDIV_Msk(17:10)|CLKDIV_Pos(9:5)|IP_EN_Pos(4:0)*/
N/*-------------------------------------------------------------------------------------------------------------------------------------------------*/
N
N#define ISP_MODULE     ((0UL<<30)          |(MODULE_NoMsk<<25)                   |(MODULE_NoMsk<<10)        |CLK_AHBCLK_ISP_EN_Pos )     /*!< ISP Module */
N#define EBI_MODULE     ((0UL<<30)          |(MODULE_NoMsk<<25)                   |(MODULE_NoMsk<<10)        |CLK_AHBCLK_EBI_EN_Pos )     /*!< EBI Module */
N#define HDIV_MODULE    ((0UL<<30)          |(MODULE_NoMsk<<25)                   |(MODULE_NoMsk<<10)        |CLK_AHBCLK_HDIV_EN_Pos )    /*!< HDIV Module */
N
N#define WDT_MODULE     ((1UL<<30)|(0x1<<28)|(0x3<<25)         |( 0<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_WDT_EN_Pos )     /*!< WDT Module */
N#define TMR0_MODULE    ((1UL<<30)|(0x1<<28)|(0x7<<25)         |( 8<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_TMR0_EN_Pos)     /*!< TMR0 Module */
N#define TMR1_MODULE    ((1UL<<30)|(0x1<<28)|(0x7<<25)         |(12<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_TMR1_EN_Pos)     /*!< TMR1 Module */
N#define TMR2_MODULE    ((1UL<<30)|(0x1<<28)|(0x7<<25)         |(16<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_TMR2_EN_Pos)     /*!< TMR2 Module */
N#define TMR3_MODULE    ((1UL<<30)|(0x1<<28)|(0x7<<25)         |(20<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_TMR3_EN_Pos)     /*!< TMR3 Module */
N#define FDIV_MODULE    ((1UL<<30)|(0x3<<28)|(0x3<<25)         |( 2<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_FDIV_EN_Pos)     /*!< FDIV Module */
N#define I2C0_MODULE    ((1UL<<30)          |(MODULE_NoMsk<<25)                   |(MODULE_NoMsk<<10)        |CLK_APBCLK_I2C0_EN_Pos)     /*!< I2C0 Module */
N#define I2C1_MODULE    ((1UL<<30)          |(MODULE_NoMsk<<25)                   |(MODULE_NoMsk<<10)        |CLK_APBCLK_I2C1_EN_Pos)     /*!< I2C1 Module */
N#define SPI0_MODULE    ((1UL<<30)|(0x1<<28)|(0x1<<25)         |( 4<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_SPI0_EN_Pos)     /*!< SPI0 Module */
N#define SPI1_MODULE    ((1UL<<30)|(0x1<<28)|(0x1<<25)         |( 5<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_SPI1_EN_Pos)     /*!< SPI1 Module */
N#define UART0_MODULE   ((1UL<<30)|(0x1<<28)|(0x3<<25)         |(24<<20)|(0x0<<18)|(0x0F<<10)        |( 8<<5)|CLK_APBCLK_UART0_EN_Pos)    /*!< UART0 Module */
N#define UART1_MODULE   ((1UL<<30)|(0x1<<28)|(0x3<<25)         |(24<<20)|(0x0<<18)|(0x0F<<10)        |( 8<<5)|CLK_APBCLK_UART1_EN_Pos)    /*!< UART1 Module */
N#define PWM01_MODULE   ((1UL<<30)|(0x1<<28)|(0x3<<25)         |(28<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_PWM01_EN_Pos)    /*!< PWM01 Module */
N#define PWM23_MODULE   ((1UL<<30)|(0x1<<28)|(0x3<<25)         |(30<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_PWM23_EN_Pos)    /*!< PWM23 Module */
N#define PWM45_MODULE   ((1UL<<30)|(0x3<<28)|(0x3<<25)         |( 4<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_PWM45_EN_Pos)    /*!< PWM45 Module */
N#define PWM67_MODULE   ((1UL<<30)|(0x3<<28)|(0x3<<25)         |( 6<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_PWM67_EN_Pos)    /*!< PWM67 Module */
N#define ADC_MODULE     ((1UL<<30)|(0x1<<28)|(0x3<<25)         |( 2<<20)|(0x0<<18)|(0xFF<<10)        |(16<<5)|CLK_APBCLK_ADC_EN_Pos)      /*!< ADC Module */
N#define ACMP01_MODULE  ((1UL<<30)          |(MODULE_NoMsk<<25)                   |(MODULE_NoMsk<<10)        |CLK_APBCLK_ACMP01_EN_Pos)   /*!< ACMP01 Module */
N#define ACMP23_MODULE  ((1UL<<30)          |(MODULE_NoMsk<<25)                   |(MODULE_NoMsk<<10)        |CLK_APBCLK_ACMP23_EN_Pos)   /*!< ACMP23 Module */
N#define WWDT_MODULE    ((1UL<<30)|(0x3<<28)|(0x3<<25)         |(16<<20)          |(MODULE_NoMsk<<10)        |CLK_APBCLK_WDT_EN_Pos )     /*!< WWDT Module */
N
N
N/*@}*/ /* end of group CLK_EXPORTED_CONSTANTS */
N
N/** @addtogroup CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Get PLL clock frequency
N  * @param      None     
N  * @return     PLL frequency
N  * @details    This function get PLL frequency. The frequency unit is Hz.    
N  */
N__STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
Xstatic __inline uint32_t CLK_GetPLLClockFreq(void)
N{
N    uint32_t u32PllFreq = 0, u32PllReg;
N    uint32_t u32FIN, u32NF, u32NR, u32NO;
N    uint8_t au8NoTbl[4] = {1, 2, 2, 4};
N
N    u32PllReg = CLK->PLLCON;
X    u32PllReg = ((CLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PLLCON;
N
N    if(u32PllReg & (CLK_PLLCON_PD_Msk | CLK_PLLCON_OE_Msk))
X    if(u32PllReg & ((1ul << 16) | (1ul << 18)))
N        return 0;           /* PLL is in power down mode or fix low */
N
N    if(u32PllReg & CLK_PLLCON_PLL_SRC_HIRC)
X    if(u32PllReg & 0x00080000UL)
N        u32FIN = __HIRC;    /* PLL source clock from HIRC */
X        u32FIN = (22118400UL);     
N    else
N        u32FIN = __HXT;     /* PLL source clock from HXT */
X        u32FIN = (12000000UL);      
N
N    if(u32PllReg & CLK_PLLCON_BP_Msk)
X    if(u32PllReg & (1ul << 17))
N        return u32FIN;      /* PLL is in bypass mode */
N
N    /* PLL is output enabled in normal work mode */
N    u32NO = au8NoTbl[((u32PllReg & CLK_PLLCON_OUT_DV_Msk) >> CLK_PLLCON_OUT_DV_Pos)];
X    u32NO = au8NoTbl[((u32PllReg & (3ul << 14)) >> 14)];
N    u32NF = ((u32PllReg & CLK_PLLCON_FB_DV_Msk) >> CLK_PLLCON_FB_DV_Pos) + 2;
X    u32NF = ((u32PllReg & (0x1FFul << 0)) >> 0) + 2;
N    u32NR = ((u32PllReg & CLK_PLLCON_IN_DV_Msk) >> CLK_PLLCON_IN_DV_Pos) + 2;
X    u32NR = ((u32PllReg & (0x1Ful << 9)) >> 9) + 2;
N
N    /* u32FIN is shifted 2 bits to avoid overflow */
N    u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
N
N    return u32PllFreq;
N}
N
N/**
N  * @brief      This function execute delay function.
N  * @param[in]  us  Delay time. The Max value is 2^24 / CPU Clock(MHz). Ex:
N  *                             50MHz => 335544us, 48MHz => 349525us, 28MHz => 699050us ...
N  * @return     None
N  * @details    Use the SysTick to generate the delay time and the UNIT is in us.
N  *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N  *             User can use SystemCoreClockUpdate() to calculate CyclesPerUs automatically before using this function.
N  */
N__STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
Xstatic __inline void CLK_SysTickDelay(uint32_t us)
N{
N    SysTick->LOAD = us * CyclesPerUs;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = us * CyclesPerUs;
N    SysTick->VAL  = (0x00);
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x00);
N    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2) | (1UL << 0);
N
N    /* Waiting for down-count to zero */
N    while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
X    while((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16)) == 0);
N    
N    /* Disable SysTick counter */
N    SysTick->CTRL = 0;    
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0;    
N}
N
N/**
N  * @brief      This function execute long delay function.
N  * @param[in]  us  Delay time. 
N  * @return     None
N  * @details    Use the SysTick to generate the long delay time and the UNIT is in us.
N  *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N  *             User can use SystemCoreClockUpdate() to calculate CyclesPerUs automatically before using this function.
N  */
N__STATIC_INLINE void CLK_SysTickLongDelay(uint32_t us)
Xstatic __inline void CLK_SysTickLongDelay(uint32_t us)
N{
N    uint32_t delay;
N        
N    /* It should <= 335544us for each delay loop */
N    delay = 335544UL;
N
N    do
N    {
N        if(us > delay)
N        {
N            us -= delay;
N        }
N        else
N        {
N            delay = us;
N            us = 0UL;
N        }        
N        
N        SysTick->LOAD = delay * CyclesPerUs;
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = delay * CyclesPerUs;
N        SysTick->VAL  = (0x0UL);
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x0UL);
N        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2) | (1UL << 0);
N
N        /* Waiting for down-count to zero */
N        while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0UL);
X        while((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16)) == 0UL);
N
N        /* Disable SysTick counter */
N        SysTick->CTRL = 0UL;
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0UL;
N    
N    }while(us > 0UL);
N    
N}
N
N
Nvoid CLK_DisableCKO(void);
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
Nvoid CLK_PowerDown(void);
Nvoid CLK_Idle(void);
Nuint32_t CLK_GetHXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetPCLKFreq(void);
Nuint32_t CLK_GetCPUFreq(void);
Nuint32_t CLK_SetCoreClock(uint32_t u32Hclk);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nuint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
Nvoid CLK_DisablePLL(void);
Nuint32_t CLK_WaitClockReady(uint32_t u32ClkMask);
Nvoid CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count);
Nvoid CLK_DisableSysTick(void);
N
N
N
N
N/*@}*/ /* end of group CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CLK_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif //__CLK_H__
N
N
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5966 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "adc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\adc.h" 1
N/**************************************************************************//**
N * @file     adc.h
N * @version  V3.0
N * $Revision: 18 $
N * $Date: 15/05/20 2:07p $
N * @brief    M051 series ADC driver header file
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __ADC_H__
N#define __ADC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup ADC_Driver ADC Driver
N  @{
N*/
N
N/** @addtogroup ADC_EXPORTED_CONSTANTS ADC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ADCR Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCR_ADEN_CONVERTER_DISABLE   (0UL<<ADC_ADCR_ADEN_Pos)   /*!< ADC converter disable          */
N#define ADC_ADCR_ADEN_CONVERTER_ENABLE    (1UL<<ADC_ADCR_ADEN_Pos)   /*!< ADC converter enable           */
N
N#define ADC_ADCR_ADMD_SINGLE            (0UL<<ADC_ADCR_ADMD_Pos)     /*!< Single mode                */
N#define ADC_ADCR_ADMD_BURST             (1UL<<ADC_ADCR_ADMD_Pos)     /*!< Burst mode                 */
N#define ADC_ADCR_ADMD_SINGLE_CYCLE      (2UL<<ADC_ADCR_ADMD_Pos)     /*!< Single cycle scan mode     */
N#define ADC_ADCR_ADMD_CONTINUOUS        (3UL<<ADC_ADCR_ADMD_Pos)     /*!< Continuous scan mode       */
N
N#define ADC_ADCR_DIFFEN_SINGLE_END      (0UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Single end input mode      */
N#define ADC_ADCR_DIFFEN_DIFFERENTIAL    (1UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Differential input type    */
N
N#define ADC_ADCR_DMOF_UNSIGNED_OUTPUT   (0UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the straight binary format as the output format of the conversion result   */
N#define ADC_ADCR_DMOF_TWOS_COMPLEMENT   (1UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the 2's complement format as the output format of the conversion result    */
N
N#define ADC_ADCR_TRGEN_DISABLE          (0UL<<ADC_ADCR_TRGEN_Pos)    /*!< Disable triggering of A/D conversion by external STADC pin or PWM   */
N#define ADC_ADCR_TRGEN_ENABLE           (1UL<<ADC_ADCR_TRGEN_Pos)    /*!< Enable triggering of A/D conversion by external STADC pin or PWM  */
N
N#define ADC_ADCR_TRGS_STADC             (0UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by external STADC pin */
N#define ADC_ADCR_TRGS_PWM               (3UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by PWM */
N
N#define ADC_ADCR_TRGCOND_LOW_LEVEL      (0UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Low level active     */
N#define ADC_ADCR_TRGCOND_HIGH_LEVEL     (1UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC High level active    */
N#define ADC_ADCR_TRGCOND_FALLING_EDGE   (2UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Falling edge active  */
N#define ADC_ADCR_TRGCOND_RISING_EDGE    (3UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Rising edge active   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCHER Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCHER_PRESEL_EXT_INPUT_SIGNAL         (0UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the external analog input                   */
N#define ADC_ADCHER_PRESEL_INT_BANDGAP              (1UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the internal bandgap voltage                */
N#define ADC_ADCHER_PRESEL_INT_TEMPERATURE_SENSOR   (2UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the output of internal temperature sensor   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCMPR Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCMPR_CMPD(x)                    ((x) << ADC_ADCMPR_CMPD_Pos)          /*!< Compare value for compare function            */
N#define ADC_ADCMPR_CMPMATCNT(x)               (((x)-1) << ADC_ADCMPR_CMPMATCNT_Pos) /*!< Match count for compare function              */
N#define ADC_ADCMPR_CMPCH(x)                   ((x) << ADC_ADCMPR_CMPCH_Pos)         /*!< Compare channel for compare function          */
N#define ADC_ADCMPR_CMPCOND_LESS_THAN          (0<<ADC_ADCMPR_CMPCOND_Pos)           /*!< The compare condition is "less than"          */
N#define ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL   (1<<ADC_ADCMPR_CMPCOND_Pos)           /*!< The compare condition is "greater than or equal to" */
N#define ADC_ADCMPR_CMPIE_INTERRUPT_ENABLE     (ADC_ADCMPR_CMPIE_Msk)                /*!< The compare function interrupt enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Interrupt Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADF_INT         (ADC_ADSR_ADF_Msk)          /*!< ADC convert complete interrupt */
N#define ADC_CMP0_INT        (ADC_ADSR_CMPF0_Msk)        /*!< ADC comparator 0 interrupt */
N#define ADC_CMP1_INT        (ADC_ADSR_CMPF1_Msk)        /*!< ADC comparator 1 interrupt */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Operation Mode Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_SINGLE_MODE         0   /*!< ADC single mode            */
N#define ADC_BURST_MODE          1   /*!< ADC burst mode             */
N#define ADC_SINGLE_CYCLE_MODE   2   /*!< ADC single-cycle scan mode */
N#define ADC_CONTINUOUS_MODE     3   /*!< ADC continuous scan mode   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Trigger Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LOW_LEVEL      0   /*!< ADC external trigger condition is low level trigger    */
N#define ADC_HIGH_LEVEL     1   /*!< ADC external trigger condition is high level trigger   */
N#define ADC_FALLING_EDGE   2   /*!< ADC external trigger condition is falling edge trigger */
N#define ADC_RISING_EDGE    3   /*!< ADC external trigger condition is rising edge trigger  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Compare Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LESS_THAN          0   /*!< ADC compare condition is "less than the compare value"                */
N#define ADC_GREATER_OR_EQUAL   1   /*!< ADC compare condition is "greater than or equal to the compare value" */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Constant Definitions of ADC Channel 7 Input Source                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_CH7_EXT_INPUT_SIGNAL         0   /*!< External input signal       */
N#define ADC_CH7_INT_BANDGAP              1   /*!< Internal band-gap voltage   */
N#define ADC_CH7_INT_TEMPERATURE_SENSOR   2   /*!< Internal temperature sensor */
N
N
N/*@}*/ /* end of group ADC_EXPORTED_CONSTANTS */
N
N/** @addtogroup ADC_EXPORTED_FUNCTIONS ADC Exported Functions
N  @{
N*/
N
N/**
N  * @brief Configure the analog input source of channel 7.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Source Decides the analog input source of channel 7. Valid values are:
N  *                       - \ref ADC_ADCHER_PRESEL_EXT_INPUT_SIGNAL        : External analog input.
N  *                       - \ref ADC_ADCHER_PRESEL_INT_BANDGAP             : Internal bandgap voltage.
N  *                       - \ref ADC_ADCHER_PRESEL_INT_TEMPERATURE_SENSOR  : Output of internal temperature sensor.
N  * @return None
N  * @details Channel 7 supports 3 input sources: External analog voltage, internal Band-gap voltage, and internal temperature sensor output.
N  * @note While using VBG as channel 7 source, ADC module clock must not exceed 300kHz.
N  */
N#define ADC_CONFIG_CH7(adc, u32Source) ((adc)->ADCHER = ((adc)->ADCHER & ~ADC_ADCHER_PRESEL_Msk) | (u32Source))
N
N/**
N  * @brief Get conversion data of specified channel.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 7.
N  * @return  16-bit data.
N  * @details Read RSLT bit field to get conversion data.
N  */
N#define ADC_GET_CONVERSION_DATA(adc, u32ChNum) (((adc)->ADDR[(u32ChNum)] & ADC_ADDR_RSLT_Msk)>>ADC_ADDR_RSLT_Pos)
N
N/**
N  * @brief Return the user-specified interrupt flags.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Valid values are:
N  *                     - \ref ADC_ADF_INT          :Convert complete interrupt flag.
N  *                     - \ref ADC_CMP0_INT         :Comparator 0 interrupt flag.
N  *                     - \ref ADC_CMP1_INT         :Comparator 1 interrupt flag.
N  * @return  User specified interrupt flags.
N  * @details Get the status of the ADC interrupt flag.
N  */
N#define ADC_GET_INT_FLAG(adc, u32Mask) ((adc)->ADSR & (u32Mask))
N
N/**
N  * @brief This macro clear the selected interrupt status bits.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Valid values are:
N  *                     - \ref ADC_ADF_INT          :Convert complete interrupt flag.
N  *                     - \ref ADC_CMP0_INT         :Comparator 0 interrupt flag.
N  *                     - \ref ADC_CMP1_INT         :Comparator 1 interrupt flag.
N  * @return  None
N  * @details ADF (ADSR[0])/CMPF0 (ADSR[1])/CMPF2 (ADSR[2]) can be cleared by writing 1 to itself.
N  */
N#define ADC_CLR_INT_FLAG(adc, u32Mask) ((adc)->ADSR = (u32Mask))
N
N/**
N  * @brief Get the busy state of ADC.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @retval 0 ADC is not busy.
N  * @retval 1 ADC is busy.
N  * @details ADSR[3] (BUSY) is a mirror of ADCR[11] (ADST).
N  */
N#define ADC_IS_BUSY(adc) ((adc)->ADSR & ADC_ADSR_BUSY_Msk ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is over written or not.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 7.
N  * @retval 0 ADC data is not overrun.
N  * @retval 1 ADC data is overrun.
N  * @details ADSR[23:16] (OVERRUN) is the mirror of ADDR0~7[16] OVERRUN bits.
N  */
N#define ADC_IS_DATA_OVERRUN(adc, u32ChNum) (((adc)->ADSR & (1<<(ADC_ADSR_OVERRUN_Pos+(u32ChNum)))) ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is valid or not.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 7.
N  * @retval 0 ADC data is not valid.
N  * @retval 1 ADC data is valid.
N  * @details VALID (ADDR0~7[17]) is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
N  */
N#define ADC_IS_DATA_VALID(adc, u32ChNum) ((adc)->ADSR & (0x1<<(ADC_ADSR_VALID_Pos+(u32ChNum))) ? 1 : 0)
N
N/**
N  * @brief Power down ADC module.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Disable A/D converter analog circuit for saving power consumption.
N  */
N#define ADC_POWER_DOWN(adc) ((adc)->ADCR &= ~ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Power on ADC module.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Before starting A/D conversion function, ADEN bit (ADCR[0]) should be set to 1.
N  */
N#define ADC_POWER_ON(adc) ((adc)->ADCR |= ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Configure the comparator 0 and enable it.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7.
N  * @param[in] u32Condition Specifies the compare condition. Valid values are:
N  *                          - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *                          - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value".
N  * @param[in] u32Data Specifies the compare value, valid value are between 0 ~ 0xFFF.
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP0(ADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *          Means ADC will assert comparator 0 flag if channel 5 conversion result is greater than or
N  *          equal to 0x800 for 10 times continuously.
N  */
N#define ADC_ENABLE_CMP0(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) ((adc)->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                           (u32Condition) | \
N                                                           ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                           (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                           ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP0(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) ((adc)->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                            (u32Condition) |                                                            ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                            (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                           ADC_ADCMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 0
N  * @param[in] adc The pointer of the specified ADC module
N  * @return None
N  * @details Set CMPEN (ADCMPR0[0]) to 0 and reset comparator 0 configurations to disable ADC compare function.
N  */
N#define ADC_DISABLE_CMP0(adc) ((adc)->ADCMPR[0] = 0)
N
N/**
N  * @brief Configure the comparator 1 and enable it.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7.
N  * @param[in] u32Condition Specifies the compare condition. Valid values are:
N  *                          - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *                          - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value".
N  * @param[in] u32Data Specifies the compare value, valid value are between 0 ~ 0xFFF.
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP1(ADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *          Means ADC will assert comparator 1 flag if channel 5 conversion result is greater than or
N  *          equal to 0x800 for 10 times continuously.
N  */
N#define ADC_ENABLE_CMP1(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) ((adc)->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                           (u32Condition) | \
N                                                           ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                           (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                           ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP1(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) ((adc)->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                            (u32Condition) |                                                            ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                            (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                           ADC_ADCMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 1.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Set CMPEN (ADCMPR1[0]) to 0 and reset comparator 1 configurations to disable ADC compare function.
N  */
N#define ADC_DISABLE_CMP1(adc) ((adc)->ADCMPR[1] = 0)
N
N/**
N  * @brief Set ADC input channel.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask  Channel enable bit. Each bit corresponds to a input channel. Bit 0 is channel 0, bit 1 is channel 1..., bit 7 is channel 7.
N  * @return None
N  * @details Enabled channel will be converted while ADC starts.
N  * @note In single mode, ADC can only convert 1 channel. If more than 1 channel are enabled, only the channel with smallest number will be converted.
N  */
N#define ADC_SET_INPUT_CHANNEL(adc, u32Mask) ((adc)->ADCHER = ((adc)->ADCHER & ~ADC_ADCHER_CHEN_Msk) | (u32Mask))
N
N/**
N  * @brief Set the output format mode.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Format Decides the output format. Valid values are:
N  *                      - \ref ADC_ADCR_DMOF_UNSIGNED_OUTPUT      : Select the straight binary format as the output format of the conversion result.
N  *                      - \ref ADC_ADCR_DMOF_TWOS_COMPLEMENT      : Select the 2's complement format as the output format of the conversion result.
N  * @return None
N  * @details  The macro is used to set the output format of ADC differential input mode.
N  * @note On M05xxBN, Burst mode and ADC compare function can not support 2's complement output format, u32Format should be set to 0.
N  */
N#define ADC_SET_DMOF(adc, u32Format) ((adc)->ADCR = ((adc)->ADCR & ~ADC_ADCR_DMOF_Msk) | (u32Format))
N
N/**
N  * @brief Start the A/D conversion.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Set ADST bit to 1 to start the A/D conversion.
N  */
N#define ADC_START_CONV(adc) ((adc)->ADCR |= ADC_ADCR_ADST_Msk)
N
N/**
N  * @brief Stop the A/D conversion.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details ADST (ADCR[11]) will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode. 
N  *          In continuous scan mode and burst mode, A/D conversion is continuously performed until software writes 0 to this bit.
N  * @note On M05xxBN, when the ADST bit is cleared to 0, the ADST bit must be kept at 0 at least one ADC peripheral clock period
N  *       before setting it to 1 again, otherwise the A/D converter may not work.
N  *       If ADST bit is cleared to 0 when ADC is in converting, the BUSY bit will be cleared to 0 immediately, ADC will finish
N  *       the current conversion and save the result to the ADDRx register of the enabled channel.
N  *       On M05xxDN and M05xxDE, if ADST bit is cleared to 0 when ADC is in converting, the BUSY bit will be cleared to 0 immediately,
N  *       ADC will terminate the current conversion and enter idle state directly.
N  */
N#define ADC_STOP_CONV(adc) ((adc)->ADCR &= ~ADC_ADCR_ADST_Msk)
N
Nvoid ADC_Open(ADC_T *adc,
N              uint32_t u32InputMode,
N              uint32_t u32OpMode,
N              uint32_t u32ChMask);
Nvoid ADC_Close(ADC_T *adc);
Nvoid ADC_EnableHWTrigger(ADC_T *adc,
N                         uint32_t u32Source,
N                         uint32_t u32Param);
Nvoid ADC_DisableHWTrigger(ADC_T *adc);
Nvoid ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
Nvoid ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);
N
N
N
N/*@}*/ /* end of group ADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ADC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ADC_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 5967 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "ebi.h"
L 1 "..\..\..\..\Library\StdDriver\inc\ebi.h" 1
N/**************************************************************************//**
N * @file     ebi.h
N * @version  V3.00
N * $Revision: 7 $
N * $Date: 15/05/20 2:07p $
N * @brief    M051 series EBI driver header file
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __EBI_H__
N#define __EBI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup EBI_Driver EBI Driver
N  @{
N*/
N
N/** @addtogroup EBI_EXPORTED_CONSTANTS EBI Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Miscellaneous Constant Definitions                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BASE_ADDR           0x60000000UL /*!< EBI base address */
N#define EBI_MAX_SIZE            0x00020000UL /*!< Maximum EBI size */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI data bus width                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BUSWIDTH_8BIT       8     /*!< EBI bus width is 8-bit */
N#define EBI_BUSWIDTH_16BIT      16    /*!< EBI bus width is 16-bit */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI MCLK divider and Timing                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_MCLKDIV_1           0x0UL /*!< EBI output clock(MCLK) is HCLK/1 */
N#define EBI_MCLKDIV_2           0x1UL /*!< EBI output clock(MCLK) is HCLK/2 */
N#define EBI_MCLKDIV_4           0x2UL /*!< EBI output clock(MCLK) is HCLK/4 */
N#define EBI_MCLKDIV_8           0x3UL /*!< EBI output clock(MCLK) is HCLK/8 */
N#define EBI_MCLKDIV_16          0x4UL /*!< EBI output clock(MCLK) is HCLK/16 */
N#define EBI_MCLKDIV_32          0x5UL /*!< EBI output clock(MCLK) is HCLK/32 */
N
N#define EBI_TIMING_FASTEST      0x0UL /*!< EBI timing is the fastest */
N#define EBI_TIMING_VERYFAST     0x1UL /*!< EBI timing is very fast */
N#define EBI_TIMING_FAST         0x2UL /*!< EBI timing is fast */
N#define EBI_TIMING_NORMAL       0x3UL /*!< EBI timing is normal  */
N#define EBI_TIMING_SLOW         0x4UL /*!< EBI timing is slow */
N#define EBI_TIMING_VERYSLOW     0x5UL /*!< EBI timing is very slow */
N#define EBI_TIMING_SLOWEST      0x6UL /*!< EBI timing is the slowest */
N
N/*@}*/ /* end of group EBI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup EBI_EXPORTED_FUNCTIONS EBI Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Read 8-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  *
N  * @return     8-bit Data
N  *
N  * @details    This macro read 8-bit data from specify EBI address.
N  */
N#define EBI_READ_DATA8(u32Addr)             (*((volatile unsigned char *)(EBI_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 8-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro write 8-bit data to specify EBI address.
N  */
N#define EBI_WRITE_DATA8(u32Addr, u32Data)   (*((volatile unsigned char *)(EBI_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 16-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  *
N  * @return     16-bit Data
N  *
N  * @details    This macro read 16-bit data from specify EBI address.
N  */
N#define EBI_READ_DATA16(u32Addr)            (*((volatile unsigned short *)(EBI_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 16-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro write 16-bit data to specify EBI address.
N  */
N#define EBI_WRITE_DATA16(u32Addr, u32Data)  (*((volatile unsigned short *)(EBI_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 32-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  *
N  * @return     32-bit Data
N  *
N  * @details    This macro read 32-bit data from specify EBI address.
N  */
N#define EBI_READ_DATA32(u32Addr)            (*((volatile unsigned int *)(EBI_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 32-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro write 32-bit data to specify EBI address.
N  */
N#define EBI_WRITE_DATA32(u32Addr, u32Data)  (*((volatile unsigned int *)(EBI_BASE_ADDR+(u32Addr))) = (u32Data))
N
Nvoid EBI_Open(uint32_t u32Bank, uint32_t u32DataWidth, uint32_t u32TimingClass, uint32_t u32BusMode, uint32_t u32CSActiveLevel);
Nvoid EBI_Close(uint32_t u32Bank);
Nvoid EBI_SetBusTiming(uint32_t u32Bank, uint32_t u32TimingConfig, uint32_t u32MclkDiv);
N
N/*@}*/ /* end of group EBI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group EBI_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__EBI_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5968 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "fmc.h"
L 1 "..\..\..\..\Library\StdDriver\inc\fmc.h" 1
N/**************************************************************************//**
N * @file     FMC.h
N * @version  V3.0
N * $Revision: 19 $
N * $Date: 15/05/22 3:06p $
N * @brief    M051 Series Flash Memory Controller Driver Header File
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#include "M051Series.h"
L 1 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 1
N/**************************************************************************//**
N * @file     M051Series.h
N * @version  V3.0
N * $Revision: 80 $
N * $Date: 15/08/10 9:27a $
N * @brief    M051 Series Peripheral Access Layer Header File
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of M051 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N  */
N
N#ifndef __M051Series_H__
S#define __M051Series_H__
S
S
S/*
S * ==========================================================================
S * ---------- Interrupt Number Definition -----------------------------------
S * ==========================================================================
S */
S
S/**
S * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
S */
Stypedef enum IRQn
S{
S    /******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
S    NonMaskableInt_IRQn       = -14,      /*!< 2 Non Maskable Interrupt                             */
S    HardFault_IRQn            = -13,      /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
S    SVCall_IRQn               = -5,       /*!< 11 Cortex-M0 SV Call Interrupt                       */
S    PendSV_IRQn               = -2,       /*!< 14 Cortex-M0 Pend SV Interrupt                       */
S    SysTick_IRQn              = -1,       /*!< 15 Cortex-M0 System Tick Interrupt                   */
S
S    /******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
S    BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */
S    WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
S    EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                      */
S    EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                      */
S    GPIO_P0P1_IRQn            = 4,        /*!< GPIO_P0P1 Interrupt                                  */
S    GPIO_P2P3P4_IRQn          = 5,        /*!< GPIO_P2P3P4 Interrupt                                */
S    PWMA_IRQn                 = 6,        /*!< PWMA Interrupt                                       */
S    PWMB_IRQn                 = 7,        /*!< PWMB Interrupt                                       */
S    TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
S    TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
S    TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
S    TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
S    UART0_IRQn                = 12,       /*!< UART0 Interrupt                                      */
S    UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
S    SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
S    SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                       */
S    I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
S    I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
S    ACMP01_IRQn               = 25,       /*!< ACMP0/1 Interrupt                                    */
S    ACMP23_IRQn               = 26,       /*!< ACMP2/3 Interrupt                                    */
S    PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
S    ADC_IRQn                  = 29        /*!< ADC Interrupt                                        */
S
S} IRQn_Type;
S
S
S/*
S * ==========================================================================
S * ----------- Processor and Core Peripheral Section ------------------------
S * ==========================================================================
S */
S
S/* Configuration of the Cortex-M0 Processor and Core Peripherals */
S#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
S#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
S#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
S
S
S#include "core_cm0.h"                   /*!< Cortex-M0 processor and core peripherals             */
S#include "system_M051Series.h"          /*!< M051Series System                                    */
S
S
S#if defined ( __CC_ARM   )
S#pragma anon_unions
S#endif
S
S
S/**
S * Initialize the system clock
S *
S * @param  none
S * @return none
S *
S * @brief  Setup the microcontroller system
S *         Initialize the PLL and update the SystemFrequency variable
S */
Sextern void SystemInit(void);
S
S
S/******************************************************************************/
S/*                Device Specific Peripheral registers structures             */
S/******************************************************************************/
S
S/** @addtogroup REGISTER Control Register
S
S  @{
S
S*/
S
S/*---------------------- Analog Comparator Controller -------------------------*/
S/** @addtogroup ACMP Analog Comparator Controller(ACMP)
S  Memory Mapped Structure for ACMP Controller
S  @{
S
S */
S
Stypedef struct
S{
S
S
S/**
S * @var ACMP_T::CR
S * Offset: 0x00,0x04  ACMP Comparator Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ACMPEN    |Comparator Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |        |          |Note: Comparator output needs to wait 2 us stable time after ACMPEN is set.
S * |[1]     |ACMPIE    |Comparator Interrupt Enable
S * |        |          |0 = Interrupt function Disabled.
S * |        |          |1 = Interrupt function Enabled.
S * |[2]     |HYSEN     |Comparator Hysteresis Enable
S * |        |          |0 = Hysteresis function Disabled.
S * |        |          |1 = Hysteresis function Enabled.
S * |[4]     |NEGSEL    |Comparator negative input selection
S * |        |          |0 = The ACMP0/2_N pin is selected as the source of negative comparator input.
S * |        |          |1 = The internal band-gap reference voltage is selected as the source of negative comparator input.
S * |[6]     |ACMPOINV  |Comparator output inverse select
S * |        |          |0 = The comparator output inverse function Disabled.
S * |        |          |1 = The comparator output inverse function Enabled.
S * @var ACMP_T::SR
S * Offset: 0x08  ACMP Comparator Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ACMPF0/2  |Comparator Flag 0/2
S * |        |          |This bit is set by hardware whenever the comparator output changes state. This will cause an interrupt if ACMPIE is set to 1.
S * |        |          |Write 1 to clear this bit to zero.
S * |[1]     |ACMPF1/3  |Comparator Flag 1/3
S * |        |          |This bit is set by hardware whenever the comparator output changes state. This will cause an interrupt if ACMPIE is set to 1.
S * |        |          |Write 1 to clear this bit to zero.
S * |[2]     |ACMPO0/2  |Comparator 0/2 Output
S * |        |          |Synchronized to the APB clock to allow reading by software. Cleared when the comparator is disabled (ACMP_CR0/2[0] = 0).
S * |[3]     |ACMPO1/3  |Comparator 1/3 Output
S * |        |          |Synchronized to the APB clock to allow reading by software. Cleared when the comparator is disabled (ACMP_CR1/3[0] = 0).
S */
S
S    __IO uint32_t CR[2];         /* Offset: 0x00,0x04  ACMP Comparator Control Register                              */
S    __IO uint32_t SR;            /* Offset: 0x08  ACMP Comparator Status Register                                    */
S
S} ACMP_T;
S
S
S
S/** @addtogroup ACMP_CONST ACMP Bit Field Definition
S  Constant Definitions for ACMP Controller
S  @{
S */
S
S/* ACMP_CR Bit Field Definitions */
S#define ACMP_CR_ACMPOINV_Pos   6                                 /*!< ACMP_T::CR: ACMPOINV Position */
S#define ACMP_CR_ACMPOINV_Msk   (1ul << ACMP_CR_ACMPOINV_Pos)     /*!< ACMP_T::CR: ACMPOINV Mask */
S
S#define ACMP_CR_NEGSEL_Pos     4                                 /*!< ACMP_T::CR: NEGSEL Position */
S#define ACMP_CR_NEGSEL_Msk     (1ul << ACMP_CR_NEGSEL_Pos)       /*!< ACMP_T::CR: NEGSEL Mask */
S
S#define ACMP_CR_HYSEN_Pos      2                                 /*!< ACMP_T::CR: HYSEN Position */
S#define ACMP_CR_HYSEN_Msk      (1ul << ACMP_CR_HYSEN_Pos)        /*!< ACMP_T::CR: HYSEN Mask */
S
S#define ACMP_CR_ACMPIE_Pos     1                                 /*!< ACMP_T::CR: ACMPIE Position */
S#define ACMP_CR_ACMPIE_Msk     (1ul << ACMP_CR_ACMPIE_Pos)       /*!< ACMP_T::CR: ACMPIE Mask */
S
S#define ACMP_CR_ACMPEN_Pos     0                                 /*!< ACMP_T::CR: ACMPEN Position */
S#define ACMP_CR_ACMPEN_Msk     (1ul << ACMP_CR_ACMPEN_Pos)       /*!< ACMP_T::CR: ACMPEN Mask */
S
S/* ACMP_SR01 Bit Field Definitions */
S#define ACMP_SR_ACMPO1_Pos   3                                   /*!< ACMP_T::SR: ACMPO1 Position */
S#define ACMP_SR_ACMPO1_Msk   (1ul << ACMP_SR_ACMPO1_Pos)         /*!< ACMP_T::SR: ACMPO1 Mask */
S
S#define ACMP_SR_ACMPO0_Pos   2                                   /*!< ACMP_T::SR: ACMPO0 Position */
S#define ACMP_SR_ACMPO0_Msk   (1ul << ACMP_SR_ACMPO0_Pos)         /*!< ACMP_T::SR: ACMPO0 Mask */
S
S#define ACMP_SR_ACMPF1_Pos   1                                   /*!< ACMP_T::SR: ACMPF1 Position */
S#define ACMP_SR_ACMPF1_Msk   (1ul << ACMP_SR_ACMPF1_Pos)         /*!< ACMP_T::SR: ACMPF1 Mask */
S
S#define ACMP_SR_ACMPF0_Pos   0                                   /*!< ACMP_T::SR: ACMPF0 Position */
S#define ACMP_SR_ACMPF0_Msk   (1ul << ACMP_SR_ACMPF0_Pos)         /*!< ACMP_T::SR: ACMPF0 Mask */
S
S/* ACMP_SR23 Bit Field Definitions */
S#define ACMP_SR_ACMPO3_Pos   3                                   /*!< ACMP_T::SR: ACMPO3 Position */
S#define ACMP_SR_ACMPO3_Msk   (1ul << ACMP_SR_ACMPO3_Pos)         /*!< ACMP_T::SR: ACMPO3 Mask */
S
S#define ACMP_SR_ACMPO2_Pos   2                                   /*!< ACMP_T::SR: ACMPO2 Position */
S#define ACMP_SR_ACMPO2_Msk   (1ul << ACMP_SR_ACMPO2_Pos)         /*!< ACMP_T::SR: ACMPO2 Mask */
S
S#define ACMP_SR_ACMPF3_Pos   1                                   /*!< ACMP_T::SR: ACMPF3 Position */
S#define ACMP_SR_ACMPF3_Msk   (1ul << ACMP_SR_ACMPF3_Pos)         /*!< ACMP_T::SR: ACMPF3 Mask */
S
S#define ACMP_SR_ACMPF2_Pos   0                                   /*!< ACMP_T::SR: ACMPF2 Position */
S#define ACMP_SR_ACMPF2_Msk   (1ul << ACMP_SR_ACMPF2_Pos)         /*!< ACMP_T::SR: ACMPF2 Mask */
S/**@}*/ /* ACMP_CONST */
S/**@}*/ /* ACMP */
S
S
S/*----------------------------- ADC Controller -------------------------------*/
S/** @addtogroup ADC Analog to Digital Converter(ADC)
S  Memory Mapped Structure for ADC Controller
S  @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var ADC_T::ADDR
S * Offset: 0x00-0x1C  A/D Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |RSLT      |A/D Conversion Result
S * |        |          |This field contains 12 bits conversion result.
S * |[16]    |OVERRUN   |Over Run Flag
S * |        |          |1 = Data in RSLT[11:0] is overwrite.
S * |        |          |0 = Data in RSLT[11:0] is recent conversion result.
S * |        |          |If converted data in RSLT[11:0] has not been read before new conversion result is
S * |        |          |loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after
S * |        |          |ADDR register is read.
S * |[17]    |VALID     |Valid Flag
S * |        |          |1 = Data in RSLT[11:0] bits is valid.
S * |        |          |0 = Data in RSLT[11:0] bits is not valid.
S * |        |          |This bit is set to 1 when corresponding channel analog input conversion is completed
S * |        |          |and cleared by hardware after ADDR register is read.
S * @var ADC_T::ADCR
S * Offset: 0x20  A/D Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ADEN      |A/D Converter Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |        |          |Before starting A/D conversion function, this bit should be set to 1. Clear it to 0 to
S * |        |          |disable A/D converter analog circuit for saving power consumption.
S * |[1]     |ADIE      |A/D Interrupt Enable
S * |        |          |1 = Enable A/D interrupt function
S * |        |          |0 = Disable A/D interrupt function
S * |        |          |A/D conversion end interrupt request is generated if ADIE bit is set to 1.
S * |[3:2]   |ADMD      |A/D Converter Operation Mode
S * |        |          |00 = Single conversion
S * |        |          |01 = Burst conversion
S * |        |          |10 = Single-cycle scan
S * |        |          |11 = Continuous scan
S * |        |          |When changing the operation mode, software should disable ADST bit firstly.
S * |        |          |Note: In Burst Mode, the A/D result data always at Data Register 0.
S * |[5:4]   |TRGS      |Hardware Trigger Source
S * |        |          |00 = A/D conversion is started by external STADC pin.
S * |        |          |Others = Reserved
S * |        |          |Software should disable TRGE and ADST before change TRGS.
S * |        |          |In hardware trigger mode, the ADST bit is set by the external trigger from STADC.
S * |[7:6]   |TRGCOND   |External Trigger Condition
S * |        |          |These two bits decide external pin STADC trigger event is level or edge. The signal
S * |        |          |must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and
S * |        |          |low state.
S * |        |          |00 = Low level
S * |        |          |01 = High level
S * |        |          |10 = Falling edge
S * |        |          |11 = Rising edge
S * |[8]     |TRGE      |External Trigger Enable
S * |        |          |Enable or disable triggering of A/D conversion by external STADC pin.
S * |        |          |1= Enable
S * |        |          |0= Disable
S * |[10]    |DIFFEN    |A/D Differential Input Mode Enable
S * |        |          |1 = A/D is in differential analog input mode
S * |        |          |0 = A/D is in single-end analog input mode
S * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus
S * |        |          |The Vplus of differential input paired channel 0 is from ADC0 pin; Vminus is from ADC1 pin.
S * |        |          |The Vplus of differential input paired channel 1 is from ADC2 pin; Vminus is from ADC3 pin.
S * |        |          |The Vplus of differential input paired channel 2 is from ADC4 pin; Vminus is from ADC5 pin.
S * |        |          |The Vplus of differential input paired channel 3 is from ADC6 pin; Vminus is from ADC7 pin.
S * |        |          |In differential input mode, only one of the two corresponding channels needs to be
S * |        |          |enabled in ADCHER. The conversion result will be placed to the corresponding data
S * |        |          |register of the enabled channel. If both channels of a differential input paired channel
S * |        |          |are enabled, the ADC will convert it twice in scan mode. And then write the conversion
S * |        |          |result to the two corresponding data registers.
S * |[11]    |ADST      |A/D Conversion Start
S * |        |          |1 = Conversion start.
S * |        |          |0 = Conversion stopped and A/D converter enter idle state.
S * |        |          |ADST bit can be controlled by two sources: software write and external pin STADC.
S * |        |          |ADST is cleared to 0 by hardware automatically at the ends of single mode and single-
S * |        |          |cycle scan mode on specified channels. In continuous scan mode, A/D conversion is
S * |        |          |continuously performed sequentially until this bit is cleared to 0 or chip reset.
S * @var ADC_T::ADCHER
S * Offset: 0x24  A/D Channel Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CHEN0     |Analog Input Channel 0 Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |        |          |This channel is the default enabled channel if CHEN0~7 are set as 0s.
S * |[1]     |CHEN1     |Analog Input Channel 1 Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |[2]     |CHEN2     |Analog Input Channel 2 Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |[3]     |CHEN3     |Analog Input Channel 3 Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |[4]     |CHEN4     |Analog Input Channel 4 Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |[5]     |CHEN5     |Analog Input Channel 5 Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |[6]     |CHEN6     |Analog Input Channel 6 Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |[7]     |CHEN7     |Analog Input Channel 7 Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |[9:8]   |PRESEL    |Analog Input Channel 7 select
S * |        |          |00: External analog input
S * |        |          |01: Internal bandgap voltage
S * |        |          |1x: Reserved
S * @var ADC_T::ADCMPR
S * Offset: 0x28,0x2C  A/D Compare Register 0 & 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CMPEN     |Compare Enable
S * |        |          |1 = Enable compare.
S * |        |          |0 = Disable compare.
S * |        |          |Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion
S * |        |          |result when converted data is loaded into ADDR register.
S * |[1]     |CMPIE     |Compare Interrupt Enable
S * |        |          |1 = Enable compare function interrupt.
S * |        |          |0 = Disable compare function interrupt.
S * |        |          |If the compare function is enabled and the compare condition matches the settings
S * |        |          |of CMPCOND and CMPMATCNT, CMPF0 bit will be asserted. If CMPIE is set to
S * |        |          |1, a compare interrupt request is generated.
S * |[2]     |CMPCOND   |Compare Condition
S * |        |          |1= Set the compare condition as that when a 12-bit A/D conversion result is
S * |        |          |greater or equal to the 12-bit CMPD(ADCMPR0[27:16]), the internal match
S * |        |          |counter will increase one.
S * |        |          |0= Set the compare condition as that when a 12-bit A/D conversion result is less
S * |        |          |than the 12-bit CMPD(ADCMPR0[27:16]), the internal match counter will
S * |        |          |increase one.
S * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT +1), the
S * |        |          |CMPF0 bit will be set.
S * |[5:3]   |CMPCH     |Compare Channel Selection
S * |        |          |000 = Channel 0 conversion result is selected to be compared.
S * |        |          |001 = Channel 1 conversion result is selected to be compared.
S * |        |          |010 = Channel 2 conversion result is selected to be compared.
S * |        |          |011 = Channel 3 conversion result is selected to be compared.
S * |        |          |100 = Channel 4 conversion result is selected to be compared.
S * |        |          |101 = Channel 5 conversion result is selected to be compared.
S * |        |          |110 = Channel 6 conversion result is selected to be compared.
S * |        |          |111 = Channel 7 conversion result is selected to be compared.
S * |[11:8]  |CMPMATCNT |Compare Match Count
S * |        |          |When the specified A/D channel analog conversion result matches the compare
S * |        |          |condition defined by CMPCOND[2], the internal match counter will increase 1.
S * |        |          |When the internal counter reaches the value to (CMPMATCNT +1), the CMPF0 bit
S * |        |          |will be set.
S * |[27:16] |CMPD      |Comparison Data
S * |        |          |The 12 bits data is used to compare with conversion result of specified channel.
S * |        |          |Software can use it to monitor the external analog input pin voltage transition in
S * |        |          |scan mode without imposing a load on software.
S * @var ADC_T::ADSR
S * Offset: 0x30  ADC Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ADF       |A/D Conversion End Flag
S * |        |          |A status flag that indicates the end of A/D conversion.
S * |        |          |ADF is set to 1 at these two conditions:
S * |        |          |1.  When A/D conversion ends in single mode
S * |        |          |2.  When A/D conversion ends on all specified channels in scan mode.
S * |        |          |3.  When more than 4 samples in FIFO in Burst mode.
S * |        |          |This bit can be cleared by writing 1 to itself.
S * |[1]     |CMPF0     |Compare Flag
S * |        |          |When the selected channel A/D conversion result meets the setting conditions of
S * |        |          |ADCMPR0 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
S * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting
S * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting
S * |[2]     |CMPF1     |Compare Flag
S * |        |          |When the selected channel A/D conversion result meets the setting conditions of
S * |        |          |ADCMPR1 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
S * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting
S * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting
S * |[3]     |BUSY      |BUSY/IDLE
S * |        |          |1 = A/D converter is busy at conversion.
S * |        |          |0 = A/D converter is in idle state.
S * |        |          |This bit is mirror of as ADST bit in ADCR.
S * |        |          |It is read only.
S * |[6:4]   |CHANNEL   |Current Conversion Channel
S * |        |          |This filed reflects current conversion channel when BUSY=1. When BUSY=0, it
S * |        |          |shows the next channel will be converted.
S * |        |          |It is read only.
S * |[15:8]  |VALID     |Data Valid flag
S * |        |          |It is a mirror of VALID bit in ADDRx
S * |        |          |When ADC is in Burst Mode, and there is at least one valid conversion result in buffer,
S * |        |          |VALID[7:0] will all set to 1.
S * |[23:16] |OVERRUN   |Over Run flag
S * |        |          |It is a mirror to OVERRUN bit in ADDRx
S * |        |          |When ADC is in Burst Mode, and the buffer is overrun, OVERRUN[7:0] will all set to
S * |        |          |1.
S * @var ADC_T::ADTDCR
S * Offset: 0x30  ADC Trigger Delay Control Register(M05xxDN/DE Only)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |PTDT      |PWM Trigger Delay Time
S * |        |          |Set this field will delay ADC start conversion time after PWM trigger.
S * |        |          |PWM trigger delay time is (4 * PTDT) * system clock 
S */
S
S    __I  uint32_t ADDR[8];       /* Offset: 0x00-0x1C  A/D Data Register                                             */
S    __IO uint32_t ADCR;          /* Offset: 0x20  A/D Control Register                                               */
S    __IO uint32_t ADCHER;        /* Offset: 0x24  A/D Channel Enable Register                                        */
S    __IO uint32_t ADCMPR[2];     /* Offset: 0x28,0x2C  A/D Compare Register 0 & 1                                    */
S    __IO uint32_t ADSR;          /* Offset: 0x30  ADC Status Register                                                */
S    __I  uint32_t RESERVED[4];
S    __IO uint32_t ADTDCR;        /* Offset: 0x44  ADC Trigger Delay Control Register(M05xxDN/DE Only)                */
S} ADC_T;
S
S
S
S
S/** @addtogroup ADC_CONST ADC Bit Field Definition
S  Constant Definitions for ADC Controller
S  @{
S */
S/* ADDR Bit Field Definitions */
S#define ADC_ADDR_VALID_Pos      17                                /*!< ADC_T::ADDR: VALID Position */
S#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC_T::ADDR: VALID Mask */
S
S#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC_T::ADDR: OVERRUN Position */
S#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC_T::ADDR: OVERRUN Mask */
S
S#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC_T::ADDR: RSLT Position */
S#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC_T::ADDR: RSLT Mask */
S
S/* ADCR Bit Field Definitions */
S#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC_T::ADCR: DMOF Position */
S#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC_T::ADCR: DMOF Mask */
S
S#define ADC_ADCR_ADST_Pos       11                                /*!< ADC_T::ADCR: ADST Position */
S#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC_T::ADCR: ADST Mask */
S
S#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC_T::ADCR: DIFFEN Position */
S#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC_T::ADCR: DIFFEN Mask */
S
S#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC_T::ADCR: TRGEN Position */
S#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC_T::ADCR: TRGEN Mask */
S
S#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC_T::ADCR: TRGCOND Position */
S#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC_T::ADCR: TRGCOND Mask */
S
S#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC_T::ADCR: TRGS Position */
S#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC_T::ADCR: TRGS Mask */
S
S#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC_T::ADCR: ADMD Position */
S#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC_T::ADCR: ADMD Mask */
S
S#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC_T::ADCR: ADIE Position */
S#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC_T::ADCR: ADIE Mask */
S
S#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC_T::ADCR: ADEN Position */
S#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC_T::ADCR: ADEN Mask */
S
S/* ADCHER Bit Field Definitions */
S#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC_T::ADCHER: PRESEL Position */
S#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC_T::ADCHER: PRESEL Mask */
S
S#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC_T::ADCHER: CHEN Position */
S#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC_T::ADCHER: CHEN Mask */
S
S/* ADCMPR Bit Field Definitions */
S#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC_T::ADCMPR: CMPD Position */
S#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC_T::ADCMPR: CMPD Mask */
S
S#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC_T::ADCMPR: CMPMATCNT Position */
S#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC_T::ADCMPR: CMPMATCNT Mask */
S
S#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC_T::ADCMPR: CMPCH Position */
S#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC_T::ADCMPR: CMPCH Mask */
S
S#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC_T::ADCMPR: CMPCOND Position */
S#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC_T::ADCMPR: CMPCOND Mask */
S
S#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC_T::ADCMPR: CMPIE Position */
S#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC_T::ADCMPR: CMPIE Mask */
S
S#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC_T::ADCMPR: CMPEN Position */
S#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC_T::ADCMPR: CMPEN Mask */
S
S/* ADSR Bit Field Definitions */
S#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC_T::ADSR: OVERRUN Position */
S#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC_T::ADSR: OVERRUN Mask */
S
S#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC_T::ADSR: VALID Position */
S#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC_T::ADSR: VALID Mask */
S
S#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC_T::ADSR: CHANNEL Position */
S#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC_T::ADSR: CHANNEL Mask */
S
S#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC_T::ADSR: BUSY Position */
S#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC_T::ADSR: BUSY Mask */
S
S#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC_T::ADSR: CMPF1 Position */
S#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC_T::ADSR: CMPF1 Mask */
S
S#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC_T::ADSR: CMPF0 Position */
S#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC_T::ADSR: CMPF0 Mask */
S
S#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC_T::ADSR: ADF Position */
S#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC_T::ADSR: ADF Mask */
S
S/* ADTDCR Bit Field Definitions */
S#define ADC_ADTDCR_PTDT_Pos        0                                     /*!< ADC_T::ADTDCR: PTDT Position */
S#define ADC_ADTDCR_PTDT_Msk        (0xFFul << ADC_ADTDCR_PTDT_Pos)       /*!< ADC_T::ADTDCR: PTDT Mask */
S/**@}*/ /* ADC_CONST */
S/**@}*/ /* ADC */
S
S
S/*---------------------------- Clock Controller ------------------------------*/
S
S/** @addtogroup CLK System Clock Controller(CLK)
S  Memory Mapped Structure for System Clock Controller
S  @{
S */
S
S
Stypedef struct
S{
S
S
S/**
S * @var CLK_T::PWRCON
S * Offset: 0x00  System Power Down Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field       |Descriptions
S * | :----: | :----:     | :---- |
S * |[0]     |XTL12M_EN   |External 4~24 MHz High Speed Crystal Enable (HXT) Control (Write Protect)
S * |        |            |The bit default value is set by flash controller user configuration register CFOSC (CONFIG0[26:24]).
S * |        |            |When the default clock source is from external 4~24 MHz high speed crystal, this bit is set to 1 automatically.
S * |        |            |0 = External 4~24 MHz high speed crystal oscillator (HXT) Disabled.
S * |        |            |1 = External 4~24 MHz high speed crystal oscillator (HXT) Enabled.
S * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register.    
S * |[2]     |OSC22M_EN   |Internal 22.1184 MHz High Speed Oscillator (HIRC) Enable Control (Write Protect)
S * |        |            |0 = Internal 22.1184 MHz high speed oscillator (HIRC) Disabled.
S * |        |            |1 = Internal 22.1184 MHz high speed oscillator (HIRC) Enabled.
S * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register. 
S * |[3]     |OSC10K_EN   |Internal 10 KHz Low Speed Oscillator (LIRC) Enable Control (Write Protect)
S * |        |            |0 = Internal 10 kHz low speed oscillator (LIRC) Disabled.
S * |        |            |1 = Internal 10 kHz low speed oscillator (LIRC) Enabled.
S * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[4]     |PD_WU_DLY   |Wake-up Delay Counter Enable Control (Write Protect)
S * |        |            |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
S * |        |            |The delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high speed crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high speed oscillator.
S * |        |            |0 = Clock cycles delay Disabled.
S * |        |            |1 = Clock cycles delay Enabled.
S * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[5]     |PD_WU_INT_EN|Power-Down Mode Wake-Up Interrupt Enable Control (Write Protect)
S * |        |            |0 = Power-down mode wake-up interrupt Disabled.
S * |        |            |1 = Power-down mode wake-up interrupt Enabled.
S * |        |            |Note1: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.
S * |        |            |Note2: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[6]     |PD_WU_STS   |Power-Down Mode Wake-Up Interrupt Status
S * |        |            |Set by "Power-down wake-up event", it indicates that resume from Power-down mode.
S * |        |            |The flag is set if the GPIO, UART, WDT, ACMP or BOD wake-up occurred.
S * |        |            |Write 1 to clear the bit to 0.
S * |        |            |Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1. 
S * |[7]     |PWR_DOWN_EN|System Power-Down Enable Bit (Write Protect)
S * |        |            |When this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depends on the PD_WAIT_CPU bit
S * |        |            |(a) If the PD_WAIT_CPU is 0, then the chip enters Power-down mode immediately after the PWR_DOWN_EN bit set.
S * |        |            |(b) if the PD_WAIT_CPU is 1, then the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode (recommend)
S * |        |            |When chip wakes up from Power-down mode, this bit is cleared by hardware.
S * |        |            |User needs to set this bit again for next Power-down.
S * |        |            |In Power-down mode, external 4~24 MHz high speed crystal oscillator and the internal 22.1184 MHz high speed oscillator will be disabled in this mode, but the internal 10 kHz low speed oscillator are not controlled by Power-down mode.
S * |        |            |In Power- down mode, the PLL and system clock are disabled, and ignored the clock source selection.
S * |        |            |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from the internal 10 kHz low speed oscillator.
S * |        |            |0 = Chip operating normally or chip in Idle mode because of WFI command.
S * |        |            |1 = Chip enters Power-down mode instantly or waits CPU sleep command WFI.
S * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[8]     |PD_WAIT_CPU |Power-down Entry Condition Control (Write Protect)
S * |        |            |0 = Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1.
S * |        |            |1 = Chip enters Power- down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1 and CPU run WFI instruction.
S * |        |            |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * @var CLK_T::AHBCLK
S * Offset: 0x04  AHB Devices Clock Enable Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control
S * |        |          |0 = Flash ISP peripheral clock Disabled.
S * |        |          |1 = Flash ISP peripheral clock Enabled.
S * |[3]     |EBI_EN    |EBI Controller Clock Enable Control
S * |        |          |0 = EBI peripherial clock Disabled.
S * |        |          |1 = EBI peripherial clock Enabled.
S * |[4]     |HDIV_EN   |Divider Controller Clock Enable Control 
S * |        |          |0 = Divider controller peripherial clock Disabled.
S * |        |          |1 = Divider controller peripherial clock Enabled.
S * @var CLK_T::APBCLK
S * Offset: 0x08  APB Devices Clock Enable Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WDT_EN    |Watchdog Timer Clock Enable Control (Write Protect)
S * |        |          |0 = Watchdog Timer clock Disabled.
S * |        |          |1 = Watchdog Timer clock Enabled.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
S * |        |          |0 = Timer0 clock Disabled.
S * |        |          |1 = Timer0 clock Enabled.
S * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
S * |        |          |0 = Timer1 clock Disabled.
S * |        |          |1 = Timer1 clock Enabled.
S * |[4]     |TMR2_EN   |Timer2 Clock Enable Control
S * |        |          |0 = Timer2 clock Disabled.
S * |        |          |1 = Timer2 clock Enabled.
S * |[5]     |TMR3_EN   |Timer3 Clock Enable Control
S * |        |          |0 = Timer3 clock Disabled.
S * |        |          |1 = Timer3 clock Enabled.
S * |[6]     |FDIV_EN   |Frequency Divider Output Clock Enable Control
S * |        |          |0 = FDIV clock Disabled.
S * |        |          |1 = FDIV clock Enabled.
S * |[8]     |I2C0_EN   |I2C0 Clock Enable Control
S * |        |          |0 = I2C0 clock Disabled.
S * |        |          |1 = I2C0 clock Enabled.
S * |[8]     |I2C1_EN   |I2C1 Clock Enable Control
S * |        |          |0 = I2C1 clock Disabled.
S * |        |          |1 = I2C1 clock Enabled. 
S * |[12]    |SPI0_EN   |SPI0 Clock Enable Control
S * |        |          |0 = SPI0 clock Disabled.
S * |        |          |1 = SPI0 clock Enabled.
S * |[13]    |SPI1_EN   |SPI1 Clock Enable Control
S * |        |          |0 = SPI1 clock Disabled.
S * |        |          |1 = SPI1 clock Enabled.
S * |[16]    |UART0_EN  |UART0 Clock Enable Control
S * |        |          |0 = UART0 clock Disabled.
S * |        |          |1 = UART0 clock Enabled.
S * |[17]    |UART1_EN  |UART1 Clock Enable Control
S * |        |          |0 = UART1 clock Disabled.
S * |        |          |1 = UART1 clock Enabled.
S * |[20]    |PWM01_EN  |PWM_01 Clock Enable Control
S * |        |          |0 = PWM01 clock Disabled.
S * |        |          |1 = PWM01 clock Enabled.
S * |[21]    |PWM23_EN  |PWM_23 Clock Enable Control
S * |        |          |0 = PWM23 clock Disabled.
S * |        |          |1 = PWM23 clock Enabled.
S * |[22]    |PWM45_EN  |PWM_45 Clock Enable Control
S * |        |          |0 = PWM45 clock Disabled.
S * |        |          |1 = PWM45 clock Enabled.
S * |[23]    |PWM67_EN  |PWM_67 Clock Enable Control
S * |        |          |0 = PWM67 clock Disabled.
S * |        |          |1 = PWM67 clock Enabled.
S * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control
S * |        |          |0 = ADC clock Disabled.
S * |        |          |1 = ADC clock Enabled.
S * |[30]    |ACMP01_EN |Analog Comparator 0/1 Clock Enable Control
S * |        |          |0 = Analog Comparator 0/1 clock Disabled.
S * |        |          |1 = Analog Comparator 0/1 clock Enabled. 
S * |[31]    |ACMP23_EN |Analog Comparator 2/3 Clock Enable Control
S * |        |          |0 = Analog Comparator 2/3 clock Disabled.
S * |        |          |1 = Analog Comparator 2/3 clock Enabled.
S * @var CLK_T::CLKSTATUS
S * Offset: 0x0C  Clock Status Monitor Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field      |Descriptions
S * | :----: | :----:    | :---- |
S * |[0]     |XTL12M_STB|External 4~24 MHz High Speed Crystal (HXT) Clock Source Stable Flag (Read Only)
S * |        |           |0 = External 4~24 MHz high speed crystal clock (HXT) is not stable or disabled.
S * |        |           |1 = External 4~24 MHz high speed crystal clock (HXT) is stable.
S * |[2]     |PLL_STB    |Internal PLL Clock Source Stable Flag (Read Only)
S * |        |           |0 = Internal PLL clock is not stable or disabled.
S * |        |           |1 = Internal PLL clock is stable.
S * |[3]     |OSC10K_STB|Internal 10 KHz Low Speed Oscillator (LIRC) Clock Source Stable Flag (Read Only)
S * |        |           |0 = Internal 10 kHz low speed oscillator clock (LIRC) is not stable or disabled.
S * |        |           |1 = Internal 10 kHz low speed oscillator clock (LIRC) is stable.
S * |[4]     |OSC22M_STB|Internal 22.1184 MHz High Speed Oscillator (HIRC) Clock Source Stable Flag (Read Only)
S * |        |           |0 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is not stable or disabled.
S * |        |           |1 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is stable.
S * |[7]     |CLK_SW_FAIL|Clock switch fail flag
S * |        |           |0 = Clock switching success.
S * |        |           |1 = Clock switching failure. 
S * |        |           |Note1: 
S * |        |           |This bit is updated when software switches system clock source. 
S * |        |           |If switch target clock is stable, this bit will be set to 0. 
S * |        |           |If switch target clock is not stable, this bit will be set to 1.
S * |        |           |Note2: On M05xxBN, software can write 1 to clear the bit to 0.
S * |        |           |Note3: 
S * |        |           |On M05xxDN/DE, this bit is read only. 
S * |        |           |After selected clock source is stable, hardware will switch system clock to selected clock automatically, and CLK_SW_FAIL will be cleared automatically by hardware. 
S * @var CLK_T::CLKSEL0
S * Offset: 0x10  Clock Source Select Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |HCLK_S    |HCLK Clock Source Selection (Write Protect)
S * |        |          |000 = Clock source is from HXT.
S * |        |          |010 = Clock source is from PLL.
S * |        |          |011 = Clock source is from LIRC.
S * |        |          |111 = Clock source is from HIRC.
S * |        |          |Others = Reserved.
S * |        |          |Note1: Before clock switching, the related clock sources (both pre-select and new-select) must be turn-on and stable.
S * |        |          |Note2: The 3-bit default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset. Therefore the default value is either 000b or 111b.
S * |        |          |Note3: These bits are write protected bit. Refer to the REGWRPROT register.
S * |[5:3]   |STCLK_S   |Cortex-M0 SysTick Clock Source Selection from Reference Clock (Write Protect)
S * |        |          |If SYST_CSR[2] = 1, SysTick clock source is from HCLK.
S * |        |          |If SYST_CSR[2] = 0, SysTick clock source is defined by below settings.
S * |        |          |000 = Clock source is from HXT.
S * |        |          |010 = Clock source is from HXT/2
S * |        |          |011 = Clock source is from HCLK/2.
S * |        |          |111 = Clock source is from HIRC/2.
S * |        |          |Others = Reserved.
S * |        |          |Note1: This bit is write protected bit. Refer to the REGWRPROT register.
S * |        |          |Note2: If the SysTick clock source is not from HCLK (i.e. SYST_CSR[2] = 0), SysTick clock source must less than or equal to HCLK/2.
S * @var CLK_T::CLKSEL1
S * Offset: 0x14  Clock Source Select Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |WDT_S     |Watchdog Timer Clock Source Selection (Write Protect)
S * |        |          |10 = Clock source is from HCLK/2048 clock.
S * |        |          |11 = Clock source is from LIRC.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register. 
S * |[3:2]   |ADC_S     |ADC Peripheral Clock Source Selection
S * |        |          |00 = Clock source is from HXT.
S * |        |          |01 = Clock source is from PLL.
S * |        |          |10 = Clock source is from HCLK.
S * |        |          |11 = Clock source is from HIRC.
S * |[4]     |SPI0_S    |SPI0 clock Source Selection
S * |        |          |0 = Clock source is from PLL.
S * |        |          |1 = Clock source is from HCLK.
S * |[5]     |SPI1_S    |SPI1 clock Source Selection
S * |        |          |0 = Clock source is from PLL.
S * |        |          |1 = Clock source is from HCLK. 
S * |[10:8]  |TMR0_S    |TIMER0 Clock Source Selection
S * |        |          |000 = Clock source is from HXT.
S * |        |          |010 = Clock source is from HCLK.
S * |        |          |011 = Clock source is from external trigger T0.
S * |        |          |101 = Clock source is from LIRC.
S * |        |          |111 = Clock source is from HIRC.
S * |[14:12] |TMR1_S    |TIMER1 Clock Source Selection
S * |        |          |000 = Clock source is from HXT.
S * |        |          |010 = Clock source is from HCLK.
S * |        |          |011 = Clock source is from external trigger T1.
S * |        |          |101 = Clock source is from LIRC.
S * |        |          |111 = Clock source is from HIRC.
S * |[18:16] |TMR2_S    |TIMER2 Clock Source Selection
S * |        |          |000 = Clock source is from HXT.
S * |        |          |010 = Clock source is from HCLK.
S * |        |          |011 = Clock source is from external trigger T2.
S * |        |          |101 = Clock source is from LIRC.
S * |        |          |111 = Clock source is from HIRC.
S * |[22:20] |TMR3_S    |TIMER3 Clock Source Selection
S * |        |          |000 = Clock source is from HXT.
S * |        |          |010 = Clock source is from HCLK.
S * |        |          |011 = Clock source is from external trigger T3.
S * |        |          |101 = Clock source is from LIRC.
S * |        |          |111 = Clock source is from HIRC.
S * |[25:24] |UART_S    |UART Clock Source Selection
S * |        |          |00 = Clock source is from HXT.
S * |        |          |01 = Clock source is from PLL.
S * |        |          |11 = Clock source is from HIRC.
S * |[29:28] |PWM01_S   |PWM0 and PWM1 Clock Source Selection
S * |        |          |PWM0 and PWM1 use the same clock source; both of them use the same prescaler.
S * |        |          |00 = Clock source is from HXT.
S * |        |          |01 = Clock source is from LIRC.
S * |        |          |10 = Clock source is from HCLK.
S * |        |          |11 = Clock source is from HIRC.
S * |[31:30] |PWM23_S   |PWM2 and PWM3 Clock Source Selection
S * |        |          |PWM2 and PWM3 use the same clock source; both of them use the same prescaler.
S * |        |          |00 = Clock source is from HXT.
S * |        |          |01 = Clock source is from LIRC.
S * |        |          |10 = Clock source is from HCLK.
S * |        |          |11 = Clock source is from HIRC.
S * @var CLK_T::CLKDIV
S * Offset: 0x18  Clock Divider Number Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |HCLK_N    |HCLK Clock Divide Number from HCLK Clock Source
S * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1).
S * |[11:8]  |UART_N    |UART Clock Divide Number from UART Clock Source
S * |        |          |UART clock frequency = (UART clock source frequency ) / (UART_N + 1).
S * |[23:16] |ADC_N     |ADC peripheral Clock Divide Number from ADC peripheral Clock Source
S * |        |          |ADC peripheral clock frequency = (ADC peripheral clock source frequency ) / (ADC_N + 1).
S * @var CLK_T::CLKSEL2
S * Offset: 0x1C  Clock Source Select Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Select
S * |        |          |00 = clock source from HXT.
S * |        |          |10 = clock source from LIRC. 
S * |        |          |10 = clock source from HCLK.
S * |        |          |11 = clock source from HIRC.
S * |[5:4]   |PWM45_S   |PWM4 and PWM5 Clock Source Selection
S * |        |          |PWM4 and PWM5 use the same clock source; both of them use the same prescaler.
S * |        |          |00 = Clock source is from HXT.
S * |        |          |01 = Clock source is from LIRC.
S * |        |          |10 = Clock source is from HCLK.
S * |        |          |11 = Clock source is from HIRC.
S * |[7:6]   |PWM67_S   |PWM6 and PWM7 Clock Source Selection
S * |        |          |PWM6 and PWM7 use the same clock source; both of them use the same prescaler.
S * |        |          |00 = Clock source is from HXT.
S * |        |          |01 = Clock source is from LIRC.
S * |        |          |10 = Clock source is from HCLK.
S * |        |          |11 = Clock source is from HIRC.
S * |[17:16] |WWDT_S    |Window Watchdog Timer Clock Source Selection
S * |        |          |10 = Clock source is from HCLK/2048 clock.
S * |        |          |11 = Clock source is from LIRC. 
S * @var CLK_T::PLLCON
S * Offset: 0x20  PLL Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:0]   |FB_DV     |PLL Feedback Divider Control Bits
S * |        |          |Refer to the formulas below the table.
S * |[13:9]  |IN_DV     |PLL Input Divider Control Bits
S * |        |          |Refer to the formulas below the table.
S * |[15:14] |OUT_DV    |PLL Output Divider Control Bits
S * |        |          |Refer to the formulas below the table.
S * |[16]    |PD        |Power-Down Mode
S * |        |          |If the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode too.
S * |        |          |0 = PLL is in Normal mode.
S * |        |          |1 = PLL is in Power-down mode (default).
S * |[17]    |BP        |PLL Bypass Control
S * |        |          |0 = PLL is in Normal mode (default).
S * |        |          |1 = PLL clock output is same as PLL source clock input.
S * |[18]    |OE        |PLL OE (FOUT Enable)Control
S * |        |          |0 = PLL FOUT Enabled.
S * |        |          |1 = PLL FOUT is fixed low.
S * |[19]    |PLL_SRC   |PLL Source Clock Selection
S * |        |          |0 = PLL source clock from HXT.
S * |        |          |1 = PLL source clock from HIRC.
S * @var CLK_T::FRQDIV
S * Offset: 0x24  Frequency Divider Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
S * |        |          |The formula of output frequency is Fout = Fin/2(N+1).
S * |        |          |Fin is the input clock frequency.
S * |        |          |Fout is the frequency of divider output clock.
S * |        |          |N is the 4-bit value of FSEL[3:0].
S * |[4]     |DIVIDER_EN|Frequency Divider Enable Bit
S * |        |          |0 = Frequency Divider function Disabled.
S * |        |          |1 = Frequency Divider function Enabled.
S * |[5]     |DIVIDER1  |Frequency Divider One Enable Bit
S * |        |          |0 = Divider output frequency is depended on FSEL value.
S * |        |          |1 = Divider output frequency is the same as input clock frequency.
S */
S
S    __IO uint32_t PWRCON;        /* Offset: 0x00  System Power Down Control Register                                 */
S    __IO uint32_t AHBCLK;        /* Offset: 0x04  AHB Devices Clock Enable Control Register                          */
S    __IO uint32_t APBCLK;        /* Offset: 0x08  APB Devices Clock Enable Control Register                          */
S    __IO uint32_t CLKSTATUS;     /* Offset: 0x0C  Clock Status Monitor Register                                      */
S    __IO uint32_t CLKSEL0;       /* Offset: 0x10  Clock Source Select Control Register 0                             */
S    __IO uint32_t CLKSEL1;       /* Offset: 0x14  Clock Source Select Control Register 1                             */
S    __IO uint32_t CLKDIV;        /* Offset: 0x18  Clock Divider Number Register                                      */
S    __IO uint32_t CLKSEL2;       /* Offset: 0x1C  Clock Source Select Control Register 2                             */
S    __IO uint32_t PLLCON;        /* Offset: 0x20  PLL Control Register                                               */
S    __IO uint32_t FRQDIV;        /* Offset: 0x24  Frequency Divider Control Register                                 */
S
S} CLK_T;
S
S
S
S/** @addtogroup CLK_CONST CLK Bit Field Definition
S  Constant Definitions for CLK Controller
S  @{
S */
S
S/* CLK PWRCON Bit Field Definitions */
S#define CLK_PWRCON_PD_WAIT_CPU_Pos           8                                    /*!< CLK_T::PWRCON: PD_WAIT_CPU Position */
S#define CLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << CLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< CLK_T::PWRCON: PD_WAIT_CPU Mask */
S
S#define CLK_PWRCON_PWR_DOWN_EN_Pos           7                                    /*!< CLK_T::PWRCON: PWR_DOWN_EN Position */
S#define CLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << CLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< CLK_T::PWRCON: PWR_DOWN_EN Mask */
S
S#define CLK_PWRCON_PD_WU_STS_Pos             6                                    /*!< CLK_T::PWRCON: PD_WU_STS Position */
S#define CLK_PWRCON_PD_WU_STS_Msk             (1ul << CLK_PWRCON_PD_WU_STS_Pos)    /*!< CLK_T::PWRCON: PD_WU_STS Mask */
S
S#define CLK_PWRCON_PD_WU_INT_EN_Pos          5                                    /*!< CLK_T::PWRCON: PD_WU_INT_EN Position */
S#define CLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << CLK_PWRCON_PD_WU_INT_EN_Pos) /*!< CLK_T::PWRCON: PD_WU_INT_EN Mask */
S
S#define CLK_PWRCON_PD_WU_DLY_Pos             4                                    /*!< CLK_T::PWRCON: PD_WU_DLY Position */
S#define CLK_PWRCON_PD_WU_DLY_Msk             (1ul << CLK_PWRCON_PD_WU_DLY_Pos)    /*!< CLK_T::PWRCON: PD_WU_DLY Mask */
S
S#define CLK_PWRCON_OSC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: OSC10K_EN Position */
S#define CLK_PWRCON_OSC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)    /*!< CLK_T::PWRCON: OSC10K_EN Mask */
S#define CLK_PWRCON_IRC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: OSC10K_EN Position */
S#define CLK_PWRCON_IRC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)    /*!< CLK_T::PWRCON: OSC10K_EN Mask */
S
S#define CLK_PWRCON_OSC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: OSC22M_EN Position */
S#define CLK_PWRCON_OSC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)    /*!< CLK_T::PWRCON: OSC22M_EN Mask */
S#define CLK_PWRCON_IRC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: OSC22M_EN Position */
S#define CLK_PWRCON_IRC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)    /*!< CLK_T::PWRCON: OSC22M_EN Mask */
S
S#define CLK_PWRCON_XTL12M_EN_Pos             0                                    /*!< CLK_T::PWRCON: XTL12M_EN Position */
S#define CLK_PWRCON_XTL12M_EN_Msk             (1ul << CLK_PWRCON_XTL12M_EN_Pos)    /*!< CLK_T::PWRCON: XTL12M_EN Mask */
S
S/* CLK AHBCLK Bit Field Definitions */
S#define CLK_AHBCLK_HDIV_EN_Pos               4                                    /*!< CLK_T::AHBCLK: HDIV_EN Position */
S#define CLK_AHBCLK_HDIV_EN_Msk               (1ul << CLK_AHBCLK_HDIV_EN_Pos)      /*!< CLK_T::AHBCLK: HDIV_EN Mask */
S
S#define CLK_AHBCLK_EBI_EN_Pos                3                                    /*!< CLK_T::AHBCLK: EBI_EN Position */
S#define CLK_AHBCLK_EBI_EN_Msk                (1ul << CLK_AHBCLK_EBI_EN_Pos)       /*!< CLK_T::AHBCLK: EBI_EN Mask */
S
S#define CLK_AHBCLK_ISP_EN_Pos                2                                    /*!< CLK_T::AHBCLK: ISP_EN Position */
S#define CLK_AHBCLK_ISP_EN_Msk                (1ul << CLK_AHBCLK_ISP_EN_Pos)       /*!< CLK_T::AHBCLK: ISP_EN Mask */
S
S/* CLK APBCLK Bit Field Definitions */
S#define CLK_APBCLK_ACMP23_EN_Pos             31                                   /*!< CLK_T::APBCLK: ACMP23_EN Position */
S#define CLK_APBCLK_ACMP23_EN_Msk             (1ul << CLK_APBCLK_ACMP23_EN_Pos)    /*!< CLK_T::APBCLK: ACMP23_EN Mask */
S
S#define CLK_APBCLK_ACMP01_EN_Pos             30                                   /*!< CLK_T::APBCLK: ACMP01_EN Position */
S#define CLK_APBCLK_ACMP01_EN_Msk             (1ul << CLK_APBCLK_ACMP01_EN_Pos)    /*!< CLK_T::APBCLK: ACMP01_EN Mask */
S
S#define CLK_APBCLK_ADC_EN_Pos                28                                   /*!< CLK_T::APBCLK: ADC_EN Position */
S#define CLK_APBCLK_ADC_EN_Msk                (1ul << CLK_APBCLK_ADC_EN_Pos)       /*!< CLK_T::APBCLK: ADC_EN Mask */
S
S#define CLK_APBCLK_PWM67_EN_Pos              23                                   /*!< CLK_T::APBCLK: PWM67_EN Position */
S#define CLK_APBCLK_PWM67_EN_Msk              (1ul << CLK_APBCLK_PWM67_EN_Pos)     /*!< CLK_T::APBCLK: PWM67_EN Mask */
S
S#define CLK_APBCLK_PWM45_EN_Pos              22                                   /*!< CLK_T::APBCLK: PWM45_EN Position */
S#define CLK_APBCLK_PWM45_EN_Msk              (1ul << CLK_APBCLK_PWM45_EN_Pos)     /*!< CLK_T::APBCLK: PWM45_EN Mask */
S
S#define CLK_APBCLK_PWM23_EN_Pos              21                                   /*!< CLK_T::APBCLK: PWM23_EN Position */
S#define CLK_APBCLK_PWM23_EN_Msk              (1ul << CLK_APBCLK_PWM23_EN_Pos)     /*!< CLK_T::APBCLK: PWM23_EN Mask */
S
S#define CLK_APBCLK_PWM01_EN_Pos              20                                   /*!< CLK_T::APBCLK: PWM01_EN Position */
S#define CLK_APBCLK_PWM01_EN_Msk              (1ul << CLK_APBCLK_PWM01_EN_Pos)     /*!< CLK_T::APBCLK: PWM01_EN Mask */
S
S#define CLK_APBCLK_UART1_EN_Pos              17                                   /*!< CLK_T::APBCLK: UART1_EN Position */
S#define CLK_APBCLK_UART1_EN_Msk              (1ul << CLK_APBCLK_UART1_EN_Pos)     /*!< CLK_T::APBCLK: UART1_EN Mask */
S
S#define CLK_APBCLK_UART0_EN_Pos              16                                   /*!< CLK_T::APBCLK: UART0_EN Position */
S#define CLK_APBCLK_UART0_EN_Msk              (1ul << CLK_APBCLK_UART0_EN_Pos)     /*!< CLK_T::APBCLK: UART0_EN Mask */
S
S#define CLK_APBCLK_SPI1_EN_Pos               13                                   /*!< CLK_T::APBCLK: SPI1_EN Position */
S#define CLK_APBCLK_SPI1_EN_Msk               (1ul << CLK_APBCLK_SPI1_EN_Pos)      /*!< CLK_T::APBCLK: SPI1_EN Mask */
S
S#define CLK_APBCLK_SPI0_EN_Pos               12                                   /*!< CLK_T::APBCLK: SPI0_EN Position */
S#define CLK_APBCLK_SPI0_EN_Msk               (1ul << CLK_APBCLK_SPI0_EN_Pos)      /*!< CLK_T::APBCLK: SPI0_EN Mask */
S
S#define CLK_APBCLK_I2C1_EN_Pos               9                                    /*!< CLK_T::APBCLK: I2C1_EN Position */
S#define CLK_APBCLK_I2C1_EN_Msk               (1ul << CLK_APBCLK_I2C1_EN_Pos)      /*!< CLK_T::APBCLK: I2C1_EN Mask */
S
S#define CLK_APBCLK_I2C0_EN_Pos               8                                    /*!< CLK_T::APBCLK: I2C0_EN Position */
S#define CLK_APBCLK_I2C0_EN_Msk               (1ul << CLK_APBCLK_I2C0_EN_Pos)      /*!< CLK_T::APBCLK: I2C0_EN Mask */
S#define CLK_APBCLK_I2C_EN_Pos                8                                    /*!< CLK_T::APBCLK: I2C_EN Position */
S#define CLK_APBCLK_I2C_EN_Msk                (1ul << CLK_APBCLK_I2C_EN_Pos)       /*!< CLK_T::APBCLK: I2C_EN Mask */
S
S#define CLK_APBCLK_FDIV_EN_Pos               6                                    /*!< CLK_T::APBCLK: FDIV_EN Position */
S#define CLK_APBCLK_FDIV_EN_Msk               (1ul << CLK_APBCLK_FDIV_EN_Pos)      /*!< CLK_T::APBCLK: FDIV_EN Mask */
S
S#define CLK_APBCLK_TMR3_EN_Pos               5                                    /*!< CLK_T::APBCLK: TMR3_EN Position */
S#define CLK_APBCLK_TMR3_EN_Msk               (1ul << CLK_APBCLK_TMR3_EN_Pos)      /*!< CLK_T::APBCLK: TMR3_EN Mask */
S
S#define CLK_APBCLK_TMR2_EN_Pos               4                                    /*!< CLK_T::APBCLK: TMR2_EN Position */
S#define CLK_APBCLK_TMR2_EN_Msk               (1ul << CLK_APBCLK_TMR2_EN_Pos)      /*!< CLK_T::APBCLK: TMR2_EN Mask */
S
S#define CLK_APBCLK_TMR1_EN_Pos               3                                    /*!< CLK_T::APBCLK: TMR1_EN Position */
S#define CLK_APBCLK_TMR1_EN_Msk               (1ul << CLK_APBCLK_TMR1_EN_Pos)      /*!< CLK_T::APBCLK: TMR1_EN Mask */
S
S#define CLK_APBCLK_TMR0_EN_Pos               2                                    /*!< CLK_T::APBCLK: TMR0_EN Position */
S#define CLK_APBCLK_TMR0_EN_Msk               (1ul << CLK_APBCLK_TMR0_EN_Pos)      /*!< CLK_T::APBCLK: TMR0_EN Mask */
S
S#define CLK_APBCLK_WDT_EN_Pos                0                                    /*!< CLK_T::APBCLK: WDT_EN Position */
S#define CLK_APBCLK_WDT_EN_Msk                (1ul << CLK_APBCLK_WDT_EN_Pos)       /*!< CLK_T::APBCLK: WDT_EN Mask */
S
S/* CLK CLKSTATUS Bit Field Definitions */
S#define CLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                     /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Position */
S#define CLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << CLK_CLKSTATUS_CLK_SW_FAIL_Pos)/*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Mask */
S
S#define CLK_CLKSTATUS_OSC22M_STB_Pos         4                                    /*!< CLK_T::CLKSTATUS: OSC22M_STB Position */
S#define CLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)/*!< CLK_T::CLKSTATUS: OSC22M_STB Mask */
S#define CLK_CLKSTATUS_IRC22M_STB_Pos         4                                    /*!< CLK_T::CLKSTATUS: IRC22M_STB Position */
S#define CLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << CLK_CLKSTATUS_IRC22M_STB_Pos)/*!< CLK_T::CLKSTATUS: IRC22M_STB Mask */
S
S#define CLK_CLKSTATUS_OSC10K_STB_Pos         3                                    /*!< CLK_T::CLKSTATUS: OSC10K_STB Position */
S#define CLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)/*!< CLK_T::CLKSTATUS: OSC10K_STB Mask */
S#define CLK_CLKSTATUS_IRC10K_STB_Pos         3                                    /*!< CLK_T::CLKSTATUS: IRC10K_STB Position */
S#define CLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << CLK_CLKSTATUS_IRC10K_STB_Pos)/*!< CLK_T::CLKSTATUS: IRC10K_STB Mask */
S
S#define CLK_CLKSTATUS_PLL_STB_Pos            2                                    /*!< CLK_T::CLKSTATUS: PLL_STB Position */
S#define CLK_CLKSTATUS_PLL_STB_Msk            (1ul << CLK_CLKSTATUS_PLL_STB_Pos)   /*!< CLK_T::CLKSTATUS: PLL_STB Mask */
S
S#define CLK_CLKSTATUS_XTL12M_STB_Pos         0                                    /*!< CLK_T::CLKSTATUS: XTL12M_STB Position */
S#define CLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << CLK_CLKSTATUS_XTL12M_STB_Pos)/*!< CLK_T::CLKSTATUS: XTL12M_STB Mask */
S
S/* CLK CLKSEL0 Bit Field Definitions */
S#define CLK_CLKSEL0_STCLK_S_Pos              3                                    /*!< CLK_T::CLKSEL0: STCLK_S Position */
S#define CLK_CLKSEL0_STCLK_S_Msk              (7ul << CLK_CLKSEL0_STCLK_S_Pos)     /*!< CLK_T::CLKSEL0: STCLK_S Mask */
S
S#define CLK_CLKSEL0_HCLK_S_Pos               0                                    /*!< CLK_T::CLKSEL0: HCLK_S Position */
S#define CLK_CLKSEL0_HCLK_S_Msk               (7ul << CLK_CLKSEL0_HCLK_S_Pos)      /*!< CLK_T::CLKSEL0: HCLK_S Mask */
S
S/* CLK CLKSEL1 Bit Field Definitions */
S#define CLK_CLKSEL1_PWM23_S_Pos              30                                   /*!< CLK_T::CLKSEL1: PWM23_S Position */
S#define CLK_CLKSEL1_PWM23_S_Msk              (3ul << CLK_CLKSEL1_PWM23_S_Pos)     /*!< CLK_T::CLKSEL1: PWM23_S Mask */
S
S#define CLK_CLKSEL1_PWM01_S_Pos              28                                   /*!< CLK_T::CLKSEL1: PWM01_S Position */
S#define CLK_CLKSEL1_PWM01_S_Msk              (3ul << CLK_CLKSEL1_PWM01_S_Pos)     /*!< CLK_T::CLKSEL1: PWM01_S Mask */
S
S#define CLK_CLKSEL1_UART_S_Pos               24                                   /*!< CLK_T::CLKSEL1: UART_S Position */
S#define CLK_CLKSEL1_UART_S_Msk               (3ul << CLK_CLKSEL1_UART_S_Pos)      /*!< CLK_T::CLKSEL1: UART_S Mask */
S
S#define CLK_CLKSEL1_TMR3_S_Pos               20                                   /*!< CLK_T::CLKSEL1: TMR3_S Position */
S#define CLK_CLKSEL1_TMR3_S_Msk               (7ul << CLK_CLKSEL1_TMR3_S_Pos)      /*!< CLK_T::CLKSEL1: TMR3_S Mask */
S
S#define CLK_CLKSEL1_TMR2_S_Pos               16                                   /*!< CLK_T::CLKSEL1: TMR2_S Position */
S#define CLK_CLKSEL1_TMR2_S_Msk               (7ul << CLK_CLKSEL1_TMR2_S_Pos)      /*!< CLK_T::CLKSEL1: TMR2_S Mask */
S
S#define CLK_CLKSEL1_TMR1_S_Pos               12                                   /*!< CLK_T::CLKSEL1: TMR1_S Position */
S#define CLK_CLKSEL1_TMR1_S_Msk               (7ul << CLK_CLKSEL1_TMR1_S_Pos)      /*!< CLK_T::CLKSEL1: TMR1_S Mask */
S
S#define CLK_CLKSEL1_TMR0_S_Pos               8                                    /*!< CLK_T::CLKSEL1: TMR0_S Position */
S#define CLK_CLKSEL1_TMR0_S_Msk               (7ul << CLK_CLKSEL1_TMR0_S_Pos)      /*!< CLK_T::CLKSEL1: TMR0_S Mask */
S
S#define CLK_CLKSEL1_SPI1_S_Pos               5                                    /*!< CLK_T::CLKSEL1: SPI1_S Position */
S#define CLK_CLKSEL1_SPI1_S_Msk               (1ul << CLK_CLKSEL1_SPI1_S_Pos)      /*!< CLK_T::CLKSEL1: SPI1_S Mask */
S
S#define CLK_CLKSEL1_SPI0_S_Pos               4                                    /*!< CLK_T::CLKSEL1: SPI0_S Position */
S#define CLK_CLKSEL1_SPI0_S_Msk               (1ul << CLK_CLKSEL1_SPI0_S_Pos)      /*!< CLK_T::CLKSEL1: SPI0_S Mask */
S
S#define CLK_CLKSEL1_ADC_S_Pos                2                                    /*!< CLK_T::CLKSEL1: ADC_S Position */
S#define CLK_CLKSEL1_ADC_S_Msk                (3ul << CLK_CLKSEL1_ADC_S_Pos)       /*!< CLK_T::CLKSEL1: ADC_S Mask */
S
S#define CLK_CLKSEL1_WDT_S_Pos                0                                    /*!< CLK_T::CLKSEL1: WDT_S Position */
S#define CLK_CLKSEL1_WDT_S_Msk                (3ul << CLK_CLKSEL1_WDT_S_Pos)       /*!< CLK_T::CLKSEL1: WDT_S Mask */
S
S/* CLK CLKSEL2 Bit Field Definitions */
S#define CLK_CLKSEL2_WWDT_S_Pos               16                                   /*!< CLK_T::CLKSEL2: WWDT_S Position */
S#define CLK_CLKSEL2_WWDT_S_Msk               (3ul << CLK_CLKSEL2_WWDT_S_Pos)      /*!< CLK_T::CLKSEL2: WWDT_S Mask */
S
S#define CLK_CLKSEL2_PWM67_S_Pos              6                                    /*!< CLK_T::CLKSEL2: PWM67_S Position */
S#define CLK_CLKSEL2_PWM67_S_Msk              (3ul << CLK_CLKSEL2_PWM67_S_Pos)     /*!< CLK_T::CLKSEL2: PWM67_S Mask */
S
S#define CLK_CLKSEL2_PWM45_S_Pos              4                                    /*!< CLK_T::CLKSEL2: PWM45_S Position */
S#define CLK_CLKSEL2_PWM45_S_Msk              (3ul << CLK_CLKSEL2_PWM45_S_Pos)     /*!< CLK_T::CLKSEL2: PWM45_S Mask */
S
S#define CLK_CLKSEL2_FRQDIV_S_Pos             2                                    /*!< CLK_T::CLKSEL2: FRQDIV_S Position */
S#define CLK_CLKSEL2_FRQDIV_S_Msk             (3ul << CLK_CLKSEL2_FRQDIV_S_Pos)    /*!< CLK_T::CLKSEL2: FRQDIV_S Mask */
S
S/* CLK CLKDIV Bit Field Definitions */
S#define CLK_CLKDIV_ADC_N_Pos                 16                                   /*!< CLK_T::CLKDIV: ADC_N Position */
S#define CLK_CLKDIV_ADC_N_Msk                 (0xFFul << CLK_CLKDIV_ADC_N_Pos)     /*!< CLK_T::CLKDIV: ADC_N Mask */
S
S#define CLK_CLKDIV_UART_N_Pos                8                                    /*!< CLK_T::CLKDIV: UART_N Position */
S#define CLK_CLKDIV_UART_N_Msk                (0xFul << CLK_CLKDIV_UART_N_Pos)     /*!< CLK_T::CLKDIV: UART_N Mask */
S
S#define CLK_CLKDIV_HCLK_N_Pos                0                                    /*!< CLK_T::CLKDIV: HCLK_N Position */
S#define CLK_CLKDIV_HCLK_N_Msk                (0xFul << CLK_CLKDIV_HCLK_N_Pos)     /*!< CLK_T::CLKDIV: HCLK_N Mask */
S
S/* CLK PLLCON Bit Field Definitions */
S#define CLK_PLLCON_PLL_SRC_Pos               19                                      /*!< CLK_T::PLLCON: PLL_SRC Position */
S#define CLK_PLLCON_PLL_SRC_Msk               (1ul << CLK_PLLCON_PLL_SRC_Pos)      /*!< CLK_T::PLLCON: PLL_SRC Mask */
S
S#define CLK_PLLCON_OE_Pos                    18                                   /*!< CLK_T::PLLCON: OE Position */
S#define CLK_PLLCON_OE_Msk                    (1ul << CLK_PLLCON_OE_Pos)           /*!< CLK_T::PLLCON: OE Mask */
S
S#define CLK_PLLCON_BP_Pos                    17                                   /*!< CLK_T::PLLCON: BP Position */
S#define CLK_PLLCON_BP_Msk                    (1ul << CLK_PLLCON_BP_Pos)           /*!< CLK_T::PLLCON: BP Mask */
S
S#define CLK_PLLCON_PD_Pos                    16                                   /*!< CLK_T::PLLCON: PD Position */
S#define CLK_PLLCON_PD_Msk                    (1ul << CLK_PLLCON_PD_Pos)           /*!< CLK_T::PLLCON: PD Mask */
S
S#define CLK_PLLCON_OUT_DV_Pos                14                                   /*!< CLK_T::PLLCON: OUT_DV Position */
S#define CLK_PLLCON_OUT_DV_Msk                (3ul << CLK_PLLCON_OUT_DV_Pos)       /*!< CLK_T::PLLCON: OUT_DV Mask */
S
S#define CLK_PLLCON_IN_DV_Pos                 9                                    /*!< CLK_T::PLLCON: IN_DV Position */
S#define CLK_PLLCON_IN_DV_Msk                 (0x1Ful << CLK_PLLCON_IN_DV_Pos)     /*!< CLK_T::PLLCON: IN_DV Mask */
S
S#define CLK_PLLCON_FB_DV_Pos                 0                                    /*!< CLK_T::PLLCON: FB_DV Position */
S#define CLK_PLLCON_FB_DV_Msk                 (0x1FFul << CLK_PLLCON_FB_DV_Pos)    /*!< CLK_T::PLLCON: FB_DV Mask */
S
S/* CLK FRQDIV Bit Field Definitions */
S#define CLK_FRQDIV_DIVIDER1_Pos              5                                    /*!< CLK_T::FRQDIV: DIVIDER1 Position */
S#define CLK_FRQDIV_DIVIDER1_Msk              (1ul << CLK_FRQDIV_DIVIDER1_Pos)     /*!< CLK_T::FRQDIV: DIVIDER1 Mask */
S
S#define CLK_FRQDIV_DIVIDER_EN_Pos            4                                    /*!< CLK_T::FRQDIV: DIVIDER_EN Position */
S#define CLK_FRQDIV_DIVIDER_EN_Msk            (1ul << CLK_FRQDIV_DIVIDER_EN_Pos)   /*!< CLK_T::FRQDIV: DIVIDER_EN Mask */
S
S#define CLK_FRQDIV_FSEL_Pos                  0                                    /*!< CLK_T::FRQDIV: FSEL Position */
S#define CLK_FRQDIV_FSEL_Msk                  (0xFul << CLK_FRQDIV_FSEL_Pos)       /*!< CLK_T::FRQDIV: FSEL Mask */
S/**@}*/ /* CLK_CONST */
S/**@}*/ /* CLK */
S
S
S/*----------------------- External Bus Interface Controller ------------------*/
S/** @addtogroup EBI External Bus Interface(EBI)
S  Memory Mapped Structure for External Bus Interface Controller
S  @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var EBI_T::EBICON
S * Offset: 0x00  EBI Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ExtEN     |EBI Enable
S * |        |          |This bit is the functional enable bit for EBI.
S * |        |          |0 = EBI function is disabled
S * |        |          |1 = EBI function is enabled
S * |[1]     |ExtBW16   |EBI data width 16 bit
S * |        |          |This bit defines if the data bus is 8-bit or 16-bit.
S * |        |          |0 = EBI data width is 8 bit
S * |        |          |1 = EBI data width is 16 bit
S * |[10:8]  |MCLKDIV   |External Output Clock Divider
S * |        |          |The frequency of EBI output clock is controlled by MCLKDIV.
S * |        |          |000 = HCLK/1
S * |        |          |001 = HCLK/2
S * |        |          |010 = HCLK/4
S * |        |          |011 = HCLK/8
S * |        |          |100 = HCLK/16
S * |        |          |101 = HCKL/32
S * |        |          |11X = default
S * |        |          |Notice: Default value of output clock is HCLK/1
S * |[18:16] |ExttALE   |Expand Time of ALE
S * |        |          |The ALE width (tALE) to latch the address can be controlled by ExttALE.
S * |        |          |tALE = (ExttALE + 1) * MCLK
S * @var EBI_T::EXTIME
S * Offset: 0x04  EBI Timing Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:3]   |ExttACC   |EBI Data Access Time
S * |        |          |ExttACC define data access time (tACC).
S * |        |          |tACC = (ExttACC + 1) * MCLK
S * |[10:8]  |ExttAHD   |EBI Data Access Hold Time
S * |        |          |ExttAHD define data access hold time (tAHD).
S * |        |          |tAHD = (ExttAHD + 1) * MCLK
S * |[15:12] |ExtIW2X   |Idle State Cycle After Write
S * |        |          |When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not zero.
S * |        |          |Idle state cycle = (ExtIW2X * MCLK)
S * |[27:24] |ExtIR2R   |Idle State Cycle Between Read-Read
S * |        |          |When read action is finish and next action is going to read, idle state is inserted and nCS return
S * |        |          |to high if ExtIR2R is not zero.
S * |        |          |Idle state cycle = (ExtIR2R * MCLK)
S * @var EBI_T::EBICON2
S * Offset: 0x08   External Bus Interface General Control Register 2
S * ---------------------------------------------------------------------------------------------------
S */
S
S    __IO uint32_t EBICON;        /* Offset: 0x00  EBI Control Register                                               */
S    __IO uint32_t EXTIME;        /* Offset: 0x04  EBI Timing Control Register                                        */
S    __IO uint32_t EBICON2;       /* Offset: 0x08   External Bus Interface General Control Register 2                 */
S
S} EBI_T;
S
S
S
S
S/** @addtogroup EBI_CONST EBI Bit Field Definition
S  Constant Definitions for EBI Controller
S  @{
S */
S/* EBI EBICON Bit Field Definitions */
S#define EBI_EBICON_ExttALE_Pos      16                                          /*!< EBI_T::EBICON: ExttALE Position */
S#define EBI_EBICON_ExttALE_Msk      (0x7ul << EBI_EBICON_ExttALE_Pos)           /*!< EBI_T::EBICON: ExttALE Mask */
S
S#define EBI_EBICON_MCLKDIV_Pos      8                                           /*!< EBI_T::EBICON: MCLKDIV Position */
S#define EBI_EBICON_MCLKDIV_Msk      (0x7ul << EBI_EBICON_MCLKDIV_Pos)           /*!< EBI_T::EBICON: MCLKDIV Mask */
S
S#define EBI_EBICON_ExtBW16_Pos      1                                           /*!< EBI_T::EBICON: ExtBW16 Position */
S#define EBI_EBICON_ExtBW16_Msk      (1ul << EBI_EBICON_ExtBW16_Pos)             /*!< EBI_T::EBICON: ExtBW16 Mask */
S
S#define EBI_EBICON_ExtEN_Pos        0                                           /*!< EBI_T::EBICON: ExtEN Position */
S#define EBI_EBICON_ExtEN_Msk        (1ul << EBI_EBICON_ExtEN_Pos)               /*!< EBI_T::EBICON: ExtEN Mask */
S
S/* EBI EXTIME Bit Field Definitions */
S#define EBI_EXTIME_ExtIR2R_Pos      24                                          /*!< EBI_T::EXTIME: ExtIR2R Position */
S#define EBI_EXTIME_ExtIR2R_Msk      (0xFul << EBI_EXTIME_ExtIR2R_Pos)           /*!< EBI_T::EXTIME: ExtIR2R Mask */
S
S#define EBI_EXTIME_ExtIW2X_Pos      12                                          /*!< EBI_T::EXTIME: ExtIW2X Position */
S#define EBI_EXTIME_ExtIW2X_Msk      (0xFul << EBI_EXTIME_ExtIW2X_Pos)           /*!< EBI_T::EXTIME: ExtIW2X Mask */
S
S#define EBI_EXTIME_ExttAHD_Pos      8                                           /*!< EBI_T::EXTIME: ExttAHD Position */
S#define EBI_EXTIME_ExttAHD_Msk      (0x7ul << EBI_EXTIME_ExttAHD_Pos)           /*!< EBI_T::EXTIME: ExttAHD Mask */
S
S#define EBI_EXTIME_ExttACC_Pos      3                                           /*!< EBI_T::EXTIME: ExttACC Position */
S#define EBI_EXTIME_ExttACC_Msk      (0x1Ful << EBI_EXTIME_ExttACC_Pos)          /*!< EBI_T::EXTIME: ExttACC Mask */
S
S/* EBI EBICON2 Bit Field Definitions */
S#define EBI_EBICON2_WAHD_OFF_Pos    2                                           /*!< EBI_T::EBICON2: WAHD_OFF Position */
S#define EBI_EBICON2_WAHD_OFF_Msk    (1ul << EBI_EBICON2_WAHD_OFF_Pos)           /*!< EBI_T::EBICON2: WAHD_OFF Mask */
S
S#define EBI_EBICON2_RAHD_OFF_Pos    1                                           /*!< EBI_T::EBICON2: RAHD_OFF Position */
S#define EBI_EBICON2_RAHD_OFF_Msk    (1ul << EBI_EBICON2_RAHD_OFF_Pos)           /*!< EBI_T::EBICON2: RAHD_OFF Mask */
S
S#define EBI_EBICON2_WBUFF_EN_Pos    0                                           /*!< EBI_T::EBICON2: WBUFF_EN Position */
S#define EBI_EBICON2_WBUFF_EN_Msk    (1ul << EBI_EBICON2_WBUFF_EN_Pos)           /*!< EBI_T::EBICON2: WBUFF_EN Mask */
S/**@}*/ /* EBI_CONST */
S/**@}*/ /* EBI */
S
S
S/*-------------------------- FLASH Memory Controller -------------------------*/
S
S/** @addtogroup FMC Flash Memory Controller(FMC)
S *
S * Memory Mapped Structure for Flash Memory Controller
S * @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var FMC_T::ISPCON
S * Offset: 0x00  ISP Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ISPEN     |ISP Enable
S * |        |          |This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function.
S * |        |          |1 = Enable ISP function
S * |        |          |0 = Disable ISP function
S * |[1]     |BS        |Boot Select
S * |        |          |This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM,
S * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check where
S * |        |          |MCU booted from. This bit is initiated with the inverted value of CBS in Config0 after power-
S * |        |          |on reset; It keeps the same value at other reset.
S * |        |          |1 = boot from LDROM
S * |        |          |0 = boot from APROM
S * |[3]     |APUEN     |APROM Update Enable (write-protected)
S * |        |          |1 = APROM can be updated when the chip runs in APROM
S * |        |          |0 = APROM can not be updated when the chip runs in APROM
S * |[4]     |CFGUEN    |Config Update Enable
S * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program
S * |        |          |code is running in APROM or LDROM.
S * |        |          |1 = Config update enable
S * |        |          |0 = Config update disable
S * |[5]     |LDUEN     |LDROM Update Enable
S * |        |          |LDROM update enable bit.
S * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
S * |        |          |0 = LDROM cannot be updated
S * |[6]     |ISPFF     |ISP Fail Flag
S * |        |          |(1) APROM writes to itself.
S * |        |          |(2) LDROM writes to itself.
S * |        |          |(3) CONFIG is erased/programmed when CFGUEN is set to 0
S * |        |          |(4) Destination address is illegal, such as over an available range.
S * |        |          |Write 1 to clear this bit.
S * @var FMC_T::ISPADR
S * Offset: 0x04  ISP Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ISPADR    |ISP Address
S * |        |          |NuMicro M051 series equips with a maximum 16kx32 embedded flash, it supports word program
S * |        |          |only. ISPARD[1:0] must be kept 2'b00 for ISP operation.
S * @var FMC_T::ISPDAT
S * Offset: 0x08  ISP Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ISPDAT    |ISP Data
S * |        |          |Write data to this register before ISP program operation
S * |        |          |Read data from this register after ISP read operation
S * @var FMC_T::ISPCMD
S * Offset: 0x0C  ISP Command Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |ISPCMD    |ISP Command
S * |        |          |ISP command table is shown below:
S * |        |          |0x00 = Read.
S * |        |          |0x21 = Program.
S * |        |          |0x22 = Page Erase.
S * @var FMC_T::ISPTRG
S * Offset: 0x10  IISP Trigger Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ISPGO     |ISP start trigger
S * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP
S * |        |          |operation is finish.
S * |        |          |1 = ISP is on going
S * |        |          |0 = ISP done
S * @var FMC_T::DFBADR
S * Offset: 0x14  Data Flash Base Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |DFBA      |Data Flash Base Address
S * |        |          |This register indicates data flash start address.
S * |        |          |It is a read only register.
S * |        |          |For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is fixed at
S * |        |          |0x01F000 by hardware internally.
S * @var FMC_T::FATCON
S * Offset: 0x18  Flash Access Time Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[4]     |LFOM      |Low Frequency Optimization Mode (write-protected)
S * |        |          |1 = Flash access always no wait state (zero wait state)
S * |        |          |0 = Insert wait state while Flash access discontinued address.
S * |        |          |Note: Set this bit only when HCLK <= 25MHz. If HCLK > 25MHz, CPU will fetch wrong
S * |        |          |code and cause fail result.
S * @var FMC_T::ISPSTA
S * Offset: 0x40  ISP Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ISPGO     |ISP Start Trigger (Read Only)
S * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware
S * |        |          |automatically when ISP operation is finished.
S * |        |          |1 = ISP operation progressed.
S * |        |          |0 = ISP operation finished.
S * |        |          |Note: This bit is the same as ISPTRG bit0
S * |[2:1]   |CBS       |Chip Boot Selection (Read Only)
S * |        |          |This is a mirror of CBS in Config0.
S * |[6]     |ISPFF     |ISP Fail Flag (Write-protection Bit)
S * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S * |        |          |(1) APROM writes to itself.
S * |        |          |(2) LDROM writes to itself.
S * |        |          |(3) CONFIG is erased/programmed when CFGUEN is set to 0
S * |        |          |(4) Destination address is illegal, such as over an available range.
S * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
S * |        |          |The current flash address space 0x0000_0000~0x0000_01FF is mapping to the address
S * |        |          |specified by the VECMAP * 512.
S */
S
S    __IO uint32_t ISPCON;        /* Offset: 0x00  ISP Control Register                                               */
S    __IO uint32_t ISPADR;        /* Offset: 0x04  ISP Address Register                                               */
S    __IO uint32_t ISPDAT;        /* Offset: 0x08  ISP Data Register                                                  */
S    __IO uint32_t ISPCMD;        /* Offset: 0x0C  ISP Command Register                                               */
S    __IO uint32_t ISPTRG;        /* Offset: 0x10  IISP Trigger Control Register                                      */
S    __I  uint32_t DFBADR;        /* Offset: 0x14  Data Flash Base Address Register                                   */
S    __IO uint32_t FATCON;        /* Offset: 0x18  Flash Access Time Control Register                                 */
S    __I  uint32_t RESERVED[9];   
S    __IO uint32_t ISPSTA;        /* Offset: 0x40  ISP Status Register                                                */
S} FMC_T;
S
S
S
S/** @addtogroup FMC_CONST FMC Bit Field Definition
S  Constant Definitions for FMC Controller
S  @{
S */
S/* FMC ISPCON Bit Field Definitions */
S#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC_T::ISPCON: ISPFF Position */
S#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC_T::ISPCON: ISPFF Mask */
S
S#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC_T::ISPCON: LDUEN Position */
S#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC_T::ISPCON: LDUEN Mask */
S
S#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC_T::ISPCON: CFGUEN Position */
S#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC_T::ISPCON: CFGUEN Mask */
S
S#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC_T::ISPCON: APUEN Position */
S#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC_T::ISPCON: APUEN Mask */
S
S#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC_T::ISPCON: BS Position */
S#define FMC_ISPCON_BS_Msk                       (1ul << FMC_ISPCON_BS_Pos)              /*!< FMC_T::ISPCON: BS Mask */
S
S#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC_T::ISPCON: ISPEN Position */
S#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC_T::ISPCON: ISPEN Mask */
S
S
S/* FMC ISPCMD Bit Field Definitions */
S#define FMC_ISPCMD_FOEN_Pos                     5                                       /*!< FMC_T::ISPCMD: FOEN Position */
S#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)            /*!< FMC_T::ISPCMD: FOEN Mask */
S
S#define FMC_ISPCMD_FCEN_Pos                     4                                       /*!< FMC_T::ISPCMD: FCEN Position */
S#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)            /*!< FMC_T::ISPCMD: FCEN Mask */
S
S#define FMC_ISPCMD_FCTRL_Pos                    0                                       /*!< FMC_T::ISPCMD: FCTRL Position */
S#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)         /*!< FMC_T::ISPCMD: FCTRL Mask */
S
S/* FMC ISPTRG Bit Field Definitions */
S#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC_T::ISPTRG: ISPGO Position */
S#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC_T::ISPTRG: ISPGO Mask */
S
S/* FMC FATCON Bit Field Definitions */
S#define FMC_FATCON_LFOM_Pos                     4                                       /*!< FMC_T::FATCON: LFOM Position */
S#define FMC_FATCON_LFOM_Msk                     (1ul << FMC_FATCON_LFOM_Pos)            /*!< FMC_T::FATCON: LFOM Mask */
S
S/* FMC ISPSTA Bit Field Definitions */
S#define FMC_ISPSTA_ISPGO_Pos                    0                                       /*!< FMC_T::ISPSTA: ISPGO Position */
S#define FMC_ISPSTA_ISPGO_Msk                    (1ul << FMC_ISPSTA_ISPGO_Pos)           /*!< FMC_T::ISPSTA: ISPGO Mask */
S
S#define FMC_ISPSTA_CBS_Pos                      1                                       /*!< FMC_T::ISPSTA: CBS Position */
S#define FMC_ISPSTA_CBS_Msk                      (3ul << FMC_ISPSTA_CBS_Pos)             /*!< FMC_T::ISPSTA: CBS Mask */
S
S#define FMC_ISPSTA_ISPFF_Pos                    6                                       /*!< FMC_T::ISPSTA: ISPFF Position */
S#define FMC_ISPSTA_ISPFF_Msk                    (1ul << FMC_ISPSTA_ISPFF_Pos)           /*!< FMC_T::ISPSTA: ISPFF Mask */
S
S#define FMC_ISPSTA_VECMAP_Pos                   9                                       /*!< FMC_T::ISPSTA: VECMAP Position */
S#define FMC_ISPSTA_VECMAP_Msk                   (0xffful << FMC_ISPSTA_VECMAP_Pos)      /*!< FMC_T::ISPSTA: VECMAP Mask */
S/**@}*/ /* FMC_CONST */
S/**@}*/ /* FMC */
S
S
S/*--------------------- General Purpose Input and Output ---------------------*/
S/** @addtogroup GPIO General Purpose Input and Output(GPIO)
S  Memory Mapped Structure for General Purpose I/O
S  @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var GPIO_T::PMD
S * Offset: 0x00/0x40/0x80/0xC0/0x100  Port 0-4  I/O Mode Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2n+1:2n]|PMDn     |Determine each I/O mode of Px.n pins.
S * |        |          |00 = Px.n is in Input mode.
S * |        |          |01 = Px.n is in Push-pull Output mode.
S * |        |          |10 = Px.n is in Open-drain Output mode.
S * |        |          |11 = Px.n is in Quasi-bidirectional mode.
S * |        |          |Note1: x = 0~4, n = 0~7.
S * |        |          |Note2: The default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip is powered on (only for M05xxBN).
S * |        |          |Note3: The initial value of this field is defined by CIOINI (CONFIG[10]) (only for M05xxDN/DE). 
S * |        |          |If CIOINI is set to 1, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on. 
S * |        |          |If CIOINI is set to 0, the default value is 0x0000_0000 and all pins will be input tri-state mode after chip powered on.        
S * @var GPIO_T::OFFD
S * Offset: 0x04/0x44/0x84/0xC4/0x104 Port 0-4 Digital Input Path Disable Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:16] |OFFD      |Port 0-4 Pin [n] Digital Input Path Disable Control
S * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled. 
S * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
S * |        |          |0 = Px.n digital input path Enabled.
S * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
S * |        |          |Note: x = 0~4, n = 0~7.
S * @var GPIO_T::DOUT
S * Offset: 0x8/0x48/0x88/0xC8/0x108 Port 0-4 Data Output Value
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |DOUT[n]   |Port 0-4 Pin [n] Output Value
S * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
S * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
S * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
S * |        |          |Note: x = 0~4, n = 0~7.
S * @var GPIO_T::DMASK
S * Offset: 0x0C/0x4C/0x8C/0xCC/0x10C Port 0-4 Data Output Write Mask
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |DMASK[n]  |Port 0-4 Pin [n] Data Output Write Mask
S * |        |          |These bits are used to protect the corresponding Px_DOUT[n] bit. When the DMASK[n] bit is set to 1, the corresponding Px_DOUT[n] bit is protected. 
S * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
S * |        |          |0 = Corresponding Px_DOUT[n] bit can be updated.
S * |        |          |1 = Corresponding Px_DOUT[n] bit protected.
S * |        |          |Note1: x = 0~4, n = 0~7.
S * |        |          |Note2: This function only protects the corresponding Px_DOUT[n] bit, and will not protect the corresponding Pxn_PDIO bit.
S * @var GPIO_T::PIN
S * Offset: 0x10/0x50/0x90/0xD0/0x110 Port 0-4 Pin Value
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PIN[n]    |Port 0-4 Pin [n] Pin Value
S * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin. If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
S * |        |          |Note: x = 0~4, n = 0~7.
S * @var GPIO_T::DBEN
S * Offset: 0x14/0x54/0x94/0xD4/0x114 Port 0-4 De-bounce Enable
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |DBEN[n]   |Port 0-4 Pin [n] Input Signal De-bounce Enable Control
S * |        |          |DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
S * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
S * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].
S * |        |          |0 = Px.n de-bounce function Disabled.
S * |        |          |1 = Px.n de-bounce function Enabled.
S * |        |          |The de-bounce function is valid only for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
S * |        |          |Note1: x = 0~4, n = 0~7.
S * |        |          |Note2: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.
S * @var GPIO_T::IMD
S * Offset: 0x18/0x58/0x98/0xD8/0x118 Port 0-4 Interrupt Mode Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |IMD[n]    |Port 0-4 Pin [n] Edge or Level Detection Interrupt Mode Control
S * |        |          |IMD[n] bit is used to control the triggered interrupt is by level trigger or by edge trigger.
S * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
S * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
S * |        |          |0 = Edge trigger interrupt.
S * |        |          |1 = Level trigger interrupt.
S * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers Px_IEN. If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
S * |        |          |The de-bounce function is valid only for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
S * |        |          |Note: x = 0~4, n = 0~7.
S * @var GPIO_T::IEN
S * Offset: 0x1C/0x5C/0x9C/0xDC/0x11C Port 0-4 Interrupt Enable Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:16] |IR_EN[n]  |Port 0-4 Pin [n] Interrupt Enable by Input Rising Edge or Input Level High
S * |        |          |IR_EN[n] bit is used to enable the interrupt for each of the corresponding input Px.n pin.
S * |        |          |Set bit to 1 also enable the pin wake-up function.
S * |        |          |When setting the IR_EN[n] bit to 1 :
S * |        |          |If the interrupt is level trigger (IMD[n] is 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
S * |        |          |If the interrupt is edge trigger (IMD[n] is 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
S * |        |          |0 = Px.n level high or low to high interrupt Disabled.
S * |        |          |1 = Px.n level high or low to high interrupt Enabled.
S * |        |          |Note: x = 0~4, n = 0~7.
S * |[7:0]   |IF_EN[n]  |Port 0-4 Pin [n] Interrupt Enable by Input Falling Edge or Input Level Low
S * |        |          |IF_EN[n] bit is used to enable the interrupt for each of the corresponding input Px.n pin.
S * |        |          |Set bit to 1 also enable the pin wake-up function.
S * |        |          |When setting the IF_EN[n] bit to 1 :
S * |        |          |If the interrupt is level trigger (IMD[n] is 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
S * |        |          |If the interrupt is edge trigger (IMD[n] is 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
S * |        |          |0 = Px.n level low or high to low interrupt Disabled.
S * |        |          |1 = Px.n level low or high to low interrupt Enabled.
S * |        |          |Note: x = 0~4, n = 0~7.
S * @var GPIO_T::ISRC
S * Offset: 0x20/0x60/0xA0/0xE0/0x120 Port 0-4 Interrupt Trigger Source
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |ISRC[n]   |Port 0-4 Pin [n] Interrupt Source Flag
S * |        |          |Write :
S * |        |          |0 = No action.
S * |        |          |1 = Clear the corresponding pending interrupt.
S * |        |          |Read :
S * |        |          |0 = No interrupt at Px.n.
S * |        |          |1 = Px.n generates an interrupt.
S * |        |          |Note: x = 0~4, n = 0~7.
S */
S
S    __IO uint32_t PMD;           /* Offset: 0x00/0x40/0x80/0xC0/0x100 Port 0-4  I/O Mode Control                     */
S    __IO uint32_t OFFD;          /* Offset: 0x04/0x44/0x84/0xC4/0x104 Port 0-4 Digital Input Path Disable Control    */
S    __IO uint32_t DOUT;          /* Offset: 0x08/0x48/0x88/0xC8/0x108 Port 0-4 Data Output Value                     */
S    __IO uint32_t DMASK;         /* Offset: 0x0C/0x4C/0x8C/0xCC/0x10C Port 0-4 Data Output Write Mask                */
S    __IO uint32_t PIN;           /* Offset: 0x10/0x50/0x90/0xD0/0x110 Port 0-4 Pin Value                             */
S    __IO uint32_t DBEN;          /* Offset: 0x14/0x54/0x94/0xD4/0x114 Port 0-4 De-bounce Enable                      */
S    __IO uint32_t IMD;           /* Offset: 0x18/0x58/0x98/0xD8/0x118 Port 0-4 Interrupt Mode Control                */
S    __IO uint32_t IEN;           /* Offset: 0x1C/0x5C/0x9C/0xDC/0x11C Port 0-4 Interrupt Enable Control              */
S    __IO uint32_t ISRC;          /* Offset: 0x20/0x60/0xA0/0xE0/0x120 Port 0-4 Interrupt Trigger Source              */
S
S} GPIO_T;
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var GPIO_DBNCECON_T::DBNCECON
S * Offset: 0x180 Interrupt De-bounce Cycle Control
S * ---------------------------------------------------------------------------------------------------    
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |DBCLKSEL  |De-bounce Sampling Cycle Selection
S * |        |          |0000 = Sample interrupt input once per 1 clocks.
S * |        |          |0001 = Sample interrupt input once per 2 clocks.
S * |        |          |0010 = Sample interrupt input once per 4 clocks.
S * |        |          |0011 = Sample interrupt input once per 8 clocks.
S * |        |          |0100 = Sample interrupt input once per 16 clocks.
S * |        |          |0101 = Sample interrupt input once per 32 clocks.
S * |        |          |0110 = Sample interrupt input once per 64 clocks.
S * |        |          |0111 = Sample interrupt input once per 128 clocks.
S * |        |          |1000 = Sample interrupt input once per 256 clocks.
S * |        |          |1001 = Sample interrupt input once per 2*256 clocks.
S * |        |          |1010 = Sample interrupt input once per 4*256 clocks.
S * |        |          |1011 = Sample interrupt input once per 8*256 clocks.
S * |        |          |1100 = Sample interrupt input once per 16*256 clocks.
S * |        |          |1101 = Sample interrupt input once per 32*256 clocks.
S * |        |          |1110 = Sample interrupt input once per 64*256 clocks.
S * |        |          |1111 = Sample interrupt input once per 128*256 clocks.
S * |[4]     |DBCLKSRC  |De-bounce Counter Clock Source Selection
S * |        |          |0 = De-bounce counter clock source is the HCLK.
S * |        |          |1 = De-bounce counter clock source is the 10 kHz internal low speed oscillator.
S * |[5]     |ICLK_ON   |Interrupt Clock On Mode
S * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding Px_IEN bit is set to 1.
S * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
S * |        |          |Note: It is recommended to turn off this bit to save system power if no special application concern.
S */
S
S    __IO uint32_t DBNCECON;      /* Offset: 0x180 Interrupt De-bounce Cycle Control                                  */
S
S} GPIO_DBNCECON_T;
S
S
S
S
S/** @addtogroup GPIO_CONST GPIO Bit Field Definition
S  Constant Definitions for GPIO Controller
S  @{
S */
S
S/* GPIO PMD Bit Field Definitions */
S#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO_T::PMD: PMD7 Position */
S#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO_T::PMD: PMD7 Mask */
S
S#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO_T::PMD: PMD6 Position */
S#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO_T::PMD: PMD6 Mask */
S
S#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO_T::PMD: PMD5 Position */
S#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO_T::PMD: PMD5 Mask */
S
S#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO_T::PMD: PMD4 Position */
S#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO_T::PMD: PMD4 Mask */
S
S#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO_T::PMD: PMD3 Position */
S#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO_T::PMD: PMD3 Mask */
S
S#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO_T::PMD: PMD2 Position */
S#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO_T::PMD: PMD2 Mask */
S
S#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO_T::PMD: PMD1 Position */
S#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO_T::PMD: PMD1 Mask */
S
S#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO_T::PMD: PMD0 Position */
S#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO_T::PMD: PMD0 Mask */
S
S/* GPIO OFFD Bit Field Definitions */
S#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO_T::OFFD: OFFD Position */
S#define GPIO_OFFD_OFFD_Msk          (0xFFul << GPIO_OFFD_OFFD_Pos)              /*!< GPIO_T::OFFD: OFFD Mask */
S
S/* GPIO DOUT Bit Field Definitions */
S#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO_T::DOUT: DOUT Position */
S#define GPIO_DOUT_DOUT_Msk          (0xFFul << GPIO_DOUT_DOUT_Pos)              /*!< GPIO_T::DOUT: DOUT Mask */
S
S/* GPIO DMASK Bit Field Definitions */
S#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO_T::DMASK: DMASK Position */
S#define GPIO_DMASK_DMASK_Msk        (0xFFul << GPIO_DMASK_DMASK_Pos)            /*!< GPIO_T::DMASK: DMASK Mask */
S
S/* GPIO PIN Bit Field Definitions */
S#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO_T::PIN: PIN Position */
S#define GPIO_PIN_PIN_Msk            (0xFFul << GPIO_PIN_PIN_Pos)                /*!< GPIO_T::PIN: PIN Mask */
S
S/* GPIO DBEN Bit Field Definitions */
S#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO_T::DBEN: DBEN Position */
S#define GPIO_DBEN_DBEN_Msk          (0xFFul << GPIO_DBEN_DBEN_Pos)              /*!< GPIO_T::DBEN: DBEN Mask */
S
S/* GPIO IMD Bit Field Definitions */
S#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO_T::IMD: IMD Position */
S#define GPIO_IMD_IMD_Msk            (0xFFul << GPIO_IMD_IMD_Pos)                /*!< GPIO_T::IMD: IMD Mask */
S
S/* GPIO IEN Bit Field Definitions */
S#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO_T::IEN: IR_EN Position */
S#define GPIO_IEN_IR_EN_Msk          (0xFFul << GPIO_IEN_IR_EN_Pos)              /*!< GPIO_T::IEN: IR_EN Mask */
S
S#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO_T::IEN: IF_EN Position */
S#define GPIO_IEN_IF_EN_Msk          (0xFFul << GPIO_IEN_IF_EN_Pos)              /*!< GPIO_T::IEN: IF_EN Mask */
S
S/* GPIO ISRC Bit Field Definitions */
S#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO_T::ISRC: ISRC Position */
S#define GPIO_ISRC_ISRC_Msk          (0xFFul << GPIO_ISRC_ISRC_Pos)              /*!< GPIO_T::ISRC: ISRC Mask */
S
S/* GPIO DBNCECON Bit Field Definitions */
S#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON  Position */
S#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON  Mask */
S
S#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Position */
S#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Mask */
S
S#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Position */
S#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Mask */
S/**@}*/ /* GPIO_CONST */
S/**@}*/ /* GPIO */
S
S
S
S/*----------------------- Hardware Divider Interface Controller ------------------*/
S/** @addtogroup HDIV Hardware Divider(HDIV)
S  Memory Mapped Structure for Divider Interface Controller
S  @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var HDIV_T::DIVIDEND
S * Offset: 0x00  Dividend Source Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |DIVIDEND  |Dividend Source.
S * |        |          |This register is given the dividend of divider before calculation starts.
S * @var HDIV_T::DIVISOR
S * Offset: 0x04  Divisor Source Resister
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |DIVISOR   |Divisor Source.
S * |        |          |This register is given the divisor of divider before calculation starts.
S * |        |          |Note: when this register is written, hardware divider will start calculate
S * @var HDIV_T::DIVQUO
S * Offset: 0x08  Quotient Result Resister
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |QUOTIENT  |Quotient Result
S * |        |          |This register holds the quotient result of divider after calculation complete.
S * @var HDIV_T::DIVREM
S * Offset: 0x08  Reminder Result Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |QUOTIENT  |Reminder Result
S * |        |          |This register holds the reminder result of divider after calculation complete.
S * @var HDIV_T::DIVSTS
S * Offset: 0x08  Divider Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |DIV_FINISH|Divider operation finished.
S * |        |          |0 = The divider calculation is not yet.
S * |        |          |1 = The divider calculation is finished.
S * |        |          |This register is read only.
S * |[1]     |DIV0      |Divisor zero warning.
S * |        |          |0 = The divisor is not 0.
S * |        |          |1 = The divisor is 0.
S * |        |          |This register is read only.
S */
S
S    __IO int32_t  DIVIDEND;      /* Offset: 0x00  Dividend Source Register                                           */
S    __IO int32_t  DIVISOR;       /* Offset: 0x04  Divisor Source Resister                                            */
S    __IO int32_t  DIVQUO;        /* Offset: 0x08  Quotient Result Resister                                           */
S    __IO int32_t  DIVREM;        /* Offset: 0x08  Reminder Result Register                                           */
S    __IO uint32_t DIVSTS;        /* Offset: 0x08  Divider Status Register                                            */
S
S} HDIV_T;
S
S
S
S
S/** @addtogroup HDIV_CONST HDIV Bit Field Definition
S  Constant Definitions for HDIV Controller
S  @{
S */
S
S#define HDIV_DIVSTS_DIV_FINISH_Pos   0
S#define HDIV_DIVSTS_DIV_FINISH_Msk   (1ul << HDIV_DIVSTS_DIV_FINISH_Pos)
S
S#define HDIV_DIVSTS_DIV0_Pos         1
S#define HDIV_DIVSTS_DIV0_Msk         (1ul << HDIV_DIVSTS_DIV0_Pos)
S
S/**@}*/ /* HDIV_CONST */
S/**@}*/ /* DIV */
S
S
S
S/*------------------------------ I2C Controller ------------------------------*/
S
S/** @addtogroup I2C I2C Controller(I2C)
S  Memory Mapped Structure for I2C Serial Interface Controller
S  @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var I2C_T::I2CON
S * Offset: 0x00  I2C Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2]     |AA        |Assert Acknowledge control bit.
S * |        |          |When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during
S * |        |          |the acknowledge clock pulse on the SCL line when 
S * |        |          |1. A slave is acknowledging the address sent from master, 
S * |        |          |2. The receiver devices are acknowledging the data sent by transmitter. When AA=0 prior to
S * |        |          |address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge
S * |        |          |clock pulse on the SCL line.
S * |[3]     |SI        |I2C Interrupt Flag.
S * |        |          |When a new SIO state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI
S * |        |          |(I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing one
S * |        |          |to this bit.
S * |[4]     |STO       |I2C STOP Flag.
S * |        |          |In master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus
S * |        |          |condition if a STOP condition is detected this flag will be cleared by hardware automatically.
S * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means
S * |        |          |it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
S * |[5]     |STA       |I2C START Flag.
S * |        |          |Setting STA to logic 1 to enter master mode, the I2C hardware sends a START or repeat START condition
S * |        |          |to bus when the bus is free.
S * |[6]     |ENSI      |I2C controller is enabled/disable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |        |          |Set to enable I2C serial function block. When ENS=1 the I2C serial function enables. The multi-function
S * |        |          |pin function of SDA and SCL must set to I2C function first.
S * |[7]     |EI        |Enable interrupt.
S * |        |          |1 = Enable I2C interrupt.
S * |        |          |0 = Disable I2C interrupt.
S * @var I2C_T::I2CADDR0
S * Offset: 0x04  I2C Slave Address Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = Disable General Call Function.
S * |        |          |1 = Enable General Call Function.
S * |[7:1]   |I2CADDR   |I2C Address Register
S * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven
S * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if
S * |        |          |either of the address is matched.
S * @var I2C_T::I2CDAT
S * Offset: 0x08  I2C Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |I2CDAT    |I2C Data Register
S * |        |          |Bit[7:0] is located with the 8-bit transferred data of I2C serial port.
S * @var I2C_T::I2CSTATUS
S * Offset: 0x0C  I2C Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |I2CSTATUS |I2C Status Register
S * |        |          |The status register of I2C:
S * |        |          |The three least significant bits are always 0. The five most significant bits contain the status code.
S * |        |          |There are 26 possible status codes. When I2STATUS contains F8H, no serial interrupt is
S * |        |          |requested. All other I2STATUS values correspond to defined I2C states. When each of these
S * |        |          |states is entered, a status interrupt is requested (SI = 1). A valid status code is present in
S * |        |          |I2STATUS one machine cycle after SI is set by hardware and is still present one machine cycle
S * |        |          |after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error
S * |        |          |occurs when a START or STOP condition is present at an illegal position in the formation frame.
S * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an
S * |        |          |acknowledge bit.
S * @var I2C_T::I2CLK
S * Offset: 0x10  I2C Clock Divided Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |I2CLK     |I2C clock divided Register
S * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x(I2CLK+1)).
S * @var I2C_T::I2CTOC
S * Offset: 0x14  I2C Time-Out Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TIF       |Time-Out flag.
S * |        |          |1 = Time-Out flag is set by H/W. It can interrupt CPU.
S * |        |          |0 = S/W can clear the flag.
S * |[1]     |DIV4      |Time-Out counter input clock is divider by 4
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |        |          |When Enable, The time-Out period is prolong 4 times.
S * |[2]     |ENTI      |Time-out counter is enabled/disable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |        |          |When Enable, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will
S * |        |          |reset counter and re-start up counting after SI is cleared.
S * @var I2C_T::I2CADDR1
S * Offset: 0x18  I2C Slave Address Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = Disable General Call Function.
S * |        |          |1 = Enable General Call Function.
S * |[7:1]   |I2CADDR   |I2C Address Register
S * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven
S * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if
S * |        |          |either of the address is matched.
S * @var I2C_T::I2CADDR2
S * Offset: 0x1C  I2C Slave Address Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = Disable General Call Function.
S * |        |          |1 = Enable General Call Function.
S * |[7:1]   |I2CADDR   |I2C Address Register
S * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven
S * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if
S * |        |          |either of the address is matched.
S * @var I2C_T::I2CADDR3
S * Offset: 0x20  I2C Slave Address Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = Disable General Call Function.
S * |        |          |1 = Enable General Call Function.
S * |[7:1]   |I2CADDR   |I2C Address Register
S * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven
S * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if
S * |        |          |either of the address is matched.
S * @var I2C_T::I2CADM0
S * Offset: 0x24  I2C Slave Address Mask Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |I2ADMx    |I2C Address Mask register
S * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as address register.)
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received
S * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received
S * |        |          |corresponding register bit should be exact the same as address register.
S * @var I2C_T::I2CADM1
S * Offset: 0x28  I2C Slave Address Mask Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |I2ADMx    |I2C Address Mask register
S * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as address register.)
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received
S * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received
S * |        |          |corresponding register bit should be exact the same as address register.
S * @var I2C_T::I2CADM2
S * Offset: 0x2C  I2C Slave Address Mask Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |I2ADMx    |I2C Address Mask register
S * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as address register.)
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received
S * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received
S * |        |          |corresponding register bit should be exact the same as address register.
S * @var I2C_T::I2CADM3
S * Offset: 0x30  I2C Slave Address Mask Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |I2ADMx    |I2C Address Mask register
S * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as address register.)
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received
S * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received
S * |        |          |corresponding register bit should be exact the same as address register.
S * @var I2C_T::I2CWKUPCON
S * Offset: 0x3C  I2C Wake Up Control Register
S * ---------------------------------------------------------------------------------------------------
S * @var I2C_T::I2CWKUPSTS
S * Offset: 0x40  I2C Wake Up Status Register
S * ---------------------------------------------------------------------------------------------------
S */
S
S    __IO uint32_t I2CON;         /* Offset: 0x00  I2C Control Register                                               */
S    __IO uint32_t I2CADDR0;      /* Offset: 0x04  I2C Slave Address Register 0                                       */
S    __IO uint32_t I2CDAT;        /* Offset: 0x08  I2C Data Register                                                  */
S    __I  uint32_t I2CSTATUS;     /* Offset: 0x0C  I2C Status Register                                                */
S    __IO uint32_t I2CLK;         /* Offset: 0x10  I2C Clock Divided Register                                         */
S    __IO uint32_t I2CTOC;        /* Offset: 0x14  I2C Time-Out Control Register                                      */
S    __IO uint32_t I2CADDR1;      /* Offset: 0x18  I2C Slave Address Register 1                                       */
S    __IO uint32_t I2CADDR2;      /* Offset: 0x1C  I2C Slave Address Register 2                                       */
S    __IO uint32_t I2CADDR3;      /* Offset: 0x20  I2C Slave Address Register 3                                       */
S    __IO uint32_t I2CADM0;       /* Offset: 0x24  I2C Slave Address Mask Register 0                                  */
S    __IO uint32_t I2CADM1;       /* Offset: 0x28  I2C Slave Address Mask Register 1                                  */
S    __IO uint32_t I2CADM2;       /* Offset: 0x2C  I2C Slave Address Mask Register 2                                  */
S    __IO uint32_t I2CADM3;       /* Offset: 0x30  I2C Slave Address Mask Register 3                                  */
S    __I  uint32_t RESERVED0[2]; 
S    __IO uint32_t I2CWKUPCON;    /* Offset: 0x3C  I2C Wake Up Control Register                                       */
S    __IO uint32_t I2CWKUPSTS;    /* Offset: 0x40  I2C Wake Up Status Register                                        */
S
S} I2C_T;
S
S
S
S/** @addtogroup I2C_CONST I2C Bit Field Definition
S  Constant Definitions for I2C Controller
S  @{
S */
S
S/* I2C I2CON Bit Field Definitions */
S#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C_T::I2CON: EI Position */
S#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C_T::I2CON: EI Mask */
S
S#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C_T::I2CON: ENS1 Position */
S#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C_T::I2CON: ENS1 Mask */
S
S#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C_T::I2CON: STA Position */
S#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C_T::I2CON: STA Mask */
S
S#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C_T::I2CON: STO Position */
S#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C_T::I2CON: STO Mask */
S
S#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C_T::I2CON: SI Position */
S#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C_T::I2CON: SI Mask */
S
S#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C_T::I2CON: AA Position */
S#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C_T::I2CON: AA Mask */
S
S/* I2C I2CADDR Bit Field Definitions */
S#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C_T::I2CADDR1: I2CADDR Position */
S#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C_T::I2CADDR1: I2CADDR Mask */
S
S#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C_T::I2CADDR1: GC Position */
S#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C_T::I2CADDR1: GC Mask */
S
S/* I2C I2CDAT Bit Field Definitions */
S#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C_T::I2CDAT: I2CDAT Position */
S#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C_T::I2CDAT: I2CDAT Mask */
S
S/* I2C I2CSTATUS Bit Field Definitions */
S#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C_T::I2CSTATUS: I2CSTATUS Position */
S#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C_T::I2CSTATUS: I2CSTATUS Mask */
S
S/* I2C I2CLK Bit Field Definitions */
S#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C_T::I2CLK: I2CLK Position */
S#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C_T::I2CLK: I2CLK Mask */
S
S/* I2C I2CTOC Bit Field Definitions */
S#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C_T::I2CTOC: ENTI Position */
S#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C_T::I2CTOC: ENTI Mask */
S
S#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C_T::I2CTOC: DIV4 Position */
S#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C_T::I2CTOC: DIV4 Mask */
S
S#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C_T::I2CTOC: TIF Position */
S#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C_T::I2CTOC: TIF Mask */
S
S/* I2C I2CADM Bit Field Definitions */
S#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C_T::I2CADM0: I2CADM Position */
S#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C_T::I2CADM0: I2CADM Mask */
S
S/* I2C I2CWKUPCON Bit Field Definitions */
S#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C_T::I2CWKUPCON: WKUPEN Position */
S#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C_T::I2CWKUPCON: WKUPEN Mask */
S
S/* I2C I2CWKUPSTS Bit Field Definitions */
S#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C_T::I2CWKUPSTS: WKUPIF Position */
S#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C_T::I2CWKUPSTS: WKUPIF Mask */
S
S/**@}*/ /* I2C_CONST */
S/**@}*/ /* I2C */
S
S
S
S/*----------------------------- PWM Controller -------------------------------*/
S
S/** @addtogroup PWM PWM Controller(PWM)
S  Memory Mapped Structure for PWM Generator and Capture Timer
S  @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var PWM_T::PPR
S * Offset: 0x00  PWM Pre-Scale Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CP01      |Clock pre-scalar 0(PWM counter 0 & 1 for group A and PWM counter 4 & 5 for group B)
S * |        |          |Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM counter
S * |        |          |If CP01=0, then the pre-scalar 0 output clock will be stopped. So corresponding PWM
S * |        |          |counter will be stopped also.
S * |[15:8]  |CP23      |Clock pre-scalar 2(PWM counter 2 & 3 for group A and PWM counter 6 & 7 for group B)
S * |        |          |Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM counter
S * |        |          |If CP23=0, then the pre-scalar 2 output clock will be stopped. So corresponding PWM
S * |        |          |counter will be stopped also.
S * |[23:16] |DZI01     |Dead zone interval register for pair of channel 0 and channel 1(PWM0 and PWM1 pair
S * |        |          |for PWM group A, PWM4 and PWM5 pair for PWM group B)
S * |        |          |These 8 bits determine dead zone length.
S * |        |          |The unit time of dead zone length is received from corresponding CSR bits.
S * |[31:24] |DZI23     |Dead zone interval register for pair of channel 2 and channel 3(PWM2 and PWM3 pair
S * |        |          |for PWM group A, PWM6 and PWM7 pair for PWM group B)
S * |        |          |These 8 bits determine dead zone length.
S * |        |          |The unit time of dead zone length is received from corresponding CSR bits.
S * @var PWM_T::CSR
S * Offset: 0x04  PWM Clock Source Divider Select Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |CSR0      |Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
S * |        |          |Select clock input for timer.
S * |        |          |(Table is the same as CSR3)
S * |[6:4]   |CSR1      |Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
S * |        |          |Select clock input for timer.
S * |        |          |(Table is the same as CSR3)
S * |[10:8]  |CSR2      |Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
S * |        |          |Select clock input for timer.
S * |        |          |(Table is the same as CSR3)
S * |[14:12] |CSR3      |Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
S * |        |          |Select clock input for timer.
S * |        |          |CSRx[2:0] = Input clock divider
S * |        |          |100 = 1
S * |        |          |011 = 16
S * |        |          |010 = 8
S * |        |          |001 = 4
S * |        |          |000 = 2
S * @var PWM_T::PCR
S * Offset: 0x08  PWM Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CH0EN     |PWM-Timer 0 Enable/Disable Start Run (PWM timer 0 for group A and PWM timer 4 for group B)
S * |        |          |1 = Enable corresponding PWM-Timer Start Run
S * |        |          |0 = Stop corresponding PWM-Timer Running
S * |[2]     |CH0INV    |PWM-Timer 0 Output Inverter ON/OFF(PWM timer 0 for group A and PWM timer 4 for group B)
S * |        |          |1 = Inverter ON
S * |        |          |0 = Inverter OFF
S * |[3]     |CH0MOD    |PWM-Timer 0 Auto-reload/One-Shot Mode(PWM timer 0 for group A and PWM timer 4
S * |        |          |for group B)
S * |        |          |1 = Auto-reload Mode
S * |        |          |0 = One-Shot Mode
S * |        |          |Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.
S * |[4]     |DZEN01    |Dead-Zone 0 Generator Enable/Disable(PWM0 and PWM1 pair for PWM group A,
S * |        |          |PWM4 and PWM5 pair for PWM group B)
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a
S * |        |          |complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a
S * |        |          |complementary pair for PWM group B.
S * |[5]     |DZEN23    |Dead-Zone 2 Generator Enable/Disable(PWM2 and PWM3 pair for PWM group A,
S * |        |          |PWM6 and PWM7 pair for PWM group B)
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a
S * |        |          |complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a
S * |        |          |complementary pair for PWM group B.
S * |[8]     |CH1EN     |PWM-Timer 1 Enable/Disable Start Run (PWM timer 1 for group A and PWM timer 5 for
S * |        |          |group B)
S * |        |          |1 = Enable corresponding PWM-Timer Start Run
S * |        |          |0 = Stop corresponding PWM-Timer Running
S * |[10]    |CH1INV    |PWM-Timer 1 Output Inverter ON/OFF(PWM timer 1 for group A and PWM timer 5 for
S * |        |          |group B)
S * |        |          |1 = Inverter ON
S * |        |          |0 = Inverter OFF
S * |[11]    |CH1MOD    |PWM-Timer 1 Auto-reload/One-Shot Mode(PWM timer 1 for group A and PWM timer 5
S * |        |          |for group B)
S * |        |          |1 = Auto-reload Mode
S * |        |          |0 = One-Shot Mode
S * |        |          |Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.
S * |[16]    |CH2EN     |PWM-Timer 2 Enable/Disable Start Run (PWM timer 2 for group A and PWM timer 6 for
S * |        |          |group B)
S * |        |          |1 = Enable corresponding PWM-Timer Start Run
S * |        |          |0 = Stop corresponding PWM-Timer Running
S * |[18]    |CH2INV    |PWM-Timer 2 Output Inverter ON/OFF(PWM timer 2 for group A and PWM timer 6 for
S * |        |          |group B)
S * |        |          |1 = Inverter ON
S * |        |          |0 = Inverter OFF
S * |[19]    |CH2MOD    |PWM-Timer 2 Auto-reload/One-Shot Mode(PWM timer 2 for group A and PWM timer 6
S * |        |          |for group B)
S * |        |          |1 = Auto-reload Mode
S * |        |          |0 = One-Shot Mode
S * |        |          |Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.
S * |[24]    |CH3EN     |PWM-Timer 3 Enable/Disable Start Run (PWM timer 3 for group A and PWM timer 7 for
S * |        |          |group B)
S * |        |          |1 = Enable corresponding PWM-Timer Start Run
S * |        |          |0 = Stop corresponding PWM-Timer Running
S * |[26]    |CH3INV    |PWM-Timer 3 Output Inverter ON/OFF(PWM timer 3 for group A and PWM timer 7 for
S * |        |          |group B)
S * |        |          |1 = Inverter ON
S * |        |          |0 = Inverter OFF
S * |[27]    |CH3MOD    |PWM-Timer 3 Auto-reload/One-Shot Mode(PWM timer 3 for group A and PWM timer 7
S * |        |          |for group B)
S * |        |          |1 = Auto-reload Mode
S * |        |          |0 = One-Shot Mode
S * |        |          |Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.
S * @var PWM_T::CNR0
S * Offset: 0x0C  PWM Counter 0/Timer 0 Loaded Value
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CNR       |PWM Counter/Timer Loaded Value
S * |        |          |CNR determines the PWM period.
S * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
S * |        |          |45 or 67, depends on selected PWM channel.
S * |        |          |Duty ratio = (CMR+1)/(CNR+1).
S * |        |          |CMR >= CNR: PWM output is always high.
S * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
S * |        |          |(Unit = one PWM clock cycle)
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::CMR0
S * Offset: 0x10  PWM Comparator 0 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CMR       |PWM Comparator Register
S * |        |          |CNR determines the PWM duty.
S * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
S * |        |          |45 or 67, depends on selected PWM channel.
S * |        |          |Duty ratio = (CMR+1)/(CNR+1).
S * |        |          |CMR >= CNR: PWM output is always high.
S * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
S * |        |          |(Unit = one PWM clock cycle)
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::PDR0
S * Offset: 0x14  PWM Data 0 Register(current counter 0 value)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PDR       |PWM Data Register
S * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S * @var PWM_T::CNR1
S * Offset: 0x18  PWM Counter 1/Timer 1 Loaded Value
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CNR       |PWM Counter/Timer Loaded Value
S * |        |          |CNR determines the PWM period.
S * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
S * |        |          |45 or 67, depends on selected PWM channel.
S * |        |          |Duty ratio = (CMR+1)/(CNR+1).
S * |        |          |CMR >= CNR: PWM output is always high.
S * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
S * |        |          |(Unit = one PWM clock cycle)
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::CMR1
S * Offset: 0x1C  PWM Comparator 1 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CMR       |PWM Comparator Register
S * |        |          |CNR determines the PWM duty.
S * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
S * |        |          |45 or 67, depends on selected PWM channel.
S * |        |          |Duty ratio = (CMR+1)/(CNR+1).
S * |        |          |CMR >= CNR: PWM output is always high.
S * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
S * |        |          |(Unit = one PWM clock cycle)
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::PDR1
S * Offset: 0x20  PWM Data 1 Register(current counter 1 value)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PDR       |PWM Data Register
S * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S * @var PWM_T::CNR2
S * Offset: 0x24  PWM Counter 2/Timer 2 Loaded Value
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CNR       |PWM Counter/Timer Loaded Value
S * |        |          |CNR determines the PWM period.
S * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
S * |        |          |45 or 67, depends on selected PWM channel.
S * |        |          |Duty ratio = (CMR+1)/(CNR+1).
S * |        |          |CMR >= CNR: PWM output is always high.
S * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
S * |        |          |(Unit = one PWM clock cycle)
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::CMR2
S * Offset: 0x28  PWM Comparator 2 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CMR       |PWM Comparator Register
S * |        |          |CNR determines the PWM duty.
S * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
S * |        |          |45 or 67, depends on selected PWM channel.
S * |        |          |Duty ratio = (CMR+1)/(CNR+1).
S * |        |          |CMR >= CNR: PWM output is always high.
S * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
S * |        |          |(Unit = one PWM clock cycle)
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::PDR2
S * Offset: 0x2C  PWM Data 2 Register(current counter 2 value)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PDR       |PWM Data Register
S * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S * @var PWM_T::CNR3
S * Offset: 0x30  PWM Counter 3/Timer 3 Loaded Value
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CNR       |PWM Counter/Timer Loaded Value
S * |        |          |CNR determines the PWM period.
S * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
S * |        |          |45 or 67, depends on selected PWM channel.
S * |        |          |Duty ratio = (CMR+1)/(CNR+1).
S * |        |          |CMR >= CNR: PWM output is always high.
S * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
S * |        |          |(Unit = one PWM clock cycle)
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::CMR3
S * Offset: 0x34  PWM Comparator 3 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CMR       |PWM Comparator Register
S * |        |          |CNR determines the PWM duty.
S * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23,
S * |        |          |45 or 67, depends on selected PWM channel.
S * |        |          |Duty ratio = (CMR+1)/(CNR+1).
S * |        |          |CMR >= CNR: PWM output is always high.
S * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
S * |        |          |(Unit = one PWM clock cycle)
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::PDR3
S * Offset: 0x38  PWM Data 3 Register(current counter 3 value)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PDR       |PWM Data Register
S * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S * @var PWM_T::PIER
S * Offset: 0x40  PWM Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWMIE0    |PWM channel 0 Interrupt Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |[1]     |PWMIE1    |PWM channel 1 Interrupt Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |[2]     |PWMIE2    |PWM channel 2 Interrupt Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * |[3]     |PWMIE3    |PWM channel 3 Interrupt Enable
S * |        |          |1 = Enable
S * |        |          |0 = Disable
S * @var PWM_T::PIIR
S * Offset: 0x44  PWM Interrupt Indication Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWMIF0    |PWM channel 0 Interrupt Status
S * |        |          |Flag is set by hardware when PWM0 down counter reaches zero, software can clear this
S * |        |          |bit by writing a one to it.
S * |[1]     |PWMIF1    |PWM channel 1 Interrupt Status
S * |        |          |Flag is set by hardware when PWM1 down counter reaches zero, software can clear this
S * |        |          |bit by writing a one to it.
S * |[2]     |PWMIF2    |PWM channel 2 Interrupt Status
S * |        |          |Flag is set by hardware when PWM2 down counter reaches zero, software can clear this
S * |        |          |bit by writing a one to it.
S * |[3]     |PWMIF3    |PWM channel 3 Interrupt Status
S * |        |          |Flag is set by hardware when PWM3 down counter reaches zero, software can clear this
S * |        |          |bit by writing a one to it.
S * @var PWM_T::CCR0
S * Offset: 0x50  Capture 0/1 Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |INV0      |PWM Group Channel 0 Inverter ON/OFF
S * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
S * |        |          |0 = Inverter OFF
S * |[1]     |CRL_IE0   |PWM Group Channel 0 Rising Latch Interrupt Enable ON/OFF
S * |        |          |1 = Enable rising latch interrupt
S * |        |          |0 = Disable rising latch interrupt
S * |        |          |When Enable, if Capture detects PWM group channel 0 has rising transition, Capture
S * |        |          |issues an Interrupt.
S * |[2]     |CFL_IE0   |PWM Group Channel 0 Falling Latch Interrupt Enable ON/OFF
S * |        |          |1 = Enable falling latch interrupt
S * |        |          |0 = Disable falling latch interrupt
S * |        |          |When Enable, if Capture detects PWM group channel 0 has falling transition, Capture
S * |        |          |issues an Interrupt.
S * |[3]     |CAPCH0EN  |Capture Channel 0 transition Enable/Disable
S * |        |          |1 = Enable capture function on PWM group channel 0.
S * |        |          |0 = Disable capture function on PWM group channel 0
S * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) 
S * |        |          |and CFLR (Falling latch).
S * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group
S * |        |          |channel 0 Interrupt.
S * |[4]     |CAPIF0    |Capture0 Interrupt Indication Flag
S * |        |          |If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs
S * |        |          |at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause
S * |        |          |CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1).
S * |        |          |This flag is clear by software with a write 1 to itself.
S * |[6]     |CRLRI0    |CRLR0 Latched Indicator Bit
S * |        |          |When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of
S * |        |          |PWM down-counter and this bit is set by hardware.
S * |        |          |Clear this bit by writing a one to it.
S * |[7]     |CFLRI0    |CFLR0 Latched Indicator Bit
S * |        |          |When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of
S * |        |          |PWM down-counter and this bit is set by hardware.
S * |        |          |Clear this bit by writing a one to it.
S * |[16]    |INV1      |PWM Group Channel 1 Inverter ON/OFF
S * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
S * |        |          |0 = Inverter OFF
S * |[17]    |CRL_IE1   |PWM Group Channel 1 Rising Latch Interrupt Enable ON/OFF
S * |        |          |1 = Enable rising latch interrupt
S * |        |          |0 = Disable rising latch interrupt
S * |        |          |When Enable, if Capture detects PWM group channel 1 has rising transition, Capture
S * |        |          |issues an Interrupt.
S * |[18]    |CFL_IE1   |PWM Group Channel 1 Falling Latch Interrupt Enable ON/OFF
S * |        |          |1 = Enable falling latch interrupt
S * |        |          |0 = Disable falling latch interrupt
S * |        |          |When Enable, if Capture detects PWM group channel 1 has falling transition, Capture
S * |        |          |issues an Interrupt.
S * |[19]    |CAPCH1EN  |Capture Channel 1 transition Enable/Disable
S * |        |          |1 = Enable capture function on PWM group channel 1.
S * |        |          |0 = Disable capture function on PWM group channel 1
S * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising
S * |        |          |latch) and CFLR (Falling latch).
S * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group
S * |        |          |channel 1 Interrupt.
S * |[20]    |CAPIF1    |Capture1 Interrupt Indication Flag
S * |        |          |If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs
S * |        |          |at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause
S * |        |          |CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1).
S * |        |          |This flag is clear by software with a write 1 to itself.
S * |[22]    |CRLRI1    |CRLR1 Latched Indicator Bit
S * |        |          |When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of
S * |        |          |PWM down-counter and this bit is set by hardware.
S * |        |          |Clear this bit by writing a one to it.
S * |[23]    |CFLRI1    |CFLR1 Latched Indicator Bit
S * |        |          |When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of
S * |        |          |PWM down-counter and this bit is set by hardware.
S * |        |          |Clear this bit by writing a one to it.
S * @var PWM_T::CCR2
S * Offset: 0x54  Capture 2/3 Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |INV2      |PWM Group Channel 2 Inverter ON/OFF
S * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
S * |        |          |0 = Inverter OFF
S * |[1]     |CRL_IE2   |PWM Group Channel 2 Rising Latch Interrupt Enable ON/OFF
S * |        |          |1 = Enable rising latch interrupt
S * |        |          |0 = Disable rising latch interrupt
S * |        |          |When Enable, if Capture detects PWM group channel 2 has rising transition, Capture
S * |        |          |issues an Interrupt.
S * |[2]     |CFL_IE2   |PWM Group Channel 2 Falling Latch Interrupt Enable ON/OFF
S * |        |          |1 = Enable falling latch interrupt
S * |        |          |0 = Disable falling latch interrupt
S * |        |          |When Enable, if Capture detects PWM group channel 2 has falling transition, Capture
S * |        |          |issues an Interrupt.
S * |[3]     |CAPCH2EN  |Capture Channel 2 transition Enable/Disable
S * |        |          |1 = Enable capture function on PWM group channel 2.
S * |        |          |0 = Disable capture function on PWM group channel 2
S * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising
S * |        |          |latch) and CFLR (Falling latch).
S * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group
S * |        |          |channel 2 Interrupt.
S * |[4]     |CAPIF2    |Capture2 Interrupt Indication Flag
S * |        |          |If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs
S * |        |          |at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause
S * |        |          |CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1).
S * |        |          |This flag is clear by software with a write 1 to itself.
S * |[6]     |CRLRI2    |CRLR2 Latched Indicator Bit
S * |        |          |When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of
S * |        |          |PWM down-counter and this bit is set by hardware.
S * |        |          |Clear this bit by writing a one to it.
S * |[7]     |CFLRI2    |CFLR2 Latched Indicator Bit
S * |        |          |When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of
S * |        |          |PWM down-counter and this bit is set by hardware.
S * |        |          |Clear this bit by writing a one to it.
S * |[16]    |INV3      |PWM Group Channel 3 Inverter ON/OFF
S * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
S * |        |          |0 = Inverter OFF
S * |[17]    |CRL_IE3   |PWM Group Channel 3 Rising Latch Interrupt Enable ON/OFF
S * |        |          |1 = Enable rising latch interrupt
S * |        |          |0 = Disable rising latch interrupt
S * |        |          |When Enable, if Capture detects PWM group channel 3 has rising transition, Capture
S * |        |          |issues an Interrupt.
S * |[18]    |CFL_IE3   |PWM Group Channel 3 Falling Latch Interrupt Enable ON/OFF
S * |        |          |1 = Enable falling latch interrupt
S * |        |          |0 = Disable falling latch interrupt
S * |        |          |When Enable, if Capture detects PWM group channel 3 has falling transition, Capture
S * |        |          |issues an Interrupt.
S * |[19]    |CAPCH3EN  |Capture Channel 3 transition Enable/Disable
S * |        |          |1 = Enable capture function on PWM group channel 3.
S * |        |          |0 = Disable capture function on PWM group channel 3
S * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising
S * |        |          |latch) and CFLR (Falling latch).
S * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group
S * |        |          |channel 3 Interrupt.
S * |[20]    |CAPIF3    |Capture3 Interrupt Indication Flag
S * |        |          |If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs
S * |        |          |at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause
S * |        |          |CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1).
S * |        |          |This flag is clear by software with a write 1 to itself.
S * |[22]    |CRLRI3    |CRLR3 Latched Indicator Bit
S * |        |          |When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of
S * |        |          |PWM down-counter and this bit is set by hardware.
S * |        |          |Clear this bit by writing a one to it.
S * |[23]    |CFLRI3    |CFLR3 Latched Indicator Bit
S * |        |          |When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of
S * |        |          |PWM down-counter and this bit is set by hardware.
S * |        |          |Clear this bit by writing a one to it.
S * @var PWM_T::CRLR0
S * Offset: 0x58  Capture 0 Rising Latch Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CRLR      |Capture Rising Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S * @var PWM_T::CFLR0
S * Offset: 0x5C  Capture 0 Falling Latch Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CFLR      |Capture Falling Latch Register
S * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
S * @var PWM_T::CRLR1
S * Offset: 0x60  Capture 1 Rising Latch Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CRLR      |Capture Rising Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S * @var PWM_T::CFLR1
S * Offset: 0x64  Capture 1 Falling Latch Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CFLR      |Capture Falling Latch Register
S * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
S * @var PWM_T::CRLR2
S * Offset: 0x68  Capture 2 Rising Latch Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CRLR      |Capture Rising Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S * @var PWM_T::CFLR2
S * Offset: 0x6C  Capture 2 Falling Latch Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CFLR      |Capture Falling Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
S * @var PWM_T::CRLR3
S * Offset: 0x70  Capture 3 Rising Latch Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CRLR      |Capture Rising Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S * @var PWM_T::CFLR3
S * Offset: 0x74  Capture 3 Falling Latch Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CFLR      |Capture Falling Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
S * @var PWM_T::CAPENR
S * Offset: 0x78  Capture Input Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |CAPENR    |Capture Input Enable Register
S * |        |          |There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs ON or
S * |        |          |OFF.
S * |        |          |0 = OFF (PWMx multi-function pin input does not affect input capture function.)
S * |        |          |1 = (PWMx multi-function pin input will affect its input capture function.)
S * |        |          |CAPENR
S * |        |          |Bit 3210 for PWM group A
S * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [0]
S * |        |          |Bit xx1x -> Capture channel 1 is from P2 [1]
S * |        |          |Bit x1xx -> Capture channel 2 is from P2 [2]
S * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [3]
S * |        |          |Bit 3210 for PWM group B
S * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [4]
S * |        |          |Bit xx1x -> Capture channel 1 is from P2 [5]
S * |        |          |Bit x1xx -> Capture channel 2 is from P2 [6]
S * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [7]
S * @var PWM_T::POE
S * Offset: 0x7C  PWM Output Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWM0      |PWM Channel 0 Output Enable Register
S * |        |          |1 = Enable PWM channel 0 output to pin.
S * |        |          |0 = Disable PWM channel 0 output to pin.
S * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S * |[1]     |PWM1      |PWM Channel 1 Output Enable Register
S * |        |          |1 = Enable PWM channel 1 output to pin.
S * |        |          |0 = Disable PWM channel 1 output to pin.
S * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S * |[2]     |PWM2      |PWM Channel 2 Output Enable Register
S * |        |          |1 = Enable PWM channel 2 output to pin.
S * |        |          |0 = Disable PWM channel 2 output to pin.
S * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S * |[3]     |PWM3      |PWM Channel 3 Output Enable Register
S * |        |          |1 = Enable PWM channel 3 output to pin.
S * |        |          |0 = Disable PWM channel 3 output to pin.
S * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S * @var PWM_T::TCON
S * Offset: 0x80  PWM Trigger Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWM0PTEN  |Channel 0 PWM Period Trigger ADC Enable Register
S * |        |          |1 = Enable PWM channel 0 trigger ADC function
S * |        |          |0 = Disable PWM channel 0 trigger ADC function
S * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to underflow.
S * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
S * |        |          |when PWM counter up count to (CNR+1) or down count to underflow based on INT01PTYPE setting.
S * |        |          |1 = Enable PWM channel 0 output to pin.
S * |        |          |0 = Disable PWM channel 0 output to pin.
S * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S * |[1]     |PWM1PTEN  |Channel 1 PWM Period Trigger ADC Enable Register
S * |        |          |1 = Enable PWM channel 1 trigger ADC function
S * |        |          |0 = Disable PWM channel 1 trigger ADC function
S * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to underflow.
S * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
S * |        |          |when PWM counter up count to (CNR+1) or down count to underflow based on INT01PTYPE setting.
S * |[2]     |PWM2PTEN  |Channel 2 PWM Period Trigger ADC Enable Register
S * |        |          |1 = Enable PWM channel 2 trigger ADC function
S * |        |          |0 = Disable PWM channel 2 trigger ADC function
S * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to underflow.
S * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
S * |        |          |when PWM counter up count to (CNR+1) or down count to underflow based on INT23PTYPE setting.
S * |[3]     |PWM3PTEN  |Channel 3 PWM Period Trigger ADC Enable Register
S * |        |          |1 = Enable PWM channel 3 trigger ADC function
S * |        |          |0 = Disable PWM channel 3 trigger ADC function
S * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to underflow.
S * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
S * |        |          |when PWM counter up count to (CNR+1) or down count to underflow based on INT23PTYPE setting.
S * |[8]     |PWM0DTEN  |Channel 0 PWM Duty Trigger ADC Enable Register
S * |        |          |1 = Enable PWM channel 0 trigger ADC function
S * |        |          |0 = Disable PWM channel 0 trigger ADC function
S * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to match CMR.
S * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
S * |        |          |when PWM counter up count or down count to match CMR based on INT01DTYPE setting.
S * |[9]     |PWM1DTEN  |Channel 1 PWM Duty Trigger ADC Enable Register
S * |        |          |1 = Enable PWM channel 1 trigger ADC function
S * |        |          |0 = Disable PWM channel 1 trigger ADC function
S * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to match CMR.
S * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
S * |        |          |when PWM counter up count or down count to match CMR based on INT01DTYPE setting.
S * |[10]    |PWM2DTEN  |Channel 2 PWM Duty Trigger ADC Enable Register
S * |        |          |1 = Enable PWM channel 2 trigger ADC function
S * |        |          |0 = Disable PWM channel 2 trigger ADC function
S * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to match CMR.
S * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
S * |        |          |when PWM counter up count or down count to match CMR based on INT23DTYPE setting.
S * |[11]    |PWM3DTEN  |Channel 3 PWM Duty Trigger ADC Enable Register
S * |        |          |1 = Enable PWM channel 3 trigger ADC function
S * |        |          |0 = Disable PWM channel 3 trigger ADC function
S * |        |          |As PWM operating at edge-aligned mode, enable this bit can make PWM trigger ADC to start conversion when PWM counter down count to match CMR.
S * |        |          |As PWM operating at center-aligned mode, enable this bit can make PWM trigger ADC to start conversion
S * |        |          |when PWM counter up count or down count to match CMR based on INT23DTYPE setting.
S * @var PWM_T::TSTATUS
S * Offset: 0x84  PWM Trigger Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWM0TF    |PWM Channel 0 Trigger ADC Flag
S * |        |          |This bit is set to 1 by hardware when PWM0 trigger ADC condition matched. As this bit is set to 1,
S * |        |          |ADC will start conversion if ADC triggered source is selected by PWM.
S * |        |          |Software can write 1 to clear this bit.
S * |[1]     |PWM1TF    |PWM Channel 1 Trigger ADC Flag
S * |        |          |This bit is set to 1 by hardware when PWM1 trigger ADC condition matched. As this bit is set to 1,
S * |        |          |ADC will start conversion if ADC triggered source is selected by PWM.
S * |        |          |Software can write 1 to clear this bit.
S * |[2]     |PWM2TF    |PWM Channel 2 Trigger ADC Flag
S * |        |          |This bit is set to 1 by hardware when PWM2 trigger ADC condition matched. As this bit is set to 1,
S * |        |          |ADC will start conversion if ADC triggered source is selected by PWM.
S * |        |          |Software can write 1 to clear this bit.
S * |[3]     |PWM3TF    |PWM Channel 3 Trigger ADC Flag
S * |        |          |This bit is set to 1 by hardware when PWM3 trigger ADC condition matched. As this bit is set to 1,
S * |        |          |ADC will start conversion if ADC triggered source is selected by PWM.
S * |        |          |Software can write 1 to clear this bit.
S * @var PWM_T::PSCR
S * Offset: 0x98  PWM Synchronous Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8]     |PSSEN1    |PWM1 Synchronous Start Enable
S * |        |          |1 = PWM1 synchronous start enable.
S * |        |          |0 = PWM1 synchronous start disable.
S * |        |          |If this bit is set to 1, PWM-Timer1 will synchronous start with PWM-Timer0 when SW writes 1 to PCR.CH0EN in PWM group A.
S * |[16]    |PSSEN2    |PWM2 Synchronous Start Enable
S * |        |          |1 = PWM2 synchronous start enable.
S * |        |          |0 = PWM2 synchronous start disable.
S * |        |          |If this bit is set to 1, PWM-Timer2 will synchronous start with PWM-Timer0 when SW writes 1 to PCR.CH0EN in PWM group A.
S * |[24]    |PSSEN3    |PWM3 Synchronous Start Enable
S * |        |          |1 = PWM3 synchronous start enable.
S * |        |          |0 = PWM3 synchronous start disable.
S * |        |          |If this bit is set to 1, PWM-Timer3 will synchronous start with PWM-Timer0 when SW writes 1 to PCR.CH0EN in PWM group A.
S */
S
S    __IO uint32_t PPR;           /* Offset: 0x00  PWM Pre-Scale Register                                             */
S    __IO uint32_t CSR;           /* Offset: 0x04  PWM Clock Source Divider Select Register                           */
S    __IO uint32_t PCR;           /* Offset: 0x08  PWM Control Register                                               */
S    __IO uint32_t CNR0;          /* Offset: 0x0C  PWM Counter 0/Timer 0 Loaded Value                                 */
S    __IO uint32_t CMR0;          /* Offset: 0x10  PWM Comparator 0 Register                                          */
S    __I  uint32_t PDR0;          /* Offset: 0x14  PWM Data 0 Register(current counter 0 value)                       */
S    __IO uint32_t CNR1;          /* Offset: 0x18  PWM Counter 1/Timer 1 Loaded Value                                 */
S    __IO uint32_t CMR1;          /* Offset: 0x1C  PWM Comparator 1 Register                                          */
S    __I  uint32_t PDR1;          /* Offset: 0x20  PWM Data 1 Register(current counter 1 value)                       */
S    __IO uint32_t CNR2;          /* Offset: 0x24  PWM Counter 2/Timer 2 Loaded Value                                 */
S    __IO uint32_t CMR2;          /* Offset: 0x28  PWM Comparator 2 Register                                          */
S    __I  uint32_t PDR2;          /* Offset: 0x2C  PWM Data 2 Register(current counter 2 value)                       */
S    __IO uint32_t CNR3;          /* Offset: 0x30  PWM Counter 3/Timer 3 Loaded Value                                 */
S    __IO uint32_t CMR3;          /* Offset: 0x34  PWM Comparator 3 Register                                          */
S    __I  uint32_t PDR3;          /* Offset: 0x38  PWM Data 3 Register(current counter 3 value)                       */
S    __I  uint32_t RESERVE0;     
S    __IO uint32_t PIER;          /* Offset: 0x40  PWM Interrupt Enable Register                                      */
S    __IO uint32_t PIIR;          /* Offset: 0x44  PWM Interrupt Indication Register                                  */
S    __I  uint32_t RESERVE1[2];  
S    __IO uint32_t CCR0;          /* Offset: 0x50  Capture 0/1 Control Register                                       */
S    __IO uint32_t CCR2;          /* Offset: 0x54  Capture 2/3 Control Register                                       */
S    __IO uint32_t CRLR0;         /* Offset: 0x58  Capture 0 Rising Latch Register                                    */
S    __IO uint32_t CFLR0;         /* Offset: 0x5C  Capture 0 Falling Latch Register                                   */
S    __IO uint32_t CRLR1;         /* Offset: 0x60  Capture 1 Rising Latch Register                                    */
S    __IO uint32_t CFLR1;         /* Offset: 0x64  Capture 1 Falling Latch Register                                   */
S    __IO uint32_t CRLR2;         /* Offset: 0x68  Capture 2 Rising Latch Register                                    */
S    __IO uint32_t CFLR2;         /* Offset: 0x6C  Capture 2 Falling Latch Register                                   */
S    __IO uint32_t CRLR3;         /* Offset: 0x70  Capture 3 Rising Latch Register                                    */
S    __IO uint32_t CFLR3;         /* Offset: 0x74  Capture 3 Falling Latch Register                                   */
S    __IO uint32_t CAPENR;        /* Offset: 0x78  Capture Input Enable Register                                      */
S    __IO uint32_t POE;           /* Offset: 0x7C  PWM Output Enable Register                                         */
S    __IO uint32_t TCON;          /* Offset: 0x80  PWM Trigger Control Register                                       */
S    __IO uint32_t TSTATUS;       /* Offset: 0x84  PWM Trigger Status Register                                        */
S    __I  uint32_t RESERVE2[4];  
S    __IO uint32_t PSCR;          /* Offset: 0x98  PWM Synchronous Control Register                                   */
S
S} PWM_T;
S
S
S
S/** @addtogroup PWM_CONST PWM Bit Field Definition
S  Constant Definitions for PWM Controller
S  @{
S */
S
S/* PWM PPR Bit Field Definitions */
S#define PWM_PPR_DZI23_Pos                       24                                  /*!< PWM_T::PPR: DZI23 Position */
S#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)       /*!< PWM_T::PPR: DZI23 Mask */
S
S#define PWM_PPR_DZI01_Pos                       16                                  /*!< PWM_T::PPR: DZI01 Position */
S#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)       /*!< PWM_T::PPR: DZI01 Mask */
S
S#define PWM_PPR_CP23_Pos                        8                                   /*!< PWM_T::PPR: CP23 Position */
S#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)        /*!< PWM_T::PPR: CP23 Mask */
S
S#define PWM_PPR_CP01_Pos                        0                                   /*!< PWM_T::PPR: CP01 Position */
S#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)        /*!< PWM_T::PPR: CP01 Mask */
S
S/* PWM CSR Bit Field Definitions */
S#define PWM_CSR_CSR3_Pos                        12                                  /*!< PWM_T::CSR: CSR3 Position */
S#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)           /*!< PWM_T::CSR: CSR3 Mask */
S
S#define PWM_CSR_CSR2_Pos                        8                                   /*!< PWM_T::CSR: CSR2 Position */
S#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)           /*!< PWM_T::CSR: CSR2 Mask */
S
S#define PWM_CSR_CSR1_Pos                        4                                   /*!< PWM_T::CSR: CSR1 Position */
S#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)           /*!< PWM_T::CSR: CSR1 Mask */
S
S#define PWM_CSR_CSR0_Pos                        0                                   /*!< PWM_T::CSR: CSR0 Position */
S#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)           /*!< PWM_T::CSR: CSR0 Mask */
S
S/* PWM PCR Bit Field Definitions */
S#define PWM_PCR_PWM23TYPE_Pos                   31                                  /*!< PWM_T::PCR: PWM23TYPE Position */
S#define PWM_PCR_PWM23TYPE_Msk                   (1ul << PWM_PCR_PWM23TYPE_Pos)      /*!< PWM_T::PCR: PWM23TYPE Mask */
S
S#define PWM_PCR_PWM01TYPE_Pos                   30                                  /*!< PWM_T::PCR: PWM01TYPE Position */
S#define PWM_PCR_PWM01TYPE_Msk                   (1ul << PWM_PCR_PWM01TYPE_Pos)      /*!< PWM_T::PCR: PWM01TYPE Mask */
S
S#define PWM_PCR_CH3MOD_Pos                      27                                  /*!< PWM_T::PCR: CH3MOD Position */
S#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)         /*!< PWM_T::PCR: CH3MOD Mask */
S
S#define PWM_PCR_CH3INV_Pos                      26                                  /*!< PWM_T::PCR: CH3INV Position */
S#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)         /*!< PWM_T::PCR: CH3INV Mask */
S
S#define PWM_PCR_CH3PINV_Pos                     25                                  /*!< PWM_T::PCR: CH3PINV Position */
S#define PWM_PCR_CH3PINV_Msk                     (1ul << PWM_PCR_CH3PINV_Pos)        /*!< PWM_T::PCR: CH3PINV Mask */
S
S#define PWM_PCR_CH3EN_Pos                       24                                  /*!< PWM_T::PCR: CH3EN Position */
S#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)          /*!< PWM_T::PCR: CH3EN Mask */
S
S#define PWM_PCR_CH2MOD_Pos                      19                                  /*!< PWM_T::PCR: CH2MOD Position */
S#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)         /*!< PWM_T::PCR: CH2MOD Mask */
S
S#define PWM_PCR_CH2INV_Pos                      18                                  /*!< PWM_T::PCR: CH2INV Position */
S#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)         /*!< PWM_T::PCR: CH2INV Mask */
S
S#define PWM_PCR_CH2PINV_Pos                     17                                  /*!< PWM_T::PCR: CH2PINV Position */
S#define PWM_PCR_CH2PINV_Msk                     (1ul << PWM_PCR_CH2PINV_Pos)        /*!< PWM_T::PCR: CH2PINV Mask */
S
S#define PWM_PCR_CH2EN_Pos                       16                                  /*!< PWM_T::PCR: CH2EN Position */
S#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)          /*!< PWM_T::PCR: CH2EN Mask */
S
S#define PWM_PCR_CH1MOD_Pos                      11                                  /*!< PWM_T::PCR: CH1MOD Position */
S#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)         /*!< PWM_T::PCR: CH1MOD Mask */
S
S#define PWM_PCR_CH1INV_Pos                      10                                  /*!< PWM_T::PCR: CH1INV Position */
S#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)         /*!< PWM_T::PCR: CH1INV Mask */
S
S#define PWM_PCR_CH1PINV_Pos                     9                                   /*!< PWM_T::PCR: CH1PINV Position */
S#define PWM_PCR_CH1PINV_Msk                     (1ul << PWM_PCR_CH1PINV_Pos)        /*!< PWM_T::PCR: CH1PINV Mask */
S
S#define PWM_PCR_CH1EN_Pos                       8                                   /*!< PWM_T::PCR: CH1EN Position */
S#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)          /*!< PWM_T::PCR: CH1EN Mask */
S
S#define PWM_PCR_DZEN23_Pos                      5                                   /*!< PWM_T::PCR: DZEN23 Position */
S#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)         /*!< PWM_T::PCR: DZEN23 Mask */
S
S#define PWM_PCR_DZEN01_Pos                      4                                   /*!< PWM_T::PCR: DZEN01 Position */
S#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)         /*!< PWM_T::PCR: DZEN01 Mask */
S
S#define PWM_PCR_CH0MOD_Pos                      3                                   /*!< PWM_T::PCR: CH0MOD Position */
S#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)         /*!< PWM_T::PCR: CH0MOD Mask */
S
S#define PWM_PCR_CH0INV_Pos                      2                                   /*!< PWM_T::PCR: CH0INV Position */
S#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)         /*!< PWM_T::PCR: CH0INV Mask */
S
S#define PWM_PCR_CH0PINV_Pos                      1                                  /*!< PWM_T::PCR: CH0PINV Position */
S#define PWM_PCR_CH0PINV_Msk                     (1ul << PWM_PCR_CH0PINV_Pos)        /*!< PWM_T::PCR: CH0PINV Mask */
S
S#define PWM_PCR_CH0EN_Pos                       0                                   /*!< PWM_T::PCR: CH0EN Position */
S#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM_T::PCR: CH0EN Mask */
S
S/* PWM CNR Bit Field Definitions */
S#define PWM_CNR_CNR_Pos                         0                                   /*!< PWM_T::CNR0: CNR Position */
S#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)       /*!< PWM_T::CNR0: CNR Mask */
S
S/* PWM CMR Bit Field Definitions */
S#define PWM_CMR_CMR_Pos                         0                                   /*!< PWM_T::CMR0: CMR Position */
S#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)       /*!< PWM_T::CMR0: CMR Mask */
S
S/* PWM PDR Bit Field Definitions */
S#define PWM_PDR_PDR_Pos                         0                                   /*!< PWM_T::PDR0: PDR Position */
S#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)       /*!< PWM_T::PDR0: PDR Mask */
S
S
S/* PWM PIER Bit Field Definitions */
S#define PWM_PIER_INT23DTYPE_Pos                 25                                  /*!< PWM_T::PIER: INT23DTYPE Position */
S#define PWM_PIER_INT23DTYPE_Msk                 (1ul << PWM_PIER_INT23DTYPE_Pos)    /*!< PWM_T::PIER: INT23DTYPE Mask */
S
S#define PWM_PIER_INT01DTYPE_Pos                 24                                  /*!< PWM_T::PIER: INT01DTYPE Position */
S#define PWM_PIER_INT01DTYPE_Msk                 (1ul << PWM_PIER_INT01DTYPE_Pos)    /*!< PWM_T::PIER: INT01DTYPE Mask */
S
S#define PWM_PIER_INT23TYPE_Pos                  17                                  /*!< PWM_T::PIER: INT23TYPE Position */
S#define PWM_PIER_INT23TYPE_Msk                  (1ul << PWM_PIER_INT23TYPE_Pos)     /*!< PWM_T::PIER: INT23TYPE Mask */
S
S#define PWM_PIER_INT01TYPE_Pos                  16                                  /*!< PWM_T::PIER: INT01TYPE Position */
S#define PWM_PIER_INT01TYPE_Msk                  (1ul << PWM_PIER_INT01TYPE_Pos)     /*!< PWM_T::PIER: INT01TYPE Mask */
S
S#define PWM_PIER_PWMDIE3_Pos                    11                                  /*!< PWM_T::PIER: PWMDIE3 Position */
S#define PWM_PIER_PWMDIE3_Msk                    (1ul << PWM_PIER_PWMDIE3_Pos)       /*!< PWM_T::PIER: PWMDIE3 Mask */
S
S#define PWM_PIER_PWMDIE2_Pos                    10                                  /*!< PWM_T::PIER: PWMDIE2 Position */
S#define PWM_PIER_PWMDIE2_Msk                    (1ul << PWM_PIER_PWMDIE2_Pos)       /*!< PWM_T::PIER: PWMDIE2 Mask */
S
S#define PWM_PIER_PWMDIE1_Pos                    9                                   /*!< PWM_T::PIER: PWMDIE1 Position */
S#define PWM_PIER_PWMDIE1_Msk                     (1ul << PWM_PIER_PWMDIE1_Pos)      /*!< PWM_T::PIER: PWMDIE1 Mask */
S
S#define PWM_PIER_PWMDIE0_Pos                    8                                   /*!< PWM_T::PIER: PWMDIE0 Position */
S#define PWM_PIER_PWMDIE0_Msk                    (1ul << PWM_PIER_PWMDIE0_Pos)       /*!< PWM_T::PIER: PWMDIE0 Mask */
S
S#define PWM_PIER_PWMIE3_Pos                     3                                   /*!< PWM_T::PIER: PWMIE3 Position */
S#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)        /*!< PWM_T::PIER: PWMIE3 Mask */
S
S#define PWM_PIER_PWMIE2_Pos                     2                                   /*!< PWM_T::PIER: PWMIE2 Position */
S#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)        /*!< PWM_T::PIER: PWMIE2 Mask */
S
S#define PWM_PIER_PWMIE1_Pos                     1                                   /*!< PWM_T::PIER: PWMIE1 Position */
S#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)        /*!< PWM_T::PIER: PWMIE1 Mask */
S
S#define PWM_PIER_PWMIE0_Pos                     0                                   /*!< PWM_T::PIER: PWMIE0 Position */
S#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)        /*!< PWM_T::PIER: PWMIE0 Mask */
S
S/* PWM PIIR Bit Field Definitions */
S#define PWM_PIIR_PWMDIF3_Pos                    11                                  /*!< PWM_T::PIIR: PWMDIF3 Position */
S#define PWM_PIIR_PWMDIF3_Msk                    (1ul << PWM_PIIR_PWMDIF3_Pos)       /*!< PWM_T::PIIR: PWMDIF3 Mask */
S
S#define PWM_PIIR_PWMDIF2_Pos                    10                                  /*!< PWM_T::PIIR: PWMDIF2 Position */
S#define PWM_PIIR_PWMDIF2_Msk                    (1ul << PWM_PIIR_PWMDIF2_Pos)       /*!< PWM_T::PIIR: PWMDIF2 Mask */
S
S#define PWM_PIIR_PWMDIF1_Pos                    9                                   /*!< PWM_T::PIIR: PWMDIF1 Position */
S#define PWM_PIIR_PWMDIF1_Msk                    (1ul << PWM_PIIR_PWMDIF1_Pos)       /*!< PWM_T::PIIR: PWMDIF1 Mask */
S
S#define PWM_PIIR_PWMDIF0_Pos                    8                                   /*!< PWM_T::PIIR: PWMDIF0 Position */
S#define PWM_PIIR_PWMDIF0_Msk                    (1ul << PWM_PIIR_PWMDIF0_Pos)       /*!< PWM_T::PIIR: PWMDIF0 Mask */
S
S#define PWM_PIIR_PWMIF3_Pos                     3                                   /*!< PWM_T::PIIR: PWMIF3 Position */
S#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)        /*!< PWM_T::PIIR: PWMIF3 Mask */
S
S#define PWM_PIIR_PWMIF2_Pos                     2                                   /*!< PWM_T::PIIR: PWMIF2 Position */
S#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)        /*!< PWM_T::PIIR: PWMIF2 Mask */
S
S#define PWM_PIIR_PWMIF1_Pos                     1                                   /*!< PWM_T::PIIR: PWMIF1 Position */
S#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)        /*!< PWM_T::PIIR: PWMIF1 Mask */
S
S#define PWM_PIIR_PWMIF0_Pos                     0                                   /*!< PWM_T::PIIR: PWMIF0 Position */
S#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)        /*!< PWM_T::PIIR: PWMIF0 Mask */
S
S/* PWM CCR0 Bit Field Definitions */
S#define PWM_CCR0_CFLRI1_Pos                     23                                  /*!< PWM_T::CCR0: CFLRI1 Position */
S#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)        /*!< PWM_T::CCR0: CFLRI1 Mask */
S
S#define PWM_CCR0_CRLRI1_Pos                     22                                  /*!< PWM_T::CCR0: CRLRI1 Position */
S#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)        /*!< PWM_T::CCR0: CRLRI1 Mask */
S
S#define PWM_CCR0_CAPIF1_Pos                     20                                  /*!< PWM_T::CCR0: CAPIF1 Position */
S#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)        /*!< PWM_T::CCR0: CAPIF1 Mask */
S
S#define PWM_CCR0_CAPCH1EN_Pos                   19                                  /*!< PWM_T::CCR0: CAPCH1EN Position */
S#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)      /*!< PWM_T::CCR0: CAPCH1EN Mask */
S
S#define PWM_CCR0_CFL_IE1_Pos                    18                                  /*!< PWM_T::CCR0: CFL_IE1 Position */
S#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)       /*!< PWM_T::CCR0: CFL_IE1 Mask */
S
S#define PWM_CCR0_CRL_IE1_Pos                    17                                  /*!< PWM_T::CCR0: CRL_IE1 Position */
S#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)       /*!< PWM_T::CCR0: CRL_IE1 Mask */
S
S#define PWM_CCR0_INV1_Pos                       16                                  /*!< PWM_T::CCR0: INV1 Position */
S#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)          /*!< PWM_T::CCR0: INV1 Mask */
S
S#define PWM_CCR0_CFLRI0_Pos                     7                                   /*!< PWM_T::CCR0: CFLRI0 Position */
S#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)        /*!< PWM_T::CCR0: CFLRI0 Mask */
S
S#define PWM_CCR0_CRLRI0_Pos                     6                                   /*!< PWM_T::CCR0: CRLRI0 Position */
S#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)        /*!< PWM_T::CCR0: CRLRI0 Mask */
S
S#define PWM_CCR0_CAPIF0_Pos                     4                                   /*!< PWM_T::CCR0: CAPIF0 Position */
S#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)        /*!< PWM_T::CCR0: CAPIF0 Mask */
S
S#define PWM_CCR0_CAPCH0EN_Pos                   3                                   /*!< PWM_T::CCR0: CAPCH0EN Position */
S#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)      /*!< PWM_T::CCR0: CAPCH0EN Mask */
S
S#define PWM_CCR0_CFL_IE0_Pos                    2                                   /*!< PWM_T::CCR0: CFL_IE0 Position */
S#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)       /*!< PWM_T::CCR0: CFL_IE0 Mask */
S
S#define PWM_CCR0_CRL_IE0_Pos                    1                                   /*!< PWM_T::CCR0: CRL_IE0 Position */
S#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)       /*!< PWM_T::CCR0: CRL_IE0 Mask */
S
S#define PWM_CCR0_INV0_Pos                       0                                   /*!< PWM_T::CCR0: INV0 Position */
S#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)          /*!< PWM_T::CCR0: INV0 Mask */
S
S/* PWM CCR2 Bit Field Definitions */
S#define PWM_CCR2_CFLRI3_Pos                     23                                  /*!< PWM_T::CCR2: CFLRI3 Position */
S#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)        /*!< PWM_T::CCR2: CFLRI3 Mask */
S
S#define PWM_CCR2_CRLRI3_Pos                     22                                  /*!< PWM_T::CCR2: CRLRI3 Position */
S#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)        /*!< PWM_T::CCR2: CRLRI3 Mask */
S
S#define PWM_CCR2_CAPIF3_Pos                     20                                  /*!< PWM_T::CCR2: CAPIF3 Position */
S#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)        /*!< PWM_T::CCR2: CAPIF3 Mask */
S
S#define PWM_CCR2_CAPCH3EN_Pos                   19                                  /*!< PWM_T::CCR2: CAPCH3EN Position */
S#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)      /*!< PWM_T::CCR2: CAPCH3EN Mask */
S
S#define PWM_CCR2_CFL_IE3_Pos                    18                                  /*!< PWM_T::CCR2: CFL_IE3 Position */
S#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)       /*!< PWM_T::CCR2: CFL_IE3 Mask */
S
S#define PWM_CCR2_CRL_IE3_Pos                    17                                  /*!< PWM_T::CCR2: CRL_IE3 Position */
S#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)       /*!< PWM_T::CCR2: CRL_IE3 Mask */
S
S#define PWM_CCR2_INV3_Pos                       16                                  /*!< PWM_T::CCR2: INV3 Position */
S#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)          /*!< PWM_T::CCR2: INV3 Mask */
S
S#define PWM_CCR2_CFLRI2_Pos                     7                                   /*!< PWM_T::CCR2: CFLRI2 Position */
S#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)        /*!< PWM_T::CCR2: CFLRI2 Mask */
S
S#define PWM_CCR2_CRLRI2_Pos                     6                                   /*!< PWM_T::CCR2: CRLRI2 Position */
S#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)        /*!< PWM_T::CCR2: CRLRI2 Mask */
S
S#define PWM_CCR2_CAPIF2_Pos                     4                                   /*!< PWM_T::CCR2: CAPIF2 Position */
S#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)        /*!< PWM_T::CCR2: CAPIF2 Mask */
S
S#define PWM_CCR2_CAPCH2EN_Pos                   3                                   /*!< PWM_T::CCR2: CAPCH2EN Position */
S#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)      /*!< PWM_T::CCR2: CAPCH2EN Mask */
S
S#define PWM_CCR2_CFL_IE2_Pos                    2                                   /*!< PWM_T::CCR2: CFL_IE2 Position */
S#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)       /*!< PWM_T::CCR2: CFL_IE2 Mask */
S
S#define PWM_CCR2_CRL_IE2_Pos                    1                                   /*!< PWM_T::CCR2: CRL_IE2 Position */
S#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)       /*!< PWM_T::CCR2: CRL_IE2 Mask */
S
S#define PWM_CCR2_INV2_Pos                       0                                   /*!< PWM_T::CCR2: INV2 Position */
S#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)          /*!< PWM_T::CCR2: INV2 Mask */
S
S/* PWM CRLR Bit Field Definitions */
S#define PWM_CRLR_CRLR_Pos                       0                                   /*!< PWM_T::CRLR0: CRLR Position */
S#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)     /*!< PWM_T::CRLR0: CRLR Mask */
S
S/* PWM CFLR Bit Field Definitions */
S#define PWM_CFLR_CFLR_Pos                       0                                   /*!< PWM_T::CFLR0: CFLR Position */
S#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)     /*!< PWM_T::CFLR0: CFLR Mask */
S
S/* PWM CAPENR Bit Field Definitions */
S#define PWM_CAPENR_CINEN3_Pos                   3                                   /*!< PWM_T::CAPENR: CINEN3 Position */
S#define PWM_CAPENR_CINEN3_Msk                   (1ul << PWM_CAPENR_CINEN3_Pos)      /*!< PWM_T::CAPENR: CINEN3 Mask */
S
S#define PWM_CAPENR_CINEN2_Pos                   2                                   /*!< PWM_T::CAPENR: CINEN2 Position */
S#define PWM_CAPENR_CINEN2_Msk                   (1ul << PWM_CAPENR_CINEN2_Pos)      /*!< PWM_T::CAPENR: CINEN2 Mask */
S
S#define PWM_CAPENR_CINEN1_Pos                   1                                   /*!< PWM_T::CAPENR: CINEN1 Position */
S#define PWM_CAPENR_CINEN1_Msk                   (1ul << PWM_CAPENR_CINEN1_Pos)      /*!< PWM_T::CAPENR: CINEN1 Mask */
S
S#define PWM_CAPENR_CINEN0_Pos                   0                                   /*!< PWM_T::CAPENR: CINEN0 Position */
S#define PWM_CAPENR_CINEN0_Msk                   (1ul << PWM_CAPENR_CINEN0_Pos)      /*!< PWM_T::CAPENR: CINEN0 Mask */
S
S/* PWM POE Bit Field Definitions */
S#define PWM_POE_PWM3_Pos                        3                                   /*!< PWM_T::POE: POE3 Position */
S#define PWM_POE_PWM3_Msk                        (1ul << PWM_POE_PWM3_Pos)           /*!< PWM_T::POE: POE3 Mask */
S
S#define PWM_POE_PWM2_Pos                        2                                   /*!< PWM_T::POE: POE2 Position */
S#define PWM_POE_PWM2_Msk                        (1ul << PWM_POE_PWM2_Pos)           /*!< PWM_T::POE: POE2 Mask */
S
S#define PWM_POE_PWM1_Pos                        1                                   /*!< PWM_T::POE: POE1 Position */
S#define PWM_POE_PWM1_Msk                        (1ul << PWM_POE_PWM1_Pos)           /*!< PWM_T::POE: POE1 Mask */
S
S#define PWM_POE_PWM0_Pos                        0                                   /*!< PWM_T::POE: POE0 Position */
S#define PWM_POE_PWM0_Msk                        (1ul << PWM_POE_PWM0_Pos)           /*!< PWM_T::POE: POE0 Mask */
S
S/* PWM TCON Bit Field Definitions */
S#define PWM_TCON_PWM3DTEN_Pos                   11                                  /*!< PWM_T::TCON: PWM3DTEN Position */
S#define PWM_TCON_PWM3DTEN_Msk                   (1ul << PWM_TCON_PWM3DTEN_Pos)      /*!< PWM_T::TCON: PWM3DTEN Mask */
S
S#define PWM_TCON_PWM2DTEN_Pos                   10                                  /*!< PWM_T::TCON: PWM2DTEN Position */
S#define PWM_TCON_PWM2DTEN_Msk                   (1ul << PWM_TCON_PWM2DTEN_Pos)      /*!< PWM_T::TCON: PWM2DTEN Mask */
S
S#define PWM_TCON_PWM1DTEN_Pos                   9                                   /*!< PWM_T::TCON: PWM1DTEN Position */
S#define PWM_TCON_PWM1DTEN_Msk                   (1ul << PWM_TCON_PWM1DTEN_Pos)      /*!< PWM_T::TCON: PWM1DTEN Mask */
S
S#define PWM_TCON_PWM0DTEN_Pos                   8                                   /*!< PWM_T::TCON: PWM0DTEN Position */
S#define PWM_TCON_PWM0DTEN_Msk                   (1ul << PWM_TCON_PWM0DTEN_Pos)      /*!< PWM_T::TCON: PWM0DTEN Mask */
S
S#define PWM_TCON_PWM3TEN_Pos                    3                                   /*!< PWM_T::TCON: PWM3TEN Position */
S#define PWM_TCON_PWM3TEN_Msk                    (1ul << PWM_TCON_PWM3TEN_Pos)       /*!< PWM_T::TCON: PWM3TEN Mask */
S
S#define PWM_TCON_PWM2TEN_Pos                    2                                   /*!< PWM_T::TCON: PWM2TEN Position */
S#define PWM_TCON_PWM2TEN_Msk                    (1ul << PWM_TCON_PWM2TEN_Pos)       /*!< PWM_T::TCON: PWM2TEN Mask */
S
S#define PWM_TCON_PWM1TEN_Pos                    1                                   /*!< PWM_T::TCON: PWM1TEN Position */
S#define PWM_TCON_PWM1TEN_Msk                    (1ul << PWM_TCON_PWM1TEN_Pos)       /*!< PWM_T::TCON: PWM1TEN Mask */
S
S#define PWM_TCON_PWM0TEN_Pos                    0                                   /*!< PWM_T::TCON: PWM0TEN Position */
S#define PWM_TCON_PWM0TEN_Msk                    (1ul << PWM_TCON_PWM0TEN_Pos)       /*!< PWM_T::TCON: PWM0TEN Mask */
S
S/* PWM TSTATUS Bit Field Definitions */
S#define PWM_TSTATUS_PWM3TF_Pos                  3                                   /*!< PWM_T::TSTATUS: PWM3TF Position */
S#define PWM_TSTATUS_PWM3TF_Msk                  (1ul << PWM_TSTATUS_PWM3TF_Pos)     /*!< PWM_T::TSTATUS: PWM3TF Mask */
S
S#define PWM_TSTATUS_PWM2TF_Pos                  2                                   /*!< PWM_T::TSTATUS: PWM2TF Position */
S#define PWM_TSTATUS_PWM2TF_Msk                  (1ul << PWM_TSTATUS_PWM2TF_Pos)     /*!< PWM_T::TSTATUS: PWM2TF Mask */
S
S#define PWM_TSTATUS_PWM1TF_Pos                  1                                   /*!< PWM_T::TSTATUS: PWM1TF Position */
S#define PWM_TSTATUS_PWM1TF_Msk                  (1ul << PWM_TSTATUS_PWM1TF_Pos)     /*!< PWM_T::TSTATUS: PWM1TF Mask */
S
S#define PWM_TSTATUS_PWM0TF_Pos                  0                                   /*!< PWM_T::TSTATUS: PWM0TF Position */
S#define PWM_TSTATUS_PWM0TF_Msk                  (1ul << PWM_TSTATUS_PWM0TF_Pos)     /*!< PWM_T::TSTATUS: PWM0TF Mask */
S
S/* PWM PSCR Bit Field Definitions */
S#define PWM_PSCR_PSSEN3_Pos                     24                                  /*!< PWM_T::PSCR: PSSEN3 Position */
S#define PWM_PSCR_PSSEN3_Msk                     (1ul << PWM_PSCR_PSSEN3_Pos)        /*!< PWM_T::PSCR: PSSEN3 Mask */
S
S#define PWM_PSCR_PSSEN2_Pos                     16                                  /*!< PWM_T::PSCR: PSSEN2 Position */
S#define PWM_PSCR_PSSEN2_Msk                     (1ul << PWM_PSCR_PSSEN2_Pos)        /*!< PWM_T::PSCR: PSSEN2 Mask */
S
S#define PWM_PSCR_PSSEN1_Pos                     8                                   /*!< PWM_T::PSCR: PSSEN1 Position */
S#define PWM_PSCR_PSSEN1_Msk                     (1ul << PWM_PSCR_PSSEN1_Pos)        /*!< PWM_T::PSCR: PSSEN1 Mask */
S
S#define PWM_PSCR_PSSEN0_Pos                     0                                   /*!< PWM_T::PSCR: PSSEN0 Position */
S#define PWM_PSCR_PSSEN0_Msk                     (1ul << PWM_PSCR_PSSEN0_Pos)        /*!< PWM_T::PSCR: PSSEN0 Mask */
S/**@}*/ /* PWM_CONST */
S/**@}*/ /* PWM */
S
S
S
S/*------------------------- SPI Interface Controller -------------------------*/
S/** @addtogroup SPI SPI Controller(SPI)
S  Memory Mapped Structure for SPI Controller
S  @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var SPI_T::CNTRL
S * Offset: 0x00  SPI Control and Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GO_BUSY   |SPI Transfer Trigger and Busy Status
S * |        |          |On M05xxBN:
S * |        |          |During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit
S * |        |          |will be cleared automatically.
S * |        |          |0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
S * |        |          |1 = In Master mode, writing 1 to this bit will start the SPI data transfer; in Slave mode,
S * |        |          |writing 1 to this bit indicates that the slave is ready to communicate with a master.
S * |        |          |Note: All registers should be set before writing 1 to the GO_BUSY bit.
S * |        |          |On M05xxDN/DE:
S * |        |          |In FIFO mode, this bit will be controlled by hardware. Software cannot modify this bit.
S * |        |          |If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1. As the
S * |        |          |transfer is finished, this bit will be cleared automatically.
S * |        |          |0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
S * |        |          |1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode,
S * |        |          |writing 1 to this bit indicates that the slave is ready to communicate with a master.
S * |        |          |Note 1: When FIFO mode is disabled, all configurations should be ready before writing
S * |        |          |1 to the GO_BUSY bit.
S * |        |          |Note 2: In M05xxDN/DE SPI Slave mode, if FIFO mode is disabled and the SPI bus
S * |        |          |clock is kept at idle state during a data transfer, the GO_BUSY bit will not be cleared to
S * |        |          |0 when slave select signal goes to inactive state.
S * |[1]     |RX_NEG    |Receive on Negative Edge
S * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
S * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
S * |[2]     |TX_NEG    |Transmit on Negative Edge
S * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
S * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPI bus clock.
S * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
S * |        |          |This field specifies how many bits are transmitted in one transaction.
S * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
S * |        |          |TX_BIT_LEN = 0x08 ... 8 bit
S * |        |          |TX_BIT_LEN = 0x09 ... 9 bits
S * |        |          |......
S * |        |          |TX_BIT_LEN = 0x1f ... 31 bits
S * |        |          |TX_BIT_LEN = 0x00 ... 32 bits
S * |[9:8]   |TX_NUM    |Numbers of Transmit/Receive Word (M05xxBN Only)
S * |        |          |This field specifies how many transmit/receive word numbers should be executed 
S * |        |          |in one transfer.
S * |        |          |00 = Only one transmit/receive word will be executed in one transfer.
S * |        |          |01 = Two successive transmit/receive words will be executed in one transfer. (burst mode)
S * |        |          |10 = Reserved.
S * |        |          |11 = Reserved.
S * |        |          |Note: In Slave mode with level-trigger configuration, if TX_NUM is set to 01, the slave
S * |        |          |select pin must be kept at active state during the successive data transfer.
S * |[10]    |LSB       |LSB First
S * |        |          |0 = The MSB is transmitted/received first.
S * |        |          |1 = The LSB is transmitted/received first.
S * |[11]    |CLKP      |Clock Polarity
S * |        |          |0 = SPI bus clock idle low.
S * |        |          |1 = SPI bus clock idle high.
S * |[15:12] |SP_CYCLE  |Suspend Interval (master only)
S * |        |          |These four bits provide configurable suspend interval between two successive
S * |        |          |transactions in a transfer. The definition of the suspend interval is the interval between
S * |        |          |the last clock edge of the preceding transaction word and the first clock edge of the
S * |        |          |following transaction word.
S * |        |          |On M05xxBN:
S * |        |          |The default value is 0x0. When TX_NUM = 00b, setting this field has no effect on
S * |        |          |transfer. The desired suspend interval is obtained according to the following equation:
S * |        |          |For byte suspend interval and burst mode suspend interval:
S * |        |          |(SP_CYCLE[3:0] + 2) * period of SPI bus clock + 1 system clock cycle
S * |        |          |Example:
S * |        |          |SP_CYCLE = 0x0 ... 2 SPI bus clock cycle + 1 system clock cycle
S * |        |          |SP_CYCLE = 0x1 ... 3 SPI bus clock cycle + 1 system clock cycle
S * |        |          |......
S * |        |          |SP_CYCLE = 0xE ... 16 SPI bus clock cycle + 1 system clock cycle
S * |        |          |SP_CYCLE = 0xF ... 17 SPI bus clock cycle + 1 system clock cycle
S * |        |          |If the SPI bus clock rate equals system clock rate, that is to say, the DIV_ONE feature
S * |        |          |is enabled, the burst mode suspend interval period is
S * |        |          |(SP_CYCLE[3:0] * 2 + 3.5) * period of system clock
S * |        |          |On M05xxDN/DE:
S * |        |          |The default value is 0x3. The period of the suspend interval is obtained according
S * |        |          |to the following equation:
S * |        |          |(SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle
S * |        |          |Example:
S * |        |          |SP_CYCLE = 0x0 ... 0.5 SPI bus clock cycle
S * |        |          |SP_CYCLE = 0x1 ... 1.5 SPI bus clock cycle
S * |        |          |......
S * |        |          |SP_CYCLE = 0xE ... 14.5 SPI bus clock cycle
S * |        |          |SP_CYCLE = 0xF ... 15.5 SPI bus clock cycle
S * |[16]    |IF        |Unit-Transfer Interrupt Flag
S * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
S * |        |          |1 = SPI controller has finished one unit transfer.
S * |        |          |NOTE: This bit can be cleared by writing 1 to itself.
S * |[17]    |IE        |Unit-Transfer Interrupt Enable Control
S * |        |          |0 = SPI unit-transfer interrupt Disabled.
S * |        |          |1 = SPI unit-transfer interrupt Enabled.
S * |[18]    |SLAVE     |SLAVE Mode Control
S * |        |          |0 = Master mode.
S * |        |          |1 = Slave mode.
S * |[19]    |REORDER   |Byte Reorder Function Selection
S * |        |          |On M05xxBN:
S * |        |          |00 = Disable both byte reorder and byte suspend functions.
S * |        |          |01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPI clock
S * |        |          |cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00 (32 bits).
S * |        |          |10 = Enable byte reorder function, but disable byte suspend function.
S * |        |          |11 = Disable byte reorder function, but insert a suspend interval (2~17 SPI clock cycles)
S * |        |          |among each byte. The setting of TX_BIT_LEN must be configured as 0x00 (32 bits).
S * |        |          |Note 1: The byte reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
S * |        |          |Note 2: In Slave mode with level-trigger configuration, if the byte suspend function is enabled,
S * |        |          |the slave select pin must be kept at active state during the successive four bytes transfer.
S * |        |          |On M05xxDN/DE:
S * |        |          |00 = Byte reorder function and byte suspend function are Disabled.
S * |        |          |01 = Byte reorder function Enabled. Byte suspend interval is determined by the setting
S * |        |          |of SP_CYCLE. Set SP_CYCLE to 0 to disabled byte suspend function.
S * |        |          |10 = Reserved.
S * |        |          |11 = Reserved.
S * |        |          |Note: Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
S * |[21]    |FIFO      |FIFO Mode Enable Control (M05xxDN/DE Only)
S * |        |          |0 = FIFO mode Disabled.
S * |        |          |1 = FIFO mode Enabled.
S * |        |          |Note:
S * |        |          |1. Before enabling FIFO mode, the other related settings should be set in advance.
S * |        |          |2. In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1
S * |        |          |automatically after writing data to the transmit FIFO buffer; the GO_BUSY bit
S * |        |          |will be cleared to 0 automatically when the SPI controller is in idle.
S * |        |          |If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1
S * |        |          |and the GO_BUSY bit will be cleared to 0.
S * |        |          |3. After clearing this bit to 0, user must wait for at least 2 peripheral clock periods
S * |        |          |before setting this bit to 1 again.
S * |[23]    |VARCLK_EN |Variable Clock Enable Control (M05xxBN Master Mode Only)
S * |        |          |0 = The bus clock output frequency is fixed and decided only by the value of DIVIDER.
S * |        |          |1 = The bus clock output frequency is variable. The output frequency is decided by the
S * |        |          |values of VARCLK, DIVIDER, and DIVIDER2.
S * |        |          |Note: When this VARCLK_EN bit is set, the setting of TX_BIT_LEN must be 
S * |        |          |programmed as 0x10 (16-bit mode).
S * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only) (M05xxDN/DE Only)
S * |        |          |A mutual mirror bit of SPI_STATUS[24].
S * |        |          |0 = Receive FIFO buffer is not empty.
S * |        |          |1 = Receive FIFO buffer is empty.
S * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (Read Only) (M05xxDN/DE Only)
S * |        |          |A mutual mirror bit of SPI_STATUS[25].
S * |        |          |0 = Receive FIFO buffer is not full.
S * |        |          |1 = Receive FIFO buffer is full.
S * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only) (M05xxDN/DE Only)
S * |        |          |A mutual mirror bit of SPI_STATUS[26].
S * |        |          |0 = Transmit FIFO buffer is not empty.
S * |        |          |1 = Transmit FIFO buffer is empty.
S * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only) (M05xxDN/DE Only)
S * |        |          |A mutual mirror bit of SPI_STATUS[27].
S * |        |          |0 = Transmit FIFO buffer is not full.
S * |        |          |1 = Transmit FIFO buffer is full.
S * @var SPI_T::DIVIDER
S * Offset: 0x04  SPI Clock Divider Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |DIVIDER   |Clock Divider
S * |        |          |On M05xxBN:
S * |        |          |Only available in Master mode. The value in this field is the frequency divider to
S * |        |          |determine the master's peripheral clock frequency (f_spi) and the bus clock frequency on the
S * |        |          |SPI bus clock output pin. The desired frequency is obtained according to the following equation:
S * |        |          |f_spi = f_pclk / ((DIVIDER + 1)*2)
S * |        |          |In Slave mode, the period of SPI bus clock driven by a master shall equal or over 5
S * |        |          |times the period of PCLK. In other words, the maximum frequency of SPI bus clock is
S * |        |          |the fifth of the frequency of slave's PCLK.
S * |        |          |On M05xxDN/DE:
S * |        |          |Only DIVIDER[7:0] is available. The value in this field is the frequency divider to
S * |        |          |determine the SPI peripheral clock frequency, f_spi, and the SPI master's bus clock
S * |        |          |frequency on the SPI bus clock output pin. The frequency is obtained according to the
S * |        |          |following equation.
S * |        |          |If the bit of BCn, SPI_CNTRL2[31], is set to 0,
S * |        |          |f_spi = f_SPI_clock_src / ((DIVIDER + 1)*2)
S * |        |          |else if BCn is set to 1,
S * |        |          |f_spi = f_SPI_clock_src / (DIVIDER + 1)
S * |        |          |where f_SPI_clock_src is the SPI peripheral clock source which is defined in the CLKSEL1 register.
S * @var SPI_T::SSR
S * Offset: 0x08  SPI Slave Select Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SSR       |Slave Select Control (Master Only)
S * |        |          |If AUTOSS bit is cleared to 0,
S * |        |          |0 = Set the SPISSx line to inactive state.
S * |        |          |1 = Set the proper SPISSx line to active state.
S * |        |          |If AUTOSS bit is set to 1,
S * |        |          |0 = Keep the SPISSx line at inactive state.
S * |        |          |1 = Select the SPISSx line to be automatically driven to active state for the duration of
S * |        |          |transmission/reception, and will be driven to inactive state for the rest of the time.
S * |        |          |The active state of SPISSx is specified in SS_LVL bit.
S * |[2]     |SS_LVL    |Slave Select Active Level
S * |        |          |This bit defines the active status of slave select signal (SPISSx).
S * |        |          |0 = The slave select signal SPISSx is active at low-level/falling-edge.
S * |        |          |1 = The slave select signal SPISSx is active at high-level/rising-edge.
S * |[3]     |AUTOSS    |Automatic Slave Select (Master only)
S * |        |          |0 = If this bit is cleared, slave select signal will be asserted and de-asserted by setting
S * |        |          |and clearing SSR[0].
S * |        |          |1 = If this bit is set, SPISSx signal is generated automatically. It means that slave
S * |        |          |select signal will be asserted by the SPI controller when transmit/receive is started by
S * |        |          |setting GO_BUSY, and is de-asserted after each transmit/receive is finished.
S * |[4]     |SS_LTRIG  |Slave Select Level Trigger (Slave only)
S * |        |          |0: The input slave select signal is edge-trigger. This is default value. It depends on
S * |        |          |SS_LVL to decide the signal is active at falling-edge or rising-edge.
S * |        |          |1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the
S * |        |          |signal is active low or active high.
S * |[5]     |LTRIG_FLAG|Level Trigger Accomplish Flag
S * |        |          |When the SS_LTRIG bit is set in Slave mode, this bit can be read to indicate the
S * |        |          |received bit number is met the requirement or not.
S * |        |          |0 = The transaction number or the transferred bit length of one transaction does not
S * |        |          |meet the specified requirements.
S * |        |          |1 = The transaction number and the transferred bit length met the specified
S * |        |          |requirements which defined in TX_NUM and TX_BIT_LEN.
S * |        |          |Note: This bit is READ only and only available in Slave mode.
S * @var SPI_T::RX0
S * Offset: 0x10  Data Receive Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |RX        |Data Receive Register
S * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer. The
S * |        |          |number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For
S * |        |          |example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the
S * |        |          |received data.
S * |        |          |NOTE: The Data Receive Registers are read only registers.
S * @var SPI_T::RX1
S * Offset: 0x14  Data Receive Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |RX        |Data Receive Register
S * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer. The
S * |        |          |number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For
S * |        |          |example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the
S * |        |          |received data.
S * |        |          |NOTE: The Data Receive Registers are read only registers.
S * @var SPI_T::TX0
S * Offset: 0x20  Data Transmit Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |TX        |Data Transmit Register
S * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer. The number
S * |        |          |of valid bits depend on the transmit bit length field in the CNTRL register.
S * |        |          |For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be
S * |        |          |transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will
S * |        |          |perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).
S * @var SPI_T::TX1
S * Offset: 0x24  Data Transmit Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |TX        |Data Transmit Register
S * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer. The number
S * |        |          |of valid bits depend on the transmit bit length field in the CNTRL register.
S * |        |          |For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be
S * |        |          |transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will
S * |        |          |perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).
S * @var SPI_T::VARCLK
S * Offset: 0x34  Variable Clock Pattern Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |VARCLK    |Variable Clock Pattern
S * |        |          |The value in this field is the frequency patterns of the SPI bus clock.
S * |        |          |If the bit pattern of VARCLK is 0, the output frequency of SPI bus clock is according the value of DIVIDER.
S * |        |          |If the bit pattern of VARCLK is 1, the output frequency of SPI bus clock is according the value of DIVIDER2.
S * |        |          |If the variable clock function is disabled, this setting is unmeaning.
S * @var SPI_T::CNTRL2
S * Offset: 0x3C  SPI Control and Status Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |DIV_ONE   |SPI Bus Clock Divider Control (M05xxBN Master Mode Only)
S * |        |          |0 = The SPI bus clock rate is determined by the setting of SPI_DIVIDER register.
S * |        |          |1 = Enable the DIV_ONE feature. The SPI bus clock rate equals the system clock rate.
S * |        |          |Note: When this bit is set to 1, both the REORDER field and the VARCLK_EN
S * |        |          |field must be configured as 0. In other words, the byte-reorder function, byte
S * |        |          |suspend function and variable clock function must be disabled.
S * |[8]     |NOSLVSEL  |Slave 3-Wire Mode Enable Bit
S * |        |          |This is used to ignore the slave select signal in Slave mode.
S * |        |          |The SPI controller can work with 3-wire interface including SPICLK, SPI_MISO, and SPI_MOSI.
S * |        |          |0 = 4-wire bi-direction interface.
S * |        |          |1 = 3-wire bi-direction interface. When this bit is set to 1, the controller will be ready to 
S * |        |          |transmit/receive data after the GO_BUSY bit is set to 1.
S * |        |          |Note: In Slave 3-wire mode, the SS_LTRIG (SPI_SSR[4]) shall be set as 1.
S * |[9]     |SLV_ABORT |Slave 3-Wire Mode Abort Control
S * |        |          |In normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.
S * |        |          |If the received bits are less than the requirement and there is no more serial clock input over the one transfer time in slave 3-wire mode,
S * |        |          |the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event.
S * |        |          |Note: It will be cleared to 0 automatically by hardware after it is set to 1 by software.
S * |[10]    |SSTA_INTEN|Slave 3-Wire Mode Start Interrupt Enable
S * |        |          |It is used to enable interrupt when the transfer has started in slave 3-wire mode.
S * |        |          |If there is no transfer done interrupt over the time period which is defined by user after the transfer start,
S * |        |          |user can set the SLV_ABORT bit to force the transfer done.
S * |        |          |0 = Transaction start interrupt Disabled.
S * |        |          |1 = Transaction start interrupt Enabled. It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared.
S * |[11]    |SLV_START_INTSTS|Slave 3-Wire Mode Start Interrupt Status
S * |        |          |This bit dedicates if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_STATUS[11].
S * |        |          |0 = Slave does not detect any SPI bus clock transition since the SSTA_INTEN bit was set to 1.
S * |        |          |1 = A transaction has started in Slave 3-wire mode. It will be cleared automatically when a transaction is done or by writing 1 to this bit.
S * |[16]    |SS_INT_OPT|Slave Select Inactive Interrupt Option (M05xxDN/DE Only)
S * |        |          |This setting is only available if the SPI controller is configured as level trigger slave device.
S * |        |          |0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.
S * |        |          |1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.
S * |[31]    |BCn       |Clock Configuration Backward Compatible Option (M05xxDN/DE Only)
S * |        |          |0 = The clock configuration is backward compatible to M05xxBN.
S * |        |          |1 = The clock configuration is not backward compatibleto M05xxBN.
S * @var SPI_T::FIFO_CTL
S * Offset: 0x40  SPI FIFO Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RX_CLR    |Clear Receive FIFO Buffer
S * |        |          |0 = No effect.
S * |        |          |1 = Clear receive FIFO buffer. The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1.
S * |        |          |This bit will be cleared to 0 by hardware after software sets it to 1 and the receive FIFO is cleared.
S * |[1]     |TX_CLR    |Clear Transmit FIFO Buffer
S * |        |          |0 = No effect.
S * |        |          |1 = Clear transmit FIFO buffer. The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1.
S * |        |          |This bit will be cleared to 0 by hardware after software sets it to 1 and the transmit FIFO is cleared.
S * |[2]     |RX_INTEN  |Receive Threshold Interrupt Enable
S * |        |          |0 = Receive threshold interrupt Disabled.
S * |        |          |1 = Receive threshold interrupt Enabled.
S * |[3]     |TX_INTEN  |Transmit Threshold Interrupt Enable
S * |        |          |0 = Transmit threshold interrupt Disabled.
S * |        |          |1 = Transmit threshold interrupt Enabled.
S * |[6]     |RXOV_INTEN|Receive FIFO Overrun Interrupt Enable Control
S * |        |          |0 = Receive FIFO overrun interrupt Disabled.
S * |        |          |1 = Receive FIFO overrun interrupt Enabled.
S * |[21]    |TIMEOUT_INTEN|Receive FIFO Time-out Interrupt Enable
S * |        |          |0 = Time-out interrupt Disabled.
S * |        |          |1 = Time-out interrupt Enabled.
S * |[25:24] |RX_THRESHOLD |Received FIFO Threshold
S * |        |          |If the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting,
S * |        |          |the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.
S * |[29:28] |TX_THRESHOLD |Transmit FIFO Threshold
S * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting,
S * |        |          |the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.
S * @var SPI_T::STATUS
S * Offset: 0x44  SPI Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RX_INTSTS |Receive FIFO Threshold Interrupt Status (read only)
S * |        |          |0 = That the valid data count within the RX FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD.
S * |        |          |1 = That the valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD.
S * |        |          |Note: If RX_INTEN = 1 and RX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
S * |[2]     |RX_OVERRUN|Receive FIFO Overrun Status
S * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
S * |        |          |Note: This bit will be cleared by writing 1 to itself.
S * |[4]     |TX_INTSTS |Transmit FIFO Threshold Interrupt Status (read only)
S * |        |          |0 = That the valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD.
S * |        |          |1 = That the valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD.
S * |        |          |Note: If TX_INTEN = 1 and TX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
S * |[11]    |SLV_START_INTSTS|Slave Start Interrupt Status
S * |        |          |It is used to dedicate that the transfer has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_CNTRL2[11].
S * |        |          |0 = The transfer is not started.
S * |        |          |1 = The transfer has started in Slave 3-wire mode. It will be cleared as transfer done or by writing one to this bit.
S * |[15:12] |RX_FIFO_COUNT   |Receive FIFO Data Count (read only)
S * |        |          |Indicates the valid data count of receive FIFO buffer.
S * |[16]    |IF        |SPI Unit Transfer Interrupt Flag
S * |        |          |A mutual mirror bit of SPI_CNTRL[16].
S * |        |          |0 = The transfer does not finish yet.
S * |        |          |1 = The SPI controller has finished one unit transfer.
S * |        |          |Note: This bit will be cleared by writing 1 to itself.
S * |[20]    |TIMEOUT   |Time-out Interrupt Flag
S * |        |          |0 = No receive FIFO time-out event.
S * |        |          |1 = The receive FIFO buffer is not empty and it does not be read over 64 SPI
S * |        |          |clock periods in Master mode or over 576 SPI peripheral clock periods in Slave
S * |        |          |mode. When the received FIFO buffer is read by software, the time-out status
S * |        |          |will be cleared automatically.
S * |        |          |Note: This bit will be cleared by writing 1 to itself.
S * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (read only)
S * |        |          |A mutual mirror bit of SPI_CNTRL[24].
S * |        |          |0 = The receive FIFO buffer is not empty.
S * |        |          |1 = The receive FIFO buffer is empty.
S * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (read only)
S * |        |          |A mutual mirror bit of SPI_CNTRL[25].
S * |        |          |0 = The receive FIFO buffer is not full.
S * |        |          |1 = The receive FIFO buffer is full.
S * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (read only)
S * |        |          |A mutual mirror bit of SPI_CNTRL[26].
S * |        |          |0 = The transmit FIFO buffer is not empty.
S * |        |          |1 = The transmit FIFO buffer is empty.
S * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (read only)
S * |        |          |A mutual mirror bit of SPI_CNTRL[27].
S * |        |          |0 = The transmit FIFO buffer is not full.
S * |        |          |1 = The transmit FIFO buffer is full.
S * |[31:28] |TX_FIFO_COUNT   |Transmit FIFO Data Count (read only)
S * |        |          |Indicates the valid data count of transmit FIFO buffer.
S */
S
S    __IO uint32_t CNTRL;         /* Offset: 0x00  SPI Control and Status Register                                    */
S    __IO uint32_t DIVIDER;       /* Offset: 0x04  SPI Clock Divider Register                                         */
S    __IO uint32_t SSR;           /* Offset: 0x08  SPI Slave Select Register                                          */
S    __I  uint32_t RESERVE0;     
S    __I  uint32_t RX0;           /* Offset: 0x10  Data Receive Register                                              */
S    __I  uint32_t RX1;           /* Offset: 0x14  Data Receive Register                                              */
S    __I  uint32_t RESERVE1[2];  
S    __O  uint32_t TX0;           /* Offset: 0x20  Data Transmit Register                                             */
S    __O  uint32_t TX1;           /* Offset: 0x24  Data Transmit Register                                             */
S    __I  uint32_t RESERVE2[3];  
S    __IO uint32_t VARCLK;        /* Offset: 0x34  Variable Clock Pattern Register                                    */
S    __I  uint32_t RESERVE3;     
S    __IO uint32_t CNTRL2;        /* Offset: 0x3C  SPI Control and Status Register 2                                  */
S    __IO uint32_t FIFO_CTL;      /* Offset: 0x40  SPI FIFO Control Register                                          */
S    __IO uint32_t STATUS;        /* Offset: 0x44  SPI Status Register                                                */
S
S} SPI_T;
S
S
S
S/** @addtogroup SPI_CONST SPI Bit Field Definition
S  Constant Definitions for SPI Controller
S  @{
S */
S
S/* SPI_CNTRL Bit Field Definitions */
S#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI_T::CNTRL: TX_FULL Position */
S#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI_T::CNTRL: TX_FULL Mask     */
S
S#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI_T::CNTRL: TX_EMPTY Position */
S#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI_T::CNTRL: TX_EMPTY Mask     */
S
S#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI_T::CNTRL: RX_FULL Position */
S#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI_T::CNTRL: RX_FULL Mask     */
S
S#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI_T::CNTRL: RX_EMPTY Position */
S#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI_T::CNTRL: RX_EMPTY Mask     */
S
S#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI_T::CNTRL: VARCLK_EN Position */
S#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI_T::CNTRL: VARCLK_EN Mask     */
S
S#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI_T::CNTRL: FIFO Position */
S#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI_T::CNTRL: FIFO Mask     */
S
S#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI_T::CNTRL: REORDER Position */
S#define SPI_CNTRL_REORDER_Msk      (3ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI_T::CNTRL: REORDER Mask     */
S
S#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI_T::CNTRL: SLAVE Position */
S#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI_T::CNTRL: SLAVE Mask     */
S
S#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI_T::CNTRL: IE Position */
S#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI_T::CNTRL: IE Mask     */
S
S#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI_T::CNTRL: IF Position */
S#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI_T::CNTRL: IF Mask     */
S
S#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI_T::CNTRL: SP_CYCLE Position */
S#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI_T::CNTRL: SP_CYCLE Mask     */
S
S#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI_T::CNTRL: CLKP Position */
S#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI_T::CNTRL: CLKP Mask     */
S
S#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI_T::CNTRL: LSB Position */
S#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI_T::CNTRL: LSB Mask     */
S
S#define SPI_CNTRL_TX_NUM_Pos       8                                      /*!< SPI_T::CNTRL: TX_NUM Position */
S#define SPI_CNTRL_TX_NUM_Msk       (3ul << SPI_CNTRL_TX_NUM_Pos)          /*!< SPI_T::CNTRL: TX_NUM Mask     */
S
S#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI_T::CNTRL: TX_BIT_LEN Position */
S#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI_T::CNTRL: TX_BIT_LEN Mask     */
S
S#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI_T::CNTRL: TX_NEG Position */
S#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI_T::CNTRL: TX_NEG Mask     */
S
S#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI_T::CNTRL: RX_NEG Position */
S#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI_T::CNTRL: RX_NEG Mask     */
S
S#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI_T::CNTRL: GO_BUSY Position */
S#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI_T::CNTRL: GO_BUSY Mask     */
S
S/* SPI_DIVIDER Bit Field Definitions */
S#define SPI_DIVIDER_DIVIDER2_Pos   16                                     /*!< SPI_T::DIVIDER: DIVIDER2 Position */
S#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFFFul << SPI_DIVIDER_DIVIDER2_Pos) /*!< SPI_T::DIVIDER: DIVIDER2 Mask */
S
S#define SPI_DIVIDER_DIVIDER_Pos    0                                      /*!< SPI_T::DIVIDER: DIVIDER Position */
S#define SPI_DIVIDER_DIVIDER_Msk    (0xFFFFul << SPI_DIVIDER_DIVIDER_Pos)  /*!< SPI_T::DIVIDER: DIVIDER Mask */
S
S/* SPI_SSR Bit Field Definitions */
S#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI_T::SSR: LTRIG_FLAG Position */
S#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI_T::SSR: LTRIG_FLAG Mask */
S
S#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI_T::SSR: SS_LTRIG Position */
S#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI_T::SSR: SS_LTRIG Mask */
S
S#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI_T::SSR: AUTOSS Position */
S#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI_T::SSR: AUTOSS Mask */
S
S#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI_T::SSR: SS_LVL Position */
S#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI_T::SSR: SS_LVL Mask */
S
S#define SPI_SSR_SSR_Pos            0                                 /*!< SPI_T::SSR: SSR Position */
S#define SPI_SSR_SSR_Msk            (1ul << SPI_SSR_SSR_Pos)          /*!< SPI_T::SSR: SSR Mask */
S
S/* SPI_CNTRL2 Bit Field Definitions */
S#define SPI_CNTRL2_BCn_Pos                31                                         /*!< SPI_T::CNTRL2: BCn Position */
S#define SPI_CNTRL2_BCn_Msk                (1ul << SPI_CNTRL2_BCn_Pos)                /*!< SPI_T::CNTRL2: BCn Mask */
S
S#define SPI_CNTRL2_SS_INT_OPT_Pos         16                                         /*!< SPI_T::CNTRL2: SS_INT_OPT Position */
S#define SPI_CNTRL2_SS_INT_OPT_Msk         (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)         /*!< SPI_T::CNTRL2: SS_INT_OPT Mask */
S
S#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::CNTRL2: SLV_START_INTSTS Position */
S#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI_T::CNTRL2: SLV_START_INTSTS Mask */
S
S#define SPI_CNTRL2_SSTA_INTEN_Pos         10                                         /*!< SPI_T::CNTRL2: SSTA_INTEN Position */
S#define SPI_CNTRL2_SSTA_INTEN_Msk         (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)         /*!< SPI_T::CNTRL2: SSTA_INTEN Mask */
S
S#define SPI_CNTRL2_SLV_ABORT_Pos          9                                          /*!< SPI_T::CNTRL2: SLV_ABORT Position */
S#define SPI_CNTRL2_SLV_ABORT_Msk          (1ul << SPI_CNTRL2_SLV_ABORT_Pos)          /*!< SPI_T::CNTRL2: SLV_ABORT Mask */
S
S#define SPI_CNTRL2_NOSLVSEL_Pos           8                                          /*!< SPI_T::CNTRL2: NOSLVSEL Position */
S#define SPI_CNTRL2_NOSLVSEL_Msk           (1ul << SPI_CNTRL2_NOSLVSEL_Pos)           /*!< SPI_T::CNTRL2: NOSLVSEL Mask */
S
S#define SPI_CNTRL2_DIV_ONE_Pos            0                                          /*!< SPI_T::CNTRL2: DIV_ONE Position */
S#define SPI_CNTRL2_DIV_ONE_Msk            (1ul << SPI_CNTRL2_DIV_ONE_Pos)            /*!< SPI_T::CNTRL2: DIV_ONE Mask */
S
S/* SPI_FIFO_CTL Bit Field Definitions */
S#define SPI_FIFO_CTL_TX_THRESHOLD_Pos     28                                         /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Position */
S#define SPI_FIFO_CTL_TX_THRESHOLD_Msk     (3ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Mask */
S
S#define SPI_FIFO_CTL_RX_THRESHOLD_Pos     24                                         /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Position */
S#define SPI_FIFO_CTL_RX_THRESHOLD_Msk     (3ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Mask */
S
S#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos    21                                         /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Position */
S#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk    (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)    /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Mask */
S
S#define SPI_FIFO_CTL_RXOV_INTEN_Pos       6                                          /*!< SPI_T::FIFO_CTL: RXOV_INTEN Position */
S#define SPI_FIFO_CTL_RXOV_INTEN_Msk       (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)       /*!< SPI_T::FIFO_CTL: RXOV_INTEN Mask */
S
S#define SPI_FIFO_CTL_TX_INTEN_Pos         3                                          /*!< SPI_T::FIFO_CTL: TX_INTEN Position */
S#define SPI_FIFO_CTL_TX_INTEN_Msk         (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)         /*!< SPI_T::FIFO_CTL: TX_INTEN Mask */
S
S#define SPI_FIFO_CTL_RX_INTEN_Pos         2                                          /*!< SPI_T::FIFO_CTL: RX_INTEN Position */
S#define SPI_FIFO_CTL_RX_INTEN_Msk         (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)         /*!< SPI_T::FIFO_CTL: RX_INTEN Mask */
S
S#define SPI_FIFO_CTL_TX_CLR_Pos           1                                          /*!< SPI_T::FIFO_CTL: TX_CLR Position */
S#define SPI_FIFO_CTL_TX_CLR_Msk           (1ul << SPI_FIFO_CTL_TX_CLR_Pos)           /*!< SPI_T::FIFO_CTL: TX_CLR Mask */
S
S#define SPI_FIFO_CTL_RX_CLR_Pos           0                                          /*!< SPI_T::FIFO_CTL: RX_CLR Position */
S#define SPI_FIFO_CTL_RX_CLR_Msk           (1ul << SPI_FIFO_CTL_RX_CLR_Pos)           /*!< SPI_T::FIFO_CTL: RX_CLR Mask */
S
S/* SPI_STATUS Bit Field Definitions */
S#define SPI_STATUS_TX_FIFO_COUNT_Pos      28                                         /*!< SPI_T::STATUS: TX_FIFO_COUNT Position */
S#define SPI_STATUS_TX_FIFO_COUNT_Msk      (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)    /*!< SPI_T::STATUS: TX_FIFO_COUNT Mask */
S
S#define SPI_STATUS_TX_FULL_Pos            27                                         /*!< SPI_T::STATUS: TX_FULL Position */
S#define SPI_STATUS_TX_FULL_Msk            (1ul << SPI_STATUS_TX_FULL_Pos)            /*!< SPI_T::STATUS: TX_FULL Mask */
S
S#define SPI_STATUS_TX_EMPTY_Pos           26                                         /*!< SPI_T::STATUS: TX_EMPTY Position */
S#define SPI_STATUS_TX_EMPTY_Msk           (1ul << SPI_STATUS_TX_EMPTY_Pos)           /*!< SPI_T::STATUS: TX_EMPTY Mask */
S
S#define SPI_STATUS_RX_FULL_Pos            25                                         /*!< SPI_T::STATUS: RX_FULL Position */
S#define SPI_STATUS_RX_FULL_Msk            (1ul << SPI_STATUS_RX_FULL_Pos)            /*!< SPI_T::STATUS: RX_FULL Mask */
S
S#define SPI_STATUS_RX_EMPTY_Pos           24                                         /*!< SPI_T::STATUS: RX_EMPTY Position */
S#define SPI_STATUS_RX_EMPTY_Msk           (1ul << SPI_STATUS_RX_EMPTY_Pos)           /*!< SPI_T::STATUS: RX_EMPTY Mask */
S
S#define SPI_STATUS_TIMEOUT_Pos            20                                         /*!< SPI_T::STATUS: TIMEOUT Position */
S#define SPI_STATUS_TIMEOUT_Msk            (1ul << SPI_STATUS_TIMEOUT_Pos)            /*!< SPI_T::STATUS: TIMEOUT Mask */
S
S#define SPI_STATUS_IF_Pos                 16                                         /*!< SPI_T::STATUS: IF Position */
S#define SPI_STATUS_IF_Msk                 (1ul << SPI_STATUS_IF_Pos)                 /*!< SPI_T::STATUS: IF Mask     */
S
S#define SPI_STATUS_RX_FIFO_COUNT_Pos      12                                         /*!< SPI_T::STATUS: RX_FIFO_COUNT Position */
S#define SPI_STATUS_RX_FIFO_COUNT_Msk      (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)    /*!< SPI_T::STATUS: RX_FIFO_COUNT Mask */
S
S#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::STATUS: SLV_START_INTSTS Position */
S#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI_T::STATUS: SLV_START_INTSTS Mask */
S
S#define SPI_STATUS_TX_INTSTS_Pos          4                                          /*!< SPI_T::STATUS: TX_INTSTS Position */
S#define SPI_STATUS_TX_INTSTS_Msk          (1ul << SPI_STATUS_TX_INTSTS_Pos)          /*!< SPI_T::STATUS: TX_INTSTS Mask */
S
S#define SPI_STATUS_RX_OVERRUN_Pos         2                                          /*!< SPI_T::STATUS: RX_OVERRUN Position */
S#define SPI_STATUS_RX_OVERRUN_Msk         (1ul << SPI_STATUS_RX_OVERRUN_Pos)         /*!< SPI_T::STATUS: RX_OVERRUN Mask */
S
S#define SPI_STATUS_RX_INTSTS_Pos          0                                          /*!< SPI_T::STATUS: RX_INTSTS Position */
S#define SPI_STATUS_RX_INTSTS_Msk          (1ul << SPI_STATUS_RX_INTSTS_Pos)          /*!< SPI_T::STATUS: RX_INTSTS Mask */
S/**@}*/ /* SPI_CONST */
S/**@}*/ /* SPI */
S
S
S
S/*---------------------------- Global Controller -----------------------------*/
S
S/** @addtogroup GCR System Global Controller(SYS)
S  Memory Mapped Structure for System Global Controller
S  @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var GCR_T::PDID
S * Offset: 0x00  Part Device Identification Number Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PDID      |This register reflects device part number code. Software can read this register to identify which device is used.
S * @var GCR_T::RSTSRC
S * Offset: 0x04  System Reset Source Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RSTS_POR  |Power-on Reset Flag
S * |        |          |The RSTS_POR flag is set by the "reset signal" from the Power-On Reset (POR) controller or bit CHIP_RST (IPRSTC1[0]) to indicate the previous reset source.
S * |        |          |0 = No reset from POR or CHIP_RST (IPRSTC1[0]).
S * |        |          |1 = Power-on Reset (POR) or CHIP_RST (IPRSTC1[0]) had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[1]     |RSTS_RESET|Reset Pin Reset Flag
S * |        |          |The RSTS_RESET flag is set by the "Reset Signal" from the /RESET pin to indicate the previous reset source.
S * |        |          |0 = No reset from /RESET pin.
S * |        |          |1 = The Pin /RESET had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[2]     |RSTS_WDT  |Watchdog Reset Flag
S * |        |          |The RSTS_WDT flag is set by The "Reset Signal" from the Watchdog Timer to indicate the previous reset source
S * |        |          |0 = No reset from watchdog timer.
S * |        |          |1 = The watchdog timer had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[3]     |RSTS_LVR  |Low Voltage Reset Flag
S * |        |          |The RSTS_LVR flag Is Set By The "Reset Signal" From The Low-Voltage-Reset Controller To Indicate The Previous Reset Source
S * |        |          |0 = No reset from LVR.
S * |        |          |1 = The LVR controller had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[4]     |RSTS_BOD  |Brown-out Detector Reset Flag
S * |        |          |The RSTS_BOD flag is set by the "Reset Signal" from the Brown-Out Detector to indicate the previous reset source.
S * |        |          |0 = No reset from BOD.
S * |        |          |1 = The BOD had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[5]     |RSTS_MCU  |MCU Reset Flag
S * |        |          |The RSTS_MCU flag is set by the "Reset Signal" from the Cortex-M0 kernel to indicate the previous reset source.
S * |        |          |0 = No reset from Cortex-M0.
S * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit SYSRESETREQ (AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 kernel.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[7]     |RSTS_CPU  |CPU Reset Flag
S * |        |          |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 CPU kernel and flash. Memory Controller (FMC)
S * |        |          |0 = No reset from CPU.
S * |        |          |1 = Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST(IPRSTC1[1]) to 1.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * @var GCR_T::IPRSTC1
S * Offset: 0x08  Peripheral Reset Control Resister 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CHIP_RST  |Chip One-shot Reset (Write Protect)
S * |        |          |Setting this bit will reset the whole chip, including Cortex-M0 core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
S * |        |          |The CHIP_RST is the same as the POR reset. All the chip controllers are reset and the chip setting from CONFIG0 are also reload.
S * |        |          |0 = Chip normal operation.
S * |        |          |1 = Chip one-shot reset.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[1]     |CPU_RST   |Cortex-M0 Core One-shot Reset (Write Protect)
S * |        |          |Setting this bit will only reset the Cortex-M0 core and Flash Memory Controller (FMC), and this bit will automatically return 0 after the two clock cycles.
S * |        |          |0 = Cortex-M0 core normal operation.
S * |        |          |1 = Cortex-M0 core one-shot reset.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[3]     |EBI_RST   |EBI Controller Reset (Write Protect)
S * |        |          |Set this bit to 1 will generate a reset signal to the EBI. User needs to set this bit to 0 to release from the reset state.
S * |        |          |0 = EBI controller normal operation.
S * |        |          |1 = EBI controller reset.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[4]     |HDIV_RST  |HDIV Controller Reset (Write Protect) 
S * |        |          |Set this bit to 1 will generate a reset signal to the hardware divider. User need to set this bit to 0 to release from the reset state.
S * |        |          |0 = Hardware divider controller normal operation.
S * |        |          |1 = Hardware divider controller reset.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register. 
S * @var GCR_T::IPRSTC2
S * Offset: 0x0C  Peripheral Reset Control Resister 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |GPIO_RST  |GPIO Controller Reset
S * |        |          |0 = GPIO controller normal operation.
S * |        |          |1 = GPIO controller reset.
S * |[2]     |TMR0_RST  |Timer0 Controller Reset
S * |        |          |0 = Timer0 controller normal operation.
S * |        |          |1 = Timer0 controller reset.
S * |[3]     |TMR1_RST  |Timer1 Controller Reset
S * |        |          |0 = Timer1 controller normal operation.
S * |        |          |1 = Timer1 controller reset.
S * |[4]     |TMR2_RST  |Timer2 Controller Reset
S * |        |          |0 = Timer2 controller normal operation.
S * |        |          |1 = Timer2 controller reset.
S * |[5]     |TMR3_RST  |Timer3 Controller Reset
S * |        |          |0 = Timer3 controller normal operation.
S * |        |          |1 = Timer3 controller reset.
S * |[8]     |I2C0_RST  |I2C0 Controller Reset
S * |        |          |0 = I2C0 controller normal operation.
S * |        |          |1 = I2C0 controller reset.
S * |[9]     |I2C1_RST  |I2C1 Controller Reset
S * |        |          |0 = I2C1 controller normal operation.
S * |        |          |1 = I2C1 controller reset.
S * |[12]    |SPI0_RST  |SPI0 Controller Reset
S * |        |          |0 = SPI0 controller normal operation.
S * |        |          |1 = SPI0 controller reset.
S * |[13]    |SPI1_RST  |SPI1 Controller Reset
S * |        |          |0 = SPI1 controller normal operation.
S * |        |          |1 = SPI1 controller reset.
S * |[16]    |UART0_RST |UART0 Controller Reset
S * |        |          |0 = UART0 controller normal operation.
S * |        |          |1 = UART0 controller reset.
S * |[17]    |UART1_RST |UART1 Controller Reset
S * |        |          |0 = UART1 controller normal operation.
S * |        |          |1 = UART1 controller reset.
S * |[20]    |PWM03_RST |PWM03 Controller Reset
S * |        |          |0 = PWM03 controller normal operation.
S * |        |          |1 = PWM03 controller reset.
S * |[21]    |PWM47_RST |PWM47 Controller Reset
S * |        |          |0 = PWM47 controller normal operation.
S * |        |          |1 = PWM47 controller reset.
S * |[22]    |ACMP01_RST|Analog Comparator A Controller Reset
S * |        |          |0 = Analog Comparator A controller normal operation.
S * |        |          |1 = Analog Comparator A controller reset.     
S * |[22]    |ACMP23_RST|Analog Comparator B Controller Reset
S * |        |          |0 = Analog Comparator B controller normal operation.
S * |        |          |1 = Analog Comparator B controller reset.         
S * |[28]    |ADC_RST   |ADC Controller Reset
S * |        |          |0 = ADC controller normal operation.
S * |        |          |1 = ADC controller reset.
S * @var GCR_T::BODCR
S * Offset: 0x18  Brown-Out Detector Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BOD_EN    |Brown-Out Detector Enable Bit (Write Protect)
S * |        |          |The default value is set by flash memory controller user configuration register CBODEN (Config0[23]) bit.
S * |        |          |0 = Brown-out Detector function Disabled.
S * |        |          |1 = Brown-out Detector function Enabled.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[2:1]   |BOD_VL    |Brown-Out Detector Threshold Voltage Selection (Write Protect)
S * |        |          |The default value is set by flash controller user configuration register CBOV (Config0[22:21]) bit.
S * |        |          |00 = Brown-out voltage is 2.2V.
S * |        |          |01 = Brown-out voltage is 2.7V.
S * |        |          |10 = Brown-out voltage is 3.7V.
S * |        |          |11 = Brown-out voltage is 4.4V.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[3]     |BOD_RSTEN |Brown-out Reset Enable Control (Write Protect)
S * |        |          |0 = Brown-out "INTERRUPT" function Enabled.
S * |        |          |While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled (BOD_RSTEN low), BOD will assert an interrupt if BOD_OUT is high.
S * |        |          |BOD interrupt will keep till to the BOD_EN set to 0. BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).
S * |        |          |1 = Brown-out "RESET" function Enabled.
S * |        |          |Note1: While the Brown-out Detector function is enabled (BOD_EN high) and BOD reset function is enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BOD_OUT high).
S * |        |          |Note2: The default value is set by flash controller user configuration register CBORST (Config0[20]) bit.
S * |        |          |Note3: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[4]     |BOD_INTF  |Brown-out Detector Interrupt Flag
S * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting.
S * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[5]     |BOD_LPM   |Brown-out Detector Low Power Mode (Write Protection)
S * |        |          |0 = BOD operated in Normal mode (default).
S * |        |          |1 = BOD Low Power mode Enabled.
S * |        |          |Note1: The BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the current to about 1/10 but slow the BOD response.
S * |        |          |Note2: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[6]     |BOD_OUT   |Brown-out Detector Output Status
S * |        |          |0 = Brown-out Detector output status is 0. It means the detected voltage is higher than BOD_VL setting or BOD_EN is 0.
S * |        |          |1 = Brown-out Detector output status is 1. It means the detected voltage is lower than BOD_VL setting. If the BOD_EN is 0, BOD function disabled, this bit always responds to 0.
S * |[7]     |LVR_EN    |Low Voltage Reset Enable Bit (Write Protect)
S * |        |          |The LVR function reset the chip when the input power voltage is lower than LVR circuit setting. LVR function is enabled by default.
S * |        |          |0 = Low Voltage Reset function Disabled.
S * |        |          |1 = Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default).
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * @var GCR_T::TEMPCR
S * Offset: 0x1C  Temperature Sensor Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |VTEMP_EN  |Temperature Sensor Enable Control
S * |        |          |This bit is used to enable/disable temperature sensor function.
S * |        |          |0 = Temperature sensor function Disabled (default).
S * |        |          |1 = Temperature sensor function Enabled.
S * |        |          |Note: After this bit is set to 1, the value of temperature sensor output can be obtained from the ADC conversion result. 
S * |        |          |Please refer to the ADC chapter for detailed ADC conversion functional description.
S * @var GCR_T::PORCR
S * Offset: 0x24  Power-On-Reset Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |POR_DIS_CODE|Power-on Reset Enable Control (Write Protect)
S * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.
S * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
S * |        |          |The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
S * |        |          |nRESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function.
S * |        |          |Note: These bits are write protected bit. Refer to the REGWRPROT register.
S * @var GCR_T::P0_MFP
S * Offset: 0x30  P0 Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |P0_MFP    |P0 multiple function Selection
S * |        |          |The pin function of P0 is depending on P0_MFP and P0_ALT.
S * |        |          |Refer to P0_ALT descriptions in detail.
S * |[8]     |P0_ALT0   |P0.0 alternate function Selection
S * |        |          |The pin function of P0.0 is depend on P0_MFP[0] and P0_ALT[0].
S * |        |          |P0_ALT[0]P0_MFP[0] = P0.0 Function
S * |        |          |00 = P0.0
S * |        |          |01 = AD0(EBI)
S * |        |          |10 = CTS1(UART1)
S * |        |          |11 = Reserved
S * |[9]     |P0_ALT1   |P0.1 alternate function Selection
S * |        |          |The pin function of P0.1 is depend on P0_MFP[1] and P0_ALT[1].
S * |        |          |P0_ALT[1] P0_MFP[1] = P0.1 Function
S * |        |          |00 = P0.1
S * |        |          |01 = AD1(EBI)
S * |        |          |10 = RTS1(UART1)
S * |        |          |11 = Reserved
S * |[10]    |P0_ALT2   |P0.2 alternate function Selection
S * |        |          |The pin function of P0.2 is depend on P0_MFP[2] and P0_ALT[2].
S * |        |          |P0_ALT[2] P0_MFP[2] = P0.2 Function
S * |        |          |00 = P0.2
S * |        |          |01 = AD2(EBI)
S * |        |          |10 = CTS0(UART0)
S * |        |          |11 = Reserved
S * |[11]    |P0_ALT3   |P0.3 alternate function Selection
S * |        |          |The pin function of P0.3 is depend on P0_MFP[3] and P0_ALT[3].
S * |        |          |P0_ALT[3] P0_MFP[3] = P0.3 Function
S * |        |          |00 = P0.3
S * |        |          |01 = AD3(EBI)
S * |        |          |10 = RTS0(UART0)
S * |        |          |11 = Reserved
S * |[12]    |P0_ALT4   |P0.4 alternate function Selection
S * |        |          |The pin function of P0.4 is depend on P0_MFP[4] and P0_ALT[4].
S * |        |          |P0_ALT[4] P0_MFP[4] = P0.4 Function
S * |        |          |00 = P0.4
S * |        |          |01 = AD4(EBI)
S * |        |          |10 = SPISS1(SPI1)
S * |        |          |11 = Reserved
S * |[13]    |P0_ALT5   |P0.5 alternate function Selection
S * |        |          |The pin function of P0.5 is depend on P0_MFP[5] and P0_ALT[5].
S * |        |          |P0_ALT[5] P0_MFP[5] = P0.5 Function
S * |        |          |00 = P0.5
S * |        |          |01 = AD5(EBI)
S * |        |          |10 = MOSI_1(SPI1)
S * |        |          |11 = Reserved
S * |[14]    |P0_ALT6   |P0.6 alternate function Selection
S * |        |          |The pin function of P0.6 is depend on P0_MFP[6] and P0_ALT[6].
S * |        |          |P0_ALT[6] P0_MFP[6] = P0.6 Function
S * |        |          |00 = P0.6
S * |        |          |01 = AD6(EBI)
S * |        |          |10 = MISO_1(SPI1)
S * |        |          |11 = Reserved
S * |[15]    |P0_ALT7   |P0.7 alternate function Selection
S * |        |          |The pin function of P0.7 is depend on P0_MFP[7] and P0_ALT[7].
S * |        |          |P0_ALT[7] P0_MFP[7] = P0.7 Function
S * |        |          |00 = P0.7
S * |        |          |01 = AD7(EBI)
S * |        |          |10 = SPICLK1(SPI1)
S * |        |          |11 = Reserved
S * |[23:16] |P0_TYPEn  |P0[7:0] input Schmitt Trigger function Enable
S * |        |          |1= P0[7:0] I/O input Schmitt Trigger function enable
S * |        |          |0= P0[7:0] I/O input Schmitt Trigger function disable
S * @var GCR_T::P1_MFP
S * Offset: 0x34  P1 Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |P1_MFP    |P1 multiple function Selection
S * |        |          |The pin function of P1 is depending on P1_MFP and P1_ALT.
S * |        |          |Refer to P1_ALT descriptions in detail.
S * |[8]     |P1_ALT0   |P1.0 alternate function Selection
S * |        |          |The pin function of P1.0 is depend on P1_MFP[0] and P1_ALT[0].
S * |        |          |P1_ALT[0] P1_MFP[0] = P1.0 Function
S * |        |          |00 = P1.0
S * |        |          |01 = AIN0(ADC)
S * |        |          |10 = T2(Timer2)
S * |        |          |11 = Reserved
S * |[9]     |P1_ALT1   |P1.1 alternate function Selection
S * |        |          |The pin function of P1.1 is depend on P1_MFP[1] and P1_ALT[1].
S * |        |          |P1_ALT[1] P1_MFP[1] = P1.1 Function
S * |        |          |00 = P1.1
S * |        |          |01 = AIN1(ADC)
S * |        |          |10 = T3(Timer3)
S * |        |          |11 = Reserved
S * |[10]    |P1_ALT2   |P1.2 alternate function Selection
S * |        |          |The pin function of P1.2 is depend on P1_MFP[2] and P1_ALT[2].
S * |        |          |P1_ALT[2] P1_MFP[2] = P1.2 Function
S * |        |          |00 = P1.2
S * |        |          |01 = AIN2(ADC)
S * |        |          |10 = RXD1(UART1)
S * |        |          |11 = Reserved
S * |[11]    |P1_ALT3   |P1.3 alternate function Selection
S * |        |          |The pin function of P1.3 is depend on P1_MFP[3] and P1_ALT[3].
S * |        |          |P1_ALT[3] P1_MFP[3] = P1.3 Function
S * |        |          |00 = P1.3
S * |        |          |01 = AIN3(ADC)
S * |        |          |10 = TXD1(UART1)
S * |        |          |11 = Reserved
S * |[12]    |P1_ALT4   |P1.4 alternate function Selection
S * |        |          |The pin function of P1.4 is depend on P1_MFP[4] and P1_ALT[4].
S * |        |          |P1_ALT[4] P1_MFP[4] = P1.4 Function
S * |        |          |00 = P1.4
S * |        |          |01 = AIN4(ADC)
S * |        |          |10 = SPISS0(SPI0)
S * |        |          |11 = Reserved
S * |[13]    |P1_ALT5   |P1.5 alternate function Selection
S * |        |          |The pin function of P1.5 is depend on P1_MFP[5] and P1_ALT[5].
S * |        |          |P1_ALT[5] P1_MFP[5] = P1.5 Function
S * |        |          |00 = P1.5
S * |        |          |01 = AIN5(ADC)
S * |        |          |10 = MOSI_0(SPI0)
S * |        |          |11 = Reserved
S * |[14]    |P1_ALT6   |P1.6 alternate function Selection
S * |        |          |The pin function of P1.6 is depend on P1_MFP[6] and P1_ALT[6].
S * |        |          |P1_ALT[6] P1_MFP[6] = P1.6 Function
S * |        |          |00 = P1.6
S * |        |          |01 = AIN6(ADC)
S * |        |          |10 = MISO_0(SPI0)
S * |        |          |11 = Reserved
S * |[15]    |P1_ALT7   |P1.7 alternate function Selection
S * |        |          |The pin function of P1.7 is depend on P1_MFP[7] and P1_ALT[7].
S * |        |          |P1_ALT[7] P1_MFP[7] = P1.7 Function
S * |        |          |00 = P1.7
S * |        |          |01 = AIN7(ADC)
S * |        |          |10 = SPICLK0(SPI0)
S * |        |          |11 = Reserved
S * |[23:16] |P1_TYPEn  |P1[7:0] input Schmitt Trigger function Enable
S * |        |          |1= P1[7:0] I/O input Schmitt Trigger function enable
S * |        |          |0= P1[7:0] I/O input Schmitt Trigger function disable
S * @var GCR_T::P2_MFP
S * Offset: 0x38  P2 Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |P2_MFP    |P2 multiple function Selection
S * |        |          |The pin function of P2 is depending on P2_MFP and P2_ALT.
S * |        |          |Refer to P2_ALT descriptions in detail.
S * |[8]     |P2_ALT0   |P2.0 alternate function Selection
S * |        |          |The pin function of P2.0 is depend on P2_MFP[0] and P2_ALT[0].
S * |        |          |P2_ALT[0] P2_MFP[0] = P2.0 Function
S * |        |          |00 = P2.0
S * |        |          |01 = AD8(EBI)
S * |        |          |10 = PWM0(PWM generator 0)
S * |        |          |11 = Reserved
S * |[9]     |P2_ALT1   |P2.1 alternate function Selection
S * |        |          |The pin function of P2.1 is depend on P2_MFP[1] and P2_ALT[1].
S * |        |          |P2_ALT[1] P2_MFP[1] = P2.1 Function
S * |        |          |00 = P2.1
S * |        |          |01 = AD9(EBI)
S * |        |          |10 = PWM1(PWM generator 0)
S * |        |          |11 = Reserved
S * |[10]    |P2_ALT2   |P2.2 alternate function Selection
S * |        |          |The pin function of P2.2 is depend on P2_MFP[2] and P2_ALT[2].
S * |        |          |P2_ALT[2] P2_MFP[2] = P2.2 Function
S * |        |          |00 = P2.2
S * |        |          |01 = AD10(EBI)
S * |        |          |10 = PWM2(PWM generator 2)
S * |        |          |11 = Reserved
S * |[11]    |P2_ALT3   |P2.3 alternate function Selection
S * |        |          |The pin function of P2.3 is depend on P2_MFP[3] and P2_ALT[3].
S * |        |          |P2_ALT[3] P2_MFP[3] = P2.3 Function
S * |        |          |00 = P2.3
S * |        |          |01 = AD11(EBI)
S * |        |          |10 = PWM3(PWM generator 2)
S * |        |          |11 = Reserved
S * |[12]    |P2_ALT4   |P2.4 alternate function Selection
S * |        |          |The pin function of P2.4 is depend on P2_MFP[4] and P2_ALT[4].
S * |        |          |P2_ALT[4] P2_MFP[4] = P0.4 Function
S * |        |          |00 = P0.4
S * |        |          |01 = AD12(EBI)
S * |        |          |10 = PWM4(PWM generator 4)
S * |        |          |11 = Reserved
S * |[13]    |P2_ALT5   |P2.5 alternate function Selection
S * |        |          |The pin function of P2.5 is depend on P2_MFP[5] and P2_ALT[5].
S * |        |          |P2_ALT[5] P2_MFP[5] = P2.5 Function
S * |        |          |00 = P2.5
S * |        |          |01 = AD13(EBI)
S * |        |          |10 = PWM5(PWM generator 4)
S * |        |          |11 = Reserved
S * |[14]    |P2_ALT6   |P2.6 alternate function Selection
S * |        |          |The pin function of P2.6 is depend on P2_MFP[6] and P2_ALT[6].
S * |        |          |P2_ALT[6] P2_MFP[6] = P2.6 Function
S * |        |          |00 = P2.6
S * |        |          |01 = AD14(EBI)
S * |        |          |10 = PWM6(PWM generator 6)
S * |        |          |11 = Reserved
S * |[15]    |P2_ALT7   |P2.7 alternate function Selection
S * |        |          |The pin function of P2.7 is depend on P2_MFP[7] and P2_ALT[7].
S * |        |          |P2_ALT[7] P2_MFP[7] = P2.7 Function
S * |        |          |00 = P2.7
S * |        |          |01 = AD15(EBI)
S * |        |          |10 = PWM7(PWM generator 6)
S * |        |          |11 = Reserved
S * |[23:16] |P2_TYPEn  |P2[7:0] input Schmitt Trigger function Enable
S * |        |          |1= P2[7:0] I/O input Schmitt Trigger function enable
S * |        |          |0= P2[7:0] I/O input Schmitt Trigger function disable
S * @var GCR_T::P3_MFP
S * Offset: 0x3C  P3 Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |P3_MFP    |P3 multiple function Selection
S * |        |          |The pin function of P3 is depending on P3_MFP and P3_ALT.
S * |        |          |Refer to P3_ALT descriptions in detail.
S * |[8]     |P3_ALT0   |P3.0 alternate function Selection
S * |        |          |The pin function of P3.0 is depend on P3_MFP[0] and P3_ALT[0].
S * |        |          |P3_ALT[0] P3_MFP[0] = P3.0 Function
S * |        |          |00 = P3.0
S * |        |          |01 = RXD(UART0)
S * |        |          |1x = Reserved
S * |[9]     |P3_ALT1   |P3.1 alternate function Selection
S * |        |          |The pin function of P3.1 is depend on P3_MFP[1] and P3_ALT[1].
S * |        |          |P3_ALT[1] P3_MFP[1] = P3.1 Function
S * |        |          |00 = P3.1
S * |        |          |01 = TXD(UART0)
S * |        |          |1x = Reserved
S * |[10]    |P3_ALT2   |P3.2 alternate function Selection
S * |        |          |The pin function of P3.2 is depend on P3_MFP[2] and P3_ALT[2].
S * |        |          |P3_ALT[2] P3_MFP[2] = P3.2 Function
S * |        |          |00 = P3.2
S * |        |          |01 = /INT0
S * |        |          |11 = Reserved
S * |[11]    |P3_ALT3   |P3.3 alternate function Selection
S * |        |          |The pin function of P3.3 is depend on P3_MFP[3] and P3_ALT[3].
S * |        |          |P3_ALT[3] P3_MFP[3] = P3.3 Function
S * |        |          |00 = P3.3
S * |        |          |01 = /INT1
S * |        |          |10 = MCLK(EBI)
S * |        |          |1x = Reserved
S * |[12]    |P3_ALT4   |P3.4 alternate function Selection
S * |        |          |The pin function of P3.4 is depend on P3_MFP[4] and P3_ALT[4].
S * |        |          |P3_ALT[4] P3_MFP[4] = P3.4 Function
S * |        |          |00 = P3.4
S * |        |          |01 = T0(Timer0)
S * |        |          |10 = SDA(I2C)
S * |        |          |11 = Reserved
S * |[13]    |P3_ALT5   |P3.5 alternate function Selection
S * |        |          |The pin function of P3.5 is depend on P3_MFP[5] and P3_ALT[5].
S * |        |          |P3_ALT[5] P3_MFP[5] = P3.5 Function
S * |        |          |00 = P3.5
S * |        |          |01 = T1(Timer1)
S * |        |          |10 = SCL(I2C)
S * |        |          |11 = Reserved
S * |[14]    |P3_ALT6   |P3.6 alternate function Selection
S * |        |          |The pin function of P3.6 is depend on P3_MFP[6] and P3_ALT[6].
S * |        |          |P3_ALT[6] P3_MFP[6] = P3.6 Function
S * |        |          |00 = P3.6
S * |        |          |01 = WR(EBI)
S * |        |          |10 = CKO(Clock Driver output)
S * |        |          |11 = Reserved
S * |[15]    |P3_ALT7   |P3.7 alternate function Selection
S * |        |          |The pin function of P3.7 is depend on P3_MFP[7] and P3_ALT[7].
S * |        |          |P3_ALT[7] P3_MFP[7] = P3.7 Function
S * |        |          |00 = P3.7
S * |        |          |01 = RD(EBI)
S * |        |          |1x = Reserved
S * |[23:16] |P3_TYPEn  |P3[7:0] input Schmitt Trigger function Enable
S * |        |          |1= P3[7:0] I/O input Schmitt Trigger function enable
S * |        |          |0= P3[7:0] I/O input Schmitt Trigger function disable
S * @var GCR_T::P4_MFP
S * Offset: 0x40  P4 Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |P4_MFP    |P4 multiple function Selection
S * |        |          |The pin function of P4 is depending on P4_MFP and P4_ALT.
S * |        |          |Refer to P4_ALT descriptions in detail.
S * |[8]     |P4_ALT0   |P4.0 alternate function Selection
S * |        |          |The pin function of P4.0 is depend on P4_MFP[0] and P4_ALT[0].
S * |        |          |P4_ALT[0] P4_MFP[0] = P4.0 Function
S * |        |          |00 = P4.0
S * |        |          |01 = PWM0(PWM generator 0)
S * |        |          |1x = Reserved
S * |[9]     |P4_ALT1   |P4.1 alternate function Selection
S * |        |          |The pin function of P4.1 is depend on P4_MFP[1] and P4_ALT[1].
S * |        |          |P4_ALT[1] P4_MFP[1] = P4.1 Function
S * |        |          |00 = P4.1
S * |        |          |01 = PWM1(PWM generator 0)
S * |        |          |1x = Reserved
S * |[10]    |P4_ALT2   |P4.2 alternate function Selection
S * |        |          |The pin function of P4.2 is depend on P4_MFP[2] and P4_ALT[2].
S * |        |          |P4_ALT[2] P4_MFP[2] = P4.2 Function
S * |        |          |00 = P4.2
S * |        |          |01 = PWM2(PWM generator 2)
S * |        |          |1x = Reserved
S * |[11]    |P4_ALT3   |P4.3 alternate function Selection
S * |        |          |The pin function of P4.3 is depend on P4_MFP[3] and P4_ALT[3].
S * |        |          |P4_ALT[3] P4_MFP[3] = P4.3 Function
S * |        |          |00 = P4.3
S * |        |          |01 = PWM3(PWM generator 2)
S * |        |          |1x = Reserved
S * |[12]    |P4_ALT4   |P4.4 alternate function Selection
S * |        |          |The pin function of P4.4 is depend on P4_MFP[4] and P4_ALT[4].
S * |        |          |P4_ALT[4] P4_MFP[4] = P4.4 Function
S * |        |          |00 = P4.4
S * |        |          |01 = /CS(EBI)
S * |        |          |1x = Reserved
S * |[13]    |P4_ALT5   |P4.5 alternate function Selection
S * |        |          |The pin function of P4.5 is depend on P4_MFP[5] and P4_ALT[5].
S * |        |          |P4_ALT[5] P4_MFP[5] = P4.5 Function
S * |        |          |00 = P4.5
S * |        |          |01 = ALE(EBI)
S * |        |          |1x = Reserved
S * |[14]    |P4_ALT6   |P4.6 alternate function Selection
S * |        |          |The pin function of P4.6 is depend on P4_MFP[6] and P4_ALT[6].
S * |        |          |P4_ALT[6] P4_MFP[6] = P4.6 Function
S * |        |          |00 = P4.6
S * |        |          |01 = ICE_CLK(ICE)
S * |        |          |1x = Reserved
S * |[15]    |P4_ALT7   |P4.7 alternate function Selection
S * |        |          |The pin function of P4.7 is depend on P4_MFP[7] and P4_ALT[7].
S * |        |          |P4_ALT[7] P4_MFP[7] = P4.7 Function
S * |        |          |00 = P4.7
S * |        |          |01 = ICE_DAT(ICE)
S * |        |          |1x = Reserved
S * |[23:16] |P4_TYPEn  |P4[7:0] input Schmitt Trigger function Enable
S * |        |          |1= P4[7:0] I/O input Schmitt Trigger function enable
S * |        |          |0= P4[7:0] I/O input Schmitt Trigger function disable
S * @var GCR_T::REGWRPROT
S * Offset: 0x100 Register Write-Protection Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |REGWRPROT |Register Write-Protected Code (Write Only)
S * |        |          |Some write-protected registers have to be disabled the protected function by writing the
S * |        |          |sequence value "59h", "16h", "88h" to this field. After this sequence is completed, the
S * |        |          |REGPROTDIS bit will be set to 1 and write-protected registers can be normal write.
S * |[0]     |REGPROTDIS|Register Write-Protected Disable index (Read only)
S * |        |          |1 = Protection is disabled for writing protected registers
S * |        |          |0 = Protection is enabled for writing protected registers. Any write to the protected register is ignored.
S * |        |          |The Write-Protected registers list are below table:
S * |        |          |Registers Address Note
S * |        |          |IPRSTC1 0x5000_0008 None
S * |        |          |BODCR 0x5000_0018 None
S * |        |          |PORCR 0x5000_001C None
S * |        |          |PWRCON 0x5000_0200 bit[6] is not protected for power, wake-up interrupt clear
S * |        |          |APBCLK bit[0] 0x5000_0208 bit[0] is watch dog clock enable
S * |        |          |CLKSEL0 0x5000_0210 HCLK and CPU STCLK clock source select
S * |        |          |CLK_SEL1 bit[1:0] 0x5000_0214 Watch dog clock source select
S * |        |          |ISPCON 0x5000_C000 Flash ISP Control register
S * |        |          |WTCR 0x4000_4000 None
S * |        |          |FATCON 0x5000_C018 None
S */
S
S    __I  uint32_t PDID;          /* Offset: 0x00  Part Device Identification Number Register.                        */
S    __IO uint32_t RSTSRC;        /* Offset: 0x04  System Reset Source Register                                       */
S    __IO uint32_t IPRSTC1;       /* Offset: 0x08  Peripheral Reset Control Resister 1                                */
S    __IO uint32_t IPRSTC2;       /* Offset: 0x0C  Peripheral Reset Control Resister 2                                */
S    __I  uint32_t RESERVED0[2]; 
S    __IO uint32_t BODCR;         /* Offset: 0x18  Brown-Out Detector Control Register                                */
S    __IO uint32_t TEMPCR;        /* Offset: 0x1C  Temperature Sensor Control Register                                */
S    __I  uint32_t RESERVED1;    
S    __IO uint32_t PORCR;         /* Offset: 0x24  Power-On-Reset Control Register                                    */
S    __I  uint32_t RESERVED2[2]; 
S    __IO uint32_t P0_MFP;        /* Offset: 0x30  P0 Multiple Function and Input Type Control Register               */
S    __IO uint32_t P1_MFP;        /* Offset: 0x34  P1 Multiple Function and Input Type Control Register               */
S    __IO uint32_t P2_MFP;        /* Offset: 0x38  P2 Multiple Function and Input Type Control Register               */
S    __IO uint32_t P3_MFP;        /* Offset: 0x3C  P3 Multiple Function and Input Type Control Register               */
S    __IO uint32_t P4_MFP;        /* Offset: 0x40  P4 Multiple Function and Input Type Control Register               */
S    __I  uint32_t RESERVED3[47];
S    __IO uint32_t REGWRPROT;     /* Offset: 0x100 Register Write-Protection Register                                 */
S
S} GCR_T;
S
S
S
S
S/** @addtogroup GCR_CONST GCR Bit Field Definition
S  Constant Definitions for GCR Controller
S  @{
S */
S
S/* GCR RSTSRC Bit Field Definitions */
S#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                       /*!< GCR_T::RSTSRC: RSTS_CPU Position */
S#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)        /*!< GCR_T::RSTSRC: RSTS_CPU Mask */
S
S#define SYS_RSTSRC_RSTS_MCU_Pos                 5                                       /*!< GCR_T::RSTSRC: RSTS_MCU Position */
S#define SYS_RSTSRC_RSTS_MCU_Msk                 (1ul << SYS_RSTSRC_RSTS_MCU_Pos)        /*!< GCR_T::RSTSRC: RSTS_MCU Mask */
S
S#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                       /*!< GCR_T::RSTSRC: RSTS_BOD Position */
S#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)        /*!< GCR_T::RSTSRC: RSTS_BOD Mask */
S
S#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                       /*!< GCR_T::RSTSRC: RSTS_LVR Position */
S#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)        /*!< GCR_T::RSTSRC: RSTS_LVR Mask */
S
S#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                       /*!< GCR_T::RSTSRC: RSTS_WDT Position */
S#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)        /*!< GCR_T::RSTSRC: RSTS_WDT Mask */
S
S#define SYS_RSTSRC_RSTS_RESET_Pos               1                                       /*!< GCR_T::RSTSRC: RSTS_RESET Position */
S#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)      /*!< GCR_T::RSTSRC: RSTS_RESET Mask */
S
S#define SYS_RSTSRC_RSTS_POR_Pos                 0                                       /*!< GCR_T::RSTSRC: RSTS_POR Position */
S#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)        /*!< GCR_T::RSTSRC: RSTS_POR Mask */
S
S/* GCR IPRSTC1 Bit Field Definitions */
S#define SYS_IPRSTC1_HDIV_RST_Pos                4                                       /*!< GCR_T::IPRSTC1: DIV_RST Position */
S#define SYS_IPRSTC1_HDIV_RST_Msk                (1ul << SYS_IPRSTC1_HDIV_RST_Pos)        /*!< GCR_T::IPRSTC1: DIV_RST Mask */
S
S#define SYS_IPRSTC1_EBI_RST_Pos                 3                                       /*!< GCR_T::IPRSTC1: EBI_RST Position */
S#define SYS_IPRSTC1_EBI_RST_Msk                 (1ul << SYS_IPRSTC1_EBI_RST_Pos)        /*!< GCR_T::IPRSTC1: EBI_RST Mask */
S
S#define SYS_IPRSTC1_CPU_RST_Pos                 1                                       /*!< GCR_T::IPRSTC1: CPU_RST Position */
S#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)        /*!< GCR_T::IPRSTC1: CPU_RST Mask */
S
S#define SYS_IPRSTC1_CHIP_RST_Pos                0                                       /*!< GCR_T::IPRSTC1: CHIP_RST Position */
S#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)       /*!< GCR_T::IPRSTC1: CHIP_RST Mask */
S
S/* GCR IPRSTC2 Bit Field Definitions */
S#define SYS_IPRSTC2_ADC_RST_Pos                 28                                      /*!< GCR_T::IPRSTC2: ADC_RST Position */
S#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)        /*!< GCR_T::IPRSTC2: ADC_RST Mask */
S
S#define SYS_IPRSTC2_ACMP23_RST_Pos              23                                      /*!< GCR_T::IPRSTC2: ACMP23_RST Position */
S#define SYS_IPRSTC2_ACMP23_RST_Msk              (1ul << SYS_IPRSTC2_ACMP23_RST_Pos)     /*!< GCR_T::IPRSTC2: ACMP23_RST Mask */
S
S#define SYS_IPRSTC2_ACMP01_RST_Pos              22                                      /*!< GCR_T::IPRSTC2: ACMP01_RST Position */
S#define SYS_IPRSTC2_ACMP01_RST_Msk              (1ul << SYS_IPRSTC2_ACMP01_RST_Pos)     /*!< GCR_T::IPRSTC2: ACMP01_RST Mask */
S
S#define SYS_IPRSTC2_PWM47_RST_Pos               21                                      /*!< GCR_T::IPRSTC2: PWM47_RST Position */
S#define SYS_IPRSTC2_PWM47_RST_Msk               (1ul << SYS_IPRSTC2_PWM47_RST_Pos)      /*!< GCR_T::IPRSTC2: PWM47_RST Mask */
S
S#define SYS_IPRSTC2_PWM03_RST_Pos               20                                      /*!< GCR_T::IPRSTC2: PWM03_RST Position */
S#define SYS_IPRSTC2_PWM03_RST_Msk               (1ul << SYS_IPRSTC2_PWM03_RST_Pos)      /*!< GCR_T::IPRSTC2: PWM03_RST Mask */
S
S#define SYS_IPRSTC2_UART1_RST_Pos               17                                      /*!< GCR_T::IPRSTC2: UART1_RST Position */
S#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)      /*!< GCR_T::IPRSTC2: UART1_RST Mask */
S
S#define SYS_IPRSTC2_UART0_RST_Pos               16                                      /*!< GCR_T::IPRSTC2: UART0_RST Position */
S#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)      /*!< GCR_T::IPRSTC2: UART0_RST Mask */
S
S#define SYS_IPRSTC2_SPI1_RST_Pos                13                                      /*!< GCR_T::IPRSTC2: SPI1_RST Position */
S#define SYS_IPRSTC2_SPI1_RST_Msk                (1ul << SYS_IPRSTC2_SPI1_RST_Pos)       /*!< GCR_T::IPRSTC2: SPI1_RST Mask */
S
S#define SYS_IPRSTC2_SPI0_RST_Pos                12                                      /*!< GCR_T::IPRSTC2: SPI0_RST Position */
S#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)       /*!< GCR_T::IPRSTC2: SPI0_RST Mask */
S
S#define SYS_IPRSTC2_I2C1_RST_Pos                9                                       /*!< GCR_T::IPRSTC2: I2C1_RST Position */
S#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)       /*!< GCR_T::IPRSTC2: I2C1_RST Mask */
S
S#define SYS_IPRSTC2_I2C0_RST_Pos                8                                       /*!< GCR_T::IPRSTC2: I2C0_RST Position */
S#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)       /*!< GCR_T::IPRSTC2: I2C0_RST Mask */
S#define SYS_IPRSTC2_I2C_RST_Pos                 8                                       /*!< GCR_T::IPRSTC2: I2C_RST Position */
S#define SYS_IPRSTC2_I2C_RST_Msk                 (1ul << SYS_IPRSTC2_I2C_RST_Pos)        /*!< GCR_T::IPRSTC2: I2C_RST Mask */
S
S#define SYS_IPRSTC2_TMR3_RST_Pos                5                                       /*!< GCR_T::IPRSTC2: TMR3_RST Position */
S#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)       /*!< GCR_T::IPRSTC2: TMR3_RST Mask */
S
S#define SYS_IPRSTC2_TMR2_RST_Pos                4                                       /*!< GCR_T::IPRSTC2: TMR2_RST Position */
S#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)       /*!< GCR_T::IPRSTC2: TMR2_RST Mask */
S
S#define SYS_IPRSTC2_TMR1_RST_Pos                3                                       /*!< GCR_T::IPRSTC2: TMR1_RST Position */
S#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)       /*!< GCR_T::IPRSTC2: TMR1_RST Mask */
S
S#define SYS_IPRSTC2_TMR0_RST_Pos                2                                       /*!< GCR_T::IPRSTC2: TMR0_RST Position */
S#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)       /*!< GCR_T::IPRSTC2: TMR0_RST Mask */
S
S#define SYS_IPRSTC2_GPIO_RST_Pos                1                                       /*!< GCR_T::IPRSTC2: GPIO_RST Position */
S#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)       /*!< GCR_T::IPRSTC2: GPIO_RST Mask */
S
S/* GCR BODCR Bit Field Definitions */
S#define SYS_BODCR_LVR_EN_Pos                    7                                       /*!< GCR_T::BODCR: LVR_EN Position */
S#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)           /*!< GCR_T::BODCR: LVR_EN Mask */
S
S#define SYS_BODCR_BOD_OUT_Pos                   6                                       /*!< GCR_T::BODCR: BOD_OUT Position */
S#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)          /*!< GCR_T::BODCR: BOD_OUT Mask */
S
S#define SYS_BODCR_BOD_LPM_Pos                   5                                       /*!< GCR_T::BODCR: BOD_LPM Position */
S#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)          /*!< GCR_T::BODCR: BOD_LPM Mask */
S
S#define SYS_BODCR_BOD_INTF_Pos                  4                                       /*!< GCR_T::BODCR: BOD_INTF Position */
S#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)         /*!< GCR_T::BODCR: BOD_INTF Mask */
S
S#define SYS_BODCR_BOD_RSTEN_Pos                 3                                       /*!< GCR_T::BODCR: BOD_RSTEN Position */
S#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)        /*!< GCR_T::BODCR: BOD_RSTEN Mask */
S
S#define SYS_BODCR_BOD_VL_Pos                    1                                       /*!< GCR_T::BODCR: BOD_VL Position */
S#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)           /*!< GCR_T::BODCR: BOD_VL Mask */
S
S#define SYS_BODCR_BOD_EN_Pos                    0                                       /*!< GCR_T::BODCR: BOD_EN Position */
S#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)           /*!< GCR_T::BODCR: BOD_EN Mask */
S
S/* GCR TEMPCR Bit Field Definitions */
S#define SYS_TEMPCR_VTEMP_EN_Pos                 0                                       /*!< GCR_T::TEMPCR: VTEMP_EN Position */
S#define SYS_TEMPCR_VTEMP_EN_Msk                 (1ul << SYS_TEMPCR_VTEMP_EN_Pos)        /*!< GCR_T::TEMPCR: VTEMP_EN Mask */
S
S/* GCR PORCR Bit Field Definitions */
S#define SYS_PORCR_POR_DIS_CODE_Pos              0                                       /*!< GCR_T::PORCR: POR_DIS_CODE Position */
S#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)/*!< GCR_T::PORCR: POR_DIS_CODE Mask */
S
S/* GCR P0_MFP Bit Field Definitions */
S#define SYS_P0_MFP_P0_ALT1_Pos                  24                                      /*!< GCR_T::P0_MFP: P0_ALT1 Position */
S#define SYS_P0_MFP_P0_ALT1_Msk                  (3ul << SYS_P0_MFP_P0_ALT1_Pos)         /*!< GCR_T::P0_MFP: P0_ALT1 Mask */
S
S#define SYS_P0_MFP_P0_TYPE_Pos                  16                                      /*!< GCR_T::P0_MFP: P0_TYPE Position */
S#define SYS_P0_MFP_P0_TYPE_Msk                  (0xFFul << SYS_P0_MFP_P0_TYPE_Pos)      /*!< GCR_T::P0_MFP: P0_TYPE Mask */
S
S#define SYS_P0_MFP_P0_ALT_Pos                   8                                       /*!< GCR_T::P0_MFP: P0_ALT Position */
S#define SYS_P0_MFP_P0_ALT_Msk                   (0xFFul << SYS_P0_MFP_P0_ALT_Pos)       /*!< GCR_T::P0_MFP: P0_ALT Mask */
S
S#define SYS_P0_MFP_P0_MFP_Pos                   0                                       /*!< GCR_T::P0_MFP: P0_MFP Position */
S#define SYS_P0_MFP_P0_MFP_Msk                   (0xFFul << SYS_P0_MFP_P0_MFP_Pos)       /*!< GCR_T::P0_MFP: P0_MFP Mask */
S
S/* GCR P1_MFP Bit Field Definitions */
S#define SYS_P1_MFP_P1_TYPE_Pos                  16                                      /*!< GCR_T::P1_MFP: P1_TYPE Position */
S#define SYS_P1_MFP_P1_TYPE_Msk                  (0xFFul << SYS_P1_MFP_P1_TYPE_Pos)      /*!< GCR_T::P1_MFP: P1_TYPE Mask */
S
S#define SYS_P1_MFP_P1_ALT_Pos                   8                                       /*!< GCR_T::P1_MFP: P1_ALT Position */
S#define SYS_P1_MFP_P1_ALT_Msk                   (0xFFul << SYS_P1_MFP_P1_ALT_Pos)       /*!< GCR_T::P1_MFP: P1_ALT Mask */
S
S#define SYS_P1_MFP_P1_MFP_Pos                   0                                       /*!< GCR_T::P1_MFP: P1_MFP Position */
S#define SYS_P1_MFP_P1_MFP_Msk                   (0xFFul << SYS_P1_MFP_P1_MFP_Pos)       /*!< GCR_T::P1_MFP: P1_MFP Mask */
S
S/* GCR P2_MFP Bit Field Definitions */
S#define SYS_P2_MFP_P2_TYPE_Pos                  16                                      /*!< GCR_T::P2_MFP: P2_TYPE Position */
S#define SYS_P2_MFP_P2_TYPE_Msk                  (0xFFul << SYS_P2_MFP_P2_TYPE_Pos)      /*!< GCR_T::P2_MFP: P2_TYPE Mask */
S
S#define SYS_P2_MFP_P2_ALT_Pos                   8                                       /*!< GCR_T::P2_MFP: P2_ALT Position */
S#define SYS_P2_MFP_P2_ALT_Msk                   (0xFFul << SYS_P2_MFP_P2_ALT_Pos)       /*!< GCR_T::P2_MFP: P2_ALT Mask */
S
S#define SYS_P2_MFP_P2_MFP_Pos                   0                                       /*!< GCR_T::P2_MFP: P2_MFP Position */
S#define SYS_P2_MFP_P2_MFP_Msk                   (0xFFul << SYS_P2_MFP_P2_MFP_Pos)       /*!< GCR_T::P2_MFP: P2_MFP Mask */
S
S/* GCR P3_MFP Bit Field Definitions */
S#define SYS_P3_MFP_P3_TYPE_Pos                  16                                      /*!< GCR_T::P3_MFP: P3_TYPE Position */
S#define SYS_P3_MFP_P3_TYPE_Msk                  (0xFFul << SYS_P3_MFP_P3_TYPE_Pos)      /*!< GCR_T::P3_MFP: P3_TYPE Mask */
S
S#define SYS_P3_MFP_P3_ALT_Pos                   8                                       /*!< GCR_T::P3_MFP: P3_ALT Position */
S#define SYS_P3_MFP_P3_ALT_Msk                   (0xFFul << SYS_P3_MFP_P3_ALT_Pos)       /*!< GCR_T::P3_MFP: P3_ALT Mask */
S
S#define SYS_P3_MFP_P3_MFP_Pos                   0                                       /*!< GCR_T::P3_MFP: P3_MFP Position */
S#define SYS_P3_MFP_P3_MFP_Msk                   (0xFFul << SYS_P3_MFP_P3_MFP_Pos)       /*!< GCR_T::P3_MFP: P3_MFP Mask */
S
S/* GCR P4_MFP Bit Field Definitions */
S#define SYS_P4_MFP_P4_TYPE_Pos                  16                                      /*!< GCR_T::P4_MFP: P4_TYPE Position */
S#define SYS_P4_MFP_P4_TYPE_Msk                  (0xFFul << SYS_P4_MFP_P4_TYPE_Pos)      /*!< GCR_T::P4_MFP: P4_TYPE Mask */
S
S#define SYS_P4_MFP_P4_ALT_Pos                   8                                       /*!< GCR_T::P4_MFP: P4_ALT Position */
S#define SYS_P4_MFP_P4_ALT_Msk                   (0xFFul << SYS_P4_MFP_P4_ALT_Pos)       /*!< GCR_T::P4_MFP: P4_ALT Mask */
S
S#define SYS_P4_MFP_P4_MFP_Pos                   0                                       /*!< GCR_T::P4_MFP: P4_MFP Position */
S#define SYS_P4_MFP_P4_MFP_Msk                   (0xFFul << SYS_P4_MFP_P4_MFP_Pos)       /*!< GCR_T::P4_MFP: P4_MFP Mask */
S
S/* GCR REGWRPROT Bit Field Definitions */
S#define SYS_REGWRPROT_REGWRPROT_Pos             0                                       /*!< GCR_T::REGWRPROT: REGWRPROT Position */
S#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos) /*!< GCR_T::REGWRPROT: REGWRPROT Mask */
S
S#define SYS_REGWRPROT_REGPROTDIS_Pos            0                                       /*!< GCR_T::REGWRPROT: REGPROTDIS Position */
S#define SYS_REGWRPROT_REGPROTDIS_Msk            (1ul << SYS_REGWRPROT_REGPROTDIS_Pos)   /*!< GCR_T::REGWRPROT: REGPROTDIS Mask */
S/**@}*/ /* GCR_CONST */
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var GCR_INT_T::IRQSRC
S * Offset: 0x00-0x7C MCU IRQn(n=0~31) Interrupt Source Identity Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |INT_SRC   |Interrupt Source Identity
S * |        |          |IRQSRC[0].0 - BOD INT
S * |        |          |IRQSRC[0].1 - 0
S * |        |          |IRQSRC[0].2 - 0
S * |        |          |IRQSRC[1].0 - WDT INT
S * |        |          |IRQSRC[1].1 - 0
S * |        |          |IRQSRC[1].2 - 0
S * |        |          |IRQSRC[2].0 - EINT0, external interrupt 0 from P3.2
S * |        |          |IRQSRC[2].1 - 0
S * |        |          |IRQSRC[2].2 - 0
S * |        |          |IRQSRC[3].0 - EINT1, external interrupt 1 from P3.3
S * |        |          |IRQSRC[3].1 - 0
S * |        |          |IRQSRC[3].2 - 0
S * |        |          |IRQSRC[4].0 - P0 INT
S * |        |          |IRQSRC[4].1 - P1 INT
S * |        |          |IRQSRC[4].2 - 0
S * |        |          |IRQSRC[5].0 - P2 INT
S * |        |          |IRQSRC[5].1 - P3 INT
S * |        |          |IRQSRC[5].2 - P4 INT
S * |        |          |IRQSRC[6].0 - PWM0 INT
S * |        |          |IRQSRC[6].1 - PWM1 INT
S * |        |          |IRQSRC[6].2 - PWM2 INT
S * |        |          |IRQSRC[6].3 - PWM3 INT
S * |        |          |IRQSRC[7].0 - PWM4 INT
S * |        |          |IRQSRC[7].1 - PWM5 INT
S * |        |          |IRQSRC[7].2 - PWM6 INT
S * |        |          |IRQSRC[7].3 - PWM7 INT
S * |        |          |IRQSRC[8].0 - TIMER0 INT
S * |        |          |IRQSRC[8].1 - 0
S * |        |          |IRQSRC[8].2 - 0
S * |        |          |IRQSRC[9].0 - TIMER1 INT
S * |        |          |IRQSRC[9].1 - 0
S * |        |          |IRQSRC[9].2 - 0
S * |        |          |IRQSRC[10].0 - TIMER2 INT
S * |        |          |IRQSRC[10].1 - 0
S * |        |          |IRQSRC[10].2 - 0
S * |        |          |IRQSRC[11].0 - TIMER3 INT
S * |        |          |IRQSRC[11].1 - 0
S * |        |          |IRQSRC[11].2 - 0
S * |        |          |IRQSRC[12].0 - UART0 INT
S * |        |          |IRQSRC[12].1 - 0
S * |        |          |IRQSRC[12].2 - 0
S * |        |          |IRQSRC[13].0 - UART1 INT
S * |        |          |IRQSRC[13].1 - 0
S * |        |          |IRQSRC[13].2 - 0
S * |        |          |IRQSRC[14].0 - SPI0 INT
S * |        |          |IRQSRC[14].1 - 0
S * |        |          |IRQSRC[14].2 - 0
S * |        |          |IRQSRC[15].0 - SPI1 INT
S * |        |          |IRQSRC[15].1 - 0
S * |        |          |IRQSRC[15].2 - 0
S * |        |          |IRQSRC[16].0 - 0
S * |        |          |IRQSRC[16].1 - 0
S * |        |          |IRQSRC[16].2 - 0
S * |        |          |IRQSRC[17].0 - 0
S * |        |          |IRQSRC[17].1 - 0
S * |        |          |IRQSRC[17].2 - 0
S * |        |          |IRQSRC[18].0 - I2C0 INT
S * |        |          |IRQSRC[18].1 - 0
S * |        |          |IRQSRC[18].2 - 0
S * |        |          |IRQSRC[19].0 - I2C1 INT
S * |        |          |IRQSRC[19].1 - 0
S * |        |          |IRQSRC[19].2 - 0
S * |        |          |IRQSRC[20].0 - 0
S * |        |          |IRQSRC[20].1 - 0
S * |        |          |IRQSRC[20].2 - 0
S * |        |          |IRQSRC[21].0 - 0
S * |        |          |IRQSRC[21].1 - 0
S * |        |          |IRQSRC[21].2 - 0
S * |        |          |IRQSRC[22].0 - 0
S * |        |          |IRQSRC[22].1 - 0
S * |        |          |IRQSRC[22].2 - 0
S * |        |          |IRQSRC[23].0 - 0
S * |        |          |IRQSRC[23].1 - 0
S * |        |          |IRQSRC[23].2 - 0
S * |        |          |IRQSRC[24].0 - 0
S * |        |          |IRQSRC[24].1 - 0
S * |        |          |IRQSRC[24].2 - 0
S * |        |          |IRQSRC[25].0 - ACMP0 INT
S * |        |          |IRQSRC[25].1 - 0
S * |        |          |IRQSRC[25].2 - 0
S * |        |          |IRQSRC[26].0 - ACMP1 INT
S * |        |          |IRQSRC[26].1 - 0
S * |        |          |IRQSRC[26].2 - 0
S * |        |          |IRQSRC[27].0 - 0
S * |        |          |IRQSRC[27].1 - 0
S * |        |          |IRQSRC[27].2 - 0
S * |        |          |IRQSRC[28].0 - Power Down Wake up INT
S * |        |          |IRQSRC[28].1 - 0
S * |        |          |IRQSRC[28].2 - 0
S * |        |          |IRQSRC[29].0 - ADC INT
S * |        |          |IRQSRC[29].1 - 0
S * |        |          |IRQSRC[29].2 - 0
S * |        |          |IRQSRC[30].0 - 0
S * |        |          |IRQSRC[30].1 - 0
S * |        |          |IRQSRC[30].2 - 0
S * |        |          |IRQSRC[31].0 - 0
S * |        |          |IRQSRC[31].1 - 0
S * |        |          |IRQSRC[31].2 - 0
S * @var GCR_INT_T::NMISEL
S * Offset: 0x80 NMI Interrupt Source Select Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[4:0]   |NMI_SEL   |NMI interrupt source selection
S * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of the interrupt[31:0]
S * |        |          |The NMI_SEL bit[4:0] used to select the NMI interrupt source
S * |[8]     |NMI_EN    |NMI interrupt enable (write-protection bit)
S * |        |          |1 = Enable NMI interrupt
S * |        |          |0 = Disable NMI interrupt
S * |        |          |This bit is the protected bit.
S * |        |          |It means programming this needs to write "59h", "16h", "88h"to address 0x5000_0100 to disable register protection.
S * |        |          |Reference the register REGWRPROT at address GCR_BA+0x100
S */
S
S    __I  uint32_t IRQSRC[32];    /* Offset: 0x00-0x7C MCU IRQn(n=0~31) Interrupt Source Identity Register            */
S    __IO uint32_t NMISEL;        /* Offset: 0x80 NMI Interrupt Source Select Control Register                        */
S
S} GCR_INT_T;
S
S
S
S/** @addtogroup INT_CONST INT Bit Field Definition
S  Constant Definitions for INT Controller
S  @{
S */
S
S/* INT IRQSRC Bit Field Definitions */
S#define INT_IRQSRC_INT_SRC_Pos                  0                                       /*!< GCR_INT_T::IRQSRC: INT_SRC Position */
S#define INT_IRQSRC_INT_SRC_Msk                  (0xFul << INT_IRQSRC_INT_SRC_Pos)       /*!< GCR_INT_T::IRQSRC: INT_SRC Mask */
S
S/* INT NMI_SEL Bit Field Definitions */
S#define INT_NMI_SEL_NMI_EN_Pos                  8                                       /*!< GCR_INT_T::NMISEL: NMI_EN Position */
S#define INT_NMI_SEL_NMI_EN_Msk                  (1ul << INT_NMI_SEL_NMI_EN_Pos)         /*!< GCR_INT_T::NMISEL: NMI_EN Mask */
S
S#define INT_NMI_SEL_NMI_SEL_Pos                 0                                       /*!< GCR_INT_T::NMISEL: NMI_SEL Position */
S#define INT_NMI_SEL_NMI_SEL_Msk                 (0x1Ful << INT_NMI_SEL_NMI_SEL_Pos)     /*!< GCR_INT_T::NMISEL: NMI_SEL Mask */
S/**@}*/ /* INT_CONST */
S/**@}*/ /* GCR */
S
S
S
S/*----------------------------- TIMER Controller -----------------------------*/
S/** @addtogroup TIMER TIMER Controller(TIMER)
S  Memory Mapped Structure for Timer Controller
S  @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var TIMER_T::TCSR
S * Offset: 0x00  Timer Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |PRESCALE  |Pre-scale Counter
S * |        |          |Clock input is divided by PRESCALE+1 before it is fed to the counter. If
S * |        |          |PRESCALE=0, then there is no scaling.
S * |[16]    |TDR_EN    |Data Load Enable
S * |        |          |When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with
S * |        |          |the 24-bit up-timer value as the timer is counting.
S * |        |          |1 = Timer Data Register update enable.
S * |        |          |0 = Timer Data Register update disable.
S * |[25]    |CACT      |Timer Active Status Bit (Read only)
S * |        |          |This bit indicates the up-timer status.
S * |        |          |0 = Timer is not active.
S * |        |          |1 = Timer is active.
S * |[26]    |CRST      |Timer Reset Bit
S * |        |          |Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to
S * |        |          |0.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.
S * |[28:27] |MODE      |Timer Operating Mode
S * |        |          |00 =
S * |        |          |The timer is operating in the one-shot mode. The associated
S * |        |          |interrupt signal is generated once (if IE is enabled) and CEN is
S * |        |          |automatically cleared by hardware.
S * |        |          |01 =
S * |        |          |The timer is operating in the periodic mode. The associated
S * |        |          |interrupt signal is generated periodically (if IE is enabled).
S * |        |          |10 =
S * |        |          |The timer is operating in the toggle mode. The interrupt signal is
S * |        |          |generated periodically (if IE is enabled). And the associated
S * |        |          |signal (tout) is changing back and forth with 50% duty cycle.
S * |        |          |11 =
S * |        |          |Reserved
S * |[29]    |IE        |Interrupt Enable Bit
S * |        |          |1 = Enable timer Interrupt.
S * |        |          |0 = Disable timer Interrupt.
S * |        |          |If timer interrupt is enabled, the timer asserts its interrupt signal when the associated
S * |        |          |up-timer value is equal to TCMPR.
S * |[30]    |CEN       |Timer Enable Bit
S * |        |          |1 = Starts counting
S * |        |          |0 = Stops/Suspends counting
S * |        |          |Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up
S * |        |          |counting from the last stop counting value.
S * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00)
S * |        |          |when the associated timer interrupt is generated (IE[29]=1).
S * @var TIMER_T::TCMPR
S * Offset: 0x04  Timer Compare Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |TCMP      |Timer Compared Value
S * |        |          |TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value
S * |        |          |is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with
S * |        |          |TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
S * |        |          |Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
S * |        |          |NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
S * |        |          |NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register,
S * |        |          |TIMER will restart counting using this new value and abort previous count.
S * @var TIMER_T::TISR
S * Offset: 0x08  Timer Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TIF       |Timer Interrupt Flag
S * |        |          |This bit indicates the interrupt status of Timer.
S * |        |          |TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer
S * |        |          |compared value (TCMP). It is cleared by writing 1 to this bit.
S * @var TIMER_T::TDR
S * Offset: 0x0C  Timer Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |TDR       |Timer Data Register
S * |        |          |When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR.
S * |        |          |User can read this register for the up-timer value.
S * @var TIMER_T::TCAP
S * ===================================================================================================
S * Offset: 0x10  Timer Capture Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |TCAP      |Timer Capture Data Register
S * |        |          |When TEXEN (TEXCON[3]) is set, RSTCAPSEL (TTXCON[4]) is 0, and the transition on the TEX pins associated TEX_EDGE(TEXCON[2:1]) setting is occurred,
S * |        |          |the internal 24-bit up-timer value will be loaded into TCAP. User can read this register for the counter value.
S * @var TIMER_T::TEXCON
S * Offset: 0x14  Timer External Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TX_PHASE  |Timer External Count Phase
S * |        |          |This bit indicates the external count pin phase.
S * |        |          |1 = A rising edge of external count pin will be counted.
S * |        |          |0 = A falling edge of external count pin will be counted.
S * |[2:1]   |TEX_EDGE  |Timer External Pin Edge Detect
S * |        |          |00 = a 1 to 0 transition on TEX will be detected.
S * |        |          |01 = a 0 to 1 transition on TEX will be detected.
S * |        |          |10 = either 1 to 0 or 0 to 1 transition on TEX will be detected.
S * |        |          |11 = Reserved.
S * |[3]     |TEXEN     |Timer External Pin Enable.
S * |        |          |This bit enables the reset/capture function on the TEX pin.
S * |        |          |1 = The transition detected on the TEX pin will result in capture or reset of timer counter.
S * |        |          |0 = The TEX pin will be ignored.
S * |[4]     |RSTCAPSEL |Timer External Reset Counter / Capture mode select
S * |        |          |1 = TEX transition is using as the timer counter reset function.
S * |        |          |0 = TEX transition is using as the timer capture function.
S * |[5]     |TEXIEN    |Timer External interrupt Enable Bit
S * |        |          |1 = Enable timer External Interrupt
S * |        |          |0 = Disable timer External Interrupt
S * |        |          |If timer external interrupt is enabled, the timer asserts its external interrupt signal and sent to NVIC to inform CPU
S * |        |          |when the transition on the TEX pins associated with TEX_EDGE(TEXCON[2:1]) setting is happened.
S * |        |          |For example, while TEXIEN = 1, TEXEN = 1, and TEX_EDGE = 00,
S * |        |          |a 1 to 0 transition on the TEX pin will cause the TEXIF(TEXISR[0]) interrupt flag to be set then the interrupt signal is generated and sent to NVIC to inform CPU.
S * |[6]     |TEXDB     |Timer External Capture pin De-bounce enable bit
S * |        |          |1 = Enable De-bounce
S * |        |          |0 = Disable De-bounce
S * |        |          |If this bit is enabled, the edge of T0EX~T3EX pin is detected with de-bounce circuit.
S * |[7]     |TCDB      |Timer Counter pin De-bounce enable bit
S * |        |          |1 = Enable De-bounce
S * |        |          |0 = Disable De-bounce
S * |        |          |If this bit is enabled, the edge of T0~T3 pin is detected with de-bounce circuit.
S * @var TIMER_T::TEXISR
S * Offset: 0x18  Timer External Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TEXIF     |Timer External Interrupt Flag
S * |        |          |This bit indicates the external interrupt status of Timer.
S * |        |          |This bit is set by hardware when TEXEN (TEXCON[3]) is to 1,and the transition on the TEX pins associated TEX_EDGE(TEXCON[2:1]) setting is occurred.
S * |        |          |It is cleared by writing 1 to this bit.
S * |        |          |For example, while TEXEN = 1, and TEX_EDGE = 00, a 1 to 0 transition on the TEX pin will cause the TEXIF to be set.
S */
S
S    __IO uint32_t TCSR;          /* Offset: 0x00  Timer Control Register                                             */
S    __IO uint32_t TCMPR;         /* Offset: 0x04  Timer Compare Register                                             */
S    __IO uint32_t TISR;          /* Offset: 0x08  Timer Interrupt Status Register                                    */
S    __IO uint32_t TDR;           /* Offset: 0x0C  Timer Data Register                                                */
S    __IO uint32_t TCAP;          /* Offset: 0x10  Timer Capture Data Register                                        */
S    __IO uint32_t TEXCON;        /* Offset: 0x14  Timer External Control Register                                    */
S    __IO uint32_t TEXISR;        /* Offset: 0x18  Timer External Interrupt Status Register                           */
S
S} TIMER_T;
S
S
S
S/** @addtogroup TMR_CONST Timer Bit Field Definition
S  Constant Definitions for Timer Controller
S  @{
S */
S
S/* TIMER TCSR Bit Field Definitions */
S#define TIMER_TCSR_DBGACK_TMR_Pos   31                                          /*!< TIMER_T::TCSR: DBGACK_TMR Position */
S#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER_T::TCSR: DBGACK_TMR Mask */
S
S#define TIMER_TCSR_CEN_Pos          30                                          /*!< TIMER_T::TCSR: CEN Position */
S#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)                 /*!< TIMER_T::TCSR: CEN Mask */
S
S#define TIMER_TCSR_IE_Pos           29                                          /*!< TIMER_T::TCSR: IE Position */
S#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)                  /*!< TIMER_T::TCSR: IE Mask */
S
S#define TIMER_TCSR_MODE_Pos         27                                          /*!< TIMER_T::TCSR: MODE Position */
S#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)              /*!< TIMER_T::TCSR: MODE Mask */
S
S#define TIMER_TCSR_CRST_Pos         26                                          /*!< TIMER_T::TCSR: CRST Position */
S#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)                /*!< TIMER_T::TCSR: CRST Mask */
S
S#define TIMER_TCSR_CACT_Pos         25                                          /*!< TIMER_T::TCSR: CACT Position */
S#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)                /*!< TIMER_T::TCSR: CACT Mask */
S
S#define TIMER_TCSR_CTB_Pos          24                                          /*!< TIMER_T::TCSR: CTB Position */
S#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)                 /*!< TIMER_T::TCSR: CTB Mask */
S
S#define TIMER_TCSR_WAKE_EN_Pos      23                                          /*!< TIMER_T::TCSR: WAKE_EN Position */
S#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)             /*!< TIMER_T::TCSR: WAKE_EN Mask */
S
S#define TIMER_TCSR_CAP_SRC_Pos      22                                          /*!< TIMER_T::TCSR: CAP_SRC Position */
S#define TIMER_TCSR_CAP_SRC_Msk      (1ul << TIMER_TCSR_CAP_SRC_Pos)             /*!< TIMER_T::TCSR: CAP_SRC Mask */
S
S#define TIMER_TCSR_TOUT_SEL_Pos     21                                          /*!< TIMER_T::TCSR: TOUT_SEL Position */
S#define TIMER_TCSR_TOUT_SEL_Msk     (1ul << TIMER_TCSR_TOUT_SEL_Pos)            /*!< TIMER_T::TCSR: TOUT_SEL Mask */
S
S#define TIMER_TCSR_ERIODIC_SEL_Pos  20                                          /*!< TIMER_T::TCSR: PERIODIC_SEL Position */
S#define TIMER_TCSR_ERIODIC_SEL_Msk  (1ul << TIMER_TCSR_ERIODIC_SEL_Pos)         /*!< TIMER_T::TCSR: PERIODIC_SEL Mask */
S
S#define TIMER_TCSR_INTR_TRG_EN_Pos  19                                          /*!< TIMER_T::TCSR: INTR_TRG_EN Position */
S#define TIMER_TCSR_INTR_TRG_EN_Msk  (1ul << TIMER_TCSR_INTR_TRG_EN_Pos)         /*!< TIMER_T::TCSR: INTR_TRG_EN Mask */
S
S#define TIMER_TCSR_TDR_EN_Pos       16                                          /*!< TIMER_T::TCSR: TDR_EN Position */
S#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)              /*!< TIMER_T::TCSR: TDR_EN Mask */
S
S#define TIMER_TCSR_PRESCALE_Pos     0                                           /*!< TIMER_T::TCSR: PRESCALE Position */
S#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)         /*!< TIMER_T::TCSR: PRESCALE Mask */
S
S/* TIMER TCMPR Bit Field Definitions */
S#define TIMER_TCMP_TCMP_Pos         0                                           /*!< TIMER_T::TCMPR: TCMP Position */
S#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)         /*!< TIMER_T::TCMPR: TCMP Mask */
S
S/* TIMER TISR Bit Field Definitions */
S#define TIMER_TISR_TWF_Pos          1                                           /*!< TIMER_T::TISR: TWF Position */
S#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)                 /*!< TIMER_T::TISR: TWF Mask */
S
S#define TIMER_TISR_TIF_Pos          0                                           /*!< TIMER_T::TISR: TIF Position */
S#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)                 /*!< TIMER_T::TISR: TIF Mask */
S
S/* TIMER TDR Bit Field Definitions */
S#define TIMER_TDR_TDR_Pos           0                                           /*!< TIMER_T::TDR: TDR Position */
S#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)           /*!< TIMER_T::TDR: TDR Mask */
S
S/* TIMER TCAP Bit Field Definitions */
S#define TIMER_TCAP_TCAP_Pos         0                                           /*!< TIMER_T::TCAP: TCAP Position */
S#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER_T::TCAP: TCAP Mask */
S
S/* TIMER TEXCON Bit Field Definitions */
S#define TIMER_TEXCON_TCDB_Pos       7                                           /*!< TIMER_T::TEXCON: TCDB Position */
S#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)              /*!< TIMER_T::TEXCON: TCDB Mask */
S
S#define TIMER_TEXCON_TEXDB_Pos      6                                           /*!< TIMER_T::TEXCON: TEXDB Position */
S#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)             /*!< TIMER_T::TEXCON: TEXDB Mask */
S
S#define TIMER_TEXCON_TEXIEN_Pos     5                                           /*!< TIMER_T::TEXCON: TEXIEN Position */
S#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)            /*!< TIMER_T::TEXCON: TEXIEN Mask */
S
S#define TIMER_TEXCON_RSTCAPSEL_Pos  4                                           /*!< TIMER_T::TEXCON: RSTCAPSEL Position */
S#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)         /*!< TIMER_T::TEXCON: RSTCAPSEL Mask */
S
S#define TIMER_TEXCON_TEXEN_Pos      3                                           /*!< TIMER_T::TEXCON: TEXEN Position */
S#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)             /*!< TIMER_T::TEXCON: TEXEN Mask */
S
S#define TIMER_TEXCON_TEX_EDGE_Pos   1                                           /*!< TIMER_T::TEXCON: TEX_EDGE Position */
S#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)        /*!< TIMER_T::TEXCON: TEX_EDGE Mask */
S
S#define TIMER_TEXCON_TX_PHASE_Pos   0                                           /*!< TIMER_T::TEXCON: TX_PHASE Position */
S#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)          /*!< TIMER_T::TEXCON: TX_PHASE Mask */
S
S/* TIMER TEXISR Bit Field Definitions */
S#define TIMER_TEXISR_TEXIF_Pos      0                                           /*!< TIMER_T::TEXISR: TEXIF Position */
S#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)             /*!< TIMER_T::TEXISR: TEXIF Mask */
S/**@}*/ /* TMR_CONST */
S/**@}*/ /* TIMER */
S
S
S
S/*------------------------- UART Interface Controller ------------------------*/
S
S/** @addtogroup UART UART Controller(UART)
S  Memory Mapped Structure for UART Serial Interface Controller
S  @{
S */
S
Stypedef struct
S{
S
S
S
S/**
S * @var UART_T::DATA
S * Offset: 0x00 UART Data Transmit/Receive Holding Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |DATA      |Data Register
S * |        |          |By writing to this register, the UART will send out an 8-bit data through the UART_TXD pin (LSB first).
S * |        |          |By reading this register, the UART will return an 8-bit data received from UART_RXD pin (LSB first).
S * @var UART_T::THR
S * Offset: 0x00 UART Transmit Holding Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |THR       |Transmit Holding Register
S * |        |          |By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB first).
S * @var UART_T::RBR
S * Offset: 0x00  UART Receive Buffer Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |RBR       |Receive Buffer Register (Read Only)
S * |        |          |By reading this register, the UART will return the 8-bit data received from RX pin (LSB first).
S * @var UART_T::IER
S * Offset: 0x04  UART Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable
S * |        |          |0 = Receive data available interrupt Disabled.
S * |        |          |1 = Receive data available interrupt Enabled.    
S * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable
S * |        |          |0 = Transmit holding register empty interrupt Disabled.
S * |        |          |1 = Transmit holding register empt interrupt Enabled.    
S * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable
S * |        |          |0 = Receive Line Status interrupt Disabled.
S * |        |          |1 = Receive Line Status interrupt Enabled.    
S * |[3]     |MODEM_IEN |Modem Status Interrupt Enable
S * |        |          |0 = Modem status interrupt Disabled.
S * |        |          |1 = Modem status interrupt Enabled.    
S * |[4]     |RTO_IEN   |RX Time-out Interrupt Enable
S * |        |          |0 = RX time-out interrupt Disabled.
S * |        |          |1 = RX time-out interrupt Enabled.     
S * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable
S * |        |          |0 = Buffer error interrupt Disabled.
S * |        |          |1 = Buffer error interrupt Enabled.   
S * |[6]     |WAKE_EN   |UART Wake-up Function Enable
S * |        |          |0 = UART wake-up function Disabled.
S * |        |          |1 = UART wake-up function Enabled, when chip is in Power-down mode, an external CTS change will wake up chip from Power-down mode.     
S * |[8]     |LIN_RX_BRK_IEN|LIN RX Break Field Detected Interrupt Enable Control
S * |        |          |0 = LIN bus RX break filed interrupt Disabled.
S * |        |          |1 = LIN bus RX break filed interrupt Enabled.
S * |        |          |Note: This bit is used for LIN function mode.     
S * |[11]    |TIME_OUT_EN|Time-out Counter Enable
S * |        |          |0 = Time-out counter Disabled.
S * |        |          |1 = Time-out counter Enabled.     
S * |[12]    |AUTO_RTS_EN|RTS Auto Flow Control Enable
S * |        |          |0 = RTS auto flow control Disabled.
S * |        |          |1 = RTS auto flow control Enabled.
S * |        |          |Note: When RTS auto-flow is enabled, if the number of bytes in the RX FIFO is equal to the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.    
S * |[13]    |AUTO_CTS_EN|CTS Auto Flow Control Enable
S * |        |          |0 = CTS auto flow control Disabled.
S * |        |          |1 = CTS auto flow control Enabled.
S * |        |          |Note: When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).
S * @var UART_T::FCR
S * Offset: 0x08  UART FIFO Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |RFR       |RX Field Software Reset
S * |        |          |When RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the RX internal state machine and pointers.
S * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
S * |[2]     |TFR       |TX Field Software Reset
S * |        |          |When TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the TX internal state machine and pointers.
S * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
S * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
S * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if RDA_IEN(UA_IER[0]) enabled, and an interrupt will be generated).
S * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
S * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
S * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
S * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
S * |[8]     |RX_DIS    |Receiver Disable 
S * |        |          |The receiver is disabled or not (set 1 to disable receiver)
S * |        |          |0 = Receiver Enabled.
S * |        |          |1 = Receiver Disabled.
S * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS485_NMM(UA_ALT_CSR [8]) is programmed.
S * |[19:16] |RTS_TRI_LEV|RTS Trigger Level For Auto-Flow Control Use
S * |        |          |0000 = RTS Trigger Level is 1 byte.
S * |        |          |0001 = RTS Trigger Level is 4 bytes.
S * |        |          |0010 = RTS Trigger Level is 8 bytes.
S * |        |          |0011 = RTS Trigger Level is 14 bytes.
S * |        |          |Note: This field is used for RTS auto-flow control.
S * @var UART_T::LCR
S * Offset: 0x0C  UART Line Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |WLS       |Word Length Select
S * |        |          |This field sets UART word length.    
S * |        |          |00 = 5 bits.
S * |        |          |01 = 6 bits.
S * |        |          |10 = 7 bits.
S * |        |          |11 = 8 bits.
S * |[2]     |NSB       |Number of "STOP bit"
S * |        |          |0 = One "STOP bit" is generated in the transmitted data.
S * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data. When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.     
S * |[3]     |PBE       |Parity Bit Enable
S * |        |          |0 = No parity bit.
S * |        |          |1 = Parity bit generated Enabled.
S * |        |          |Note : Parity bit is generated on each outgoing character and is checked on each incoming data.     
S * |[4]     |EPE       |Even Parity Enable
S * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
S * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
S * |        |          |Note: This bit has effect only when PBE (UA_LCR[3]) is set.     
S * |[5]     |SPE       |Stick Parity Enable
S * |        |          |0 = Stick parity Disabled.
S * |        |          |1 = Stick parity Enabled.
S * |        |          |Note: If PBE (UA_LCR[3]) and EPE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EPE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1.     
S * |[6]     |BCB       |Break Control Bit
S * |        |          |0 = Break Control Disabled.
S * |        |          |1 = Break Control Enabled.
S * |        |          |Note: When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.
S * @var UART_T::MCR
S * Offset: 0x10  UART Modem Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |RTS       |RTS (Request-To-Send) Signal Control
S * |        |          |This bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.
S * |        |          |0 = RTS signal is active.
S * |        |          |1 = RTS signal is inactive.
S * |        |          |Note1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.
S * |        |          |Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
S * |[9]     |LEV_RTS   |RTS Pin Active Level 
S * |        |          |This bit defines the active level state of RTS pin output.
S * |        |          |0 = RTS pin output is high level active.
S * |        |          |1 = RTS pin output is low level active.
S * |[13]    |RTS_ST    |RTS Pin State (Read Only)
S * |        |          |This bit mirror from RTS pin output of voltage logic status.
S * |        |          |0 = RTS pin output is low level voltage logic state.
S * |        |          |1 = RTS pin output is high level voltage logic state.
S * @var UART_T::MSR
S * Offset: 0x14  UART Modem Status Register 
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |DCTSF     |Detect CTS State Change Flag (Read Only)
S * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.
S * |        |          |0 = CTS input has not change state.
S * |        |          |1 = CTS input has change state.
S * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S * |[4]     |CTS_ST    |CTS Pin Status (Read Only) 
S * |        |          |This bit mirror from CTS pin input of voltage logic status.
S * |        |          |0 = CTS pin input is low level voltage logic state.
S * |        |          |1 = CTS pin input is high level voltage logic state.
S * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected
S * |[8]     |LEV_CTS   |CTS Pin Active Level
S * |        |          |This bit defines the active level state of CTS pin input.
S * |        |          |0 = CTS pin input is high level active.
S * |        |          |1 = CTS pin input is low level active.
S * @var UART_T::FSR
S * Offset: 0x18  UART FIFO Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RX_OVER_IF|RX Overflow Error Interrupt Flag
S * |        |          |This bit is set when RX FIFO overflow.
S * |        |          |If the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, this bit will be set.
S * |        |          |0 = RX FIFO is not overflow.
S * |        |          |1 = RX FIFO is overflow.
S * |        |          |Note: This bit can be cleared by writing "1" to it.     
S * |[3]     |RS485_ADD_DETF|RS-485 Address Byte Detection Flag
S * |        |          |0 = Receiver detects a data that is not an address byte (bit 9 = "0").
S * |        |          |1 = Receiver detects a data that is an address byte (bit 9 = "1").
S * |        |          |Note1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode .
S * |        |          |Note2: This bit can be cleared by writing "1" to it.     
S * |[4]     |PEF       |Parity Error Flag
S * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
S * |        |          |0 = No parity error is generated.
S * |        |          |1 = Parity error is generated.
S * |        |          |Note: This bit can be cleared by writing "1" to it.
S * |[5]     |FEF       |Framing Error Flag
S * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.
S * |        |          |0 = No framing error is generated.
S * |        |          |1 = Framing error is generated.
S * |        |          |Note: This bit can be cleared by writing "1" to it.
S * |[6]     |BIF       |Break Interrupt Flag
S * |        |          |This bit is set to logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
S * |        |          |0 = No Break interrupt is generated.
S * |        |          |1 = Break interrupt is generated.
S * |        |          |Note: This bit can be cleared by writing "1" to it.
S * |[13:8]  |RX_POINTER|RX FIFO Pointer     
S * |        |          |This field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, RX_POINTER increases one. When one byte of RX FIFO is read by CPU, RX_POINTER decreases one.
S * |        |          |The Maximum value shown in RX_POINTER is 15. When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RXPTR will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15.     
S * |[14]    |RX_EMPTY  |Receiver FIFO Empty (Read Only)
S * |        |          |This bit initiate RX FIFO empty or not.
S * |        |          |0 = RX FIFO is not empty.
S * |        |          |1 = RX FIFO is empty.
S * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.     
S * |[15]    |RX_FULL   |Receiver FIFO Full (Read Only)
S * |        |          |This bit indicates RX FIFO full or not.
S * |        |          |0 = RX FIFO is not full.
S * |        |          |1 = RX FIFO is full.
S * |        |          |Note: This bit is set when the using level of RX FIFO Buffer equal to 16; otherwise, it is cleared by hardware. 
S * |[21:16] |TX_POINTER|TX FIFO Pointer (Read Only)     
S * |        |          |This field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, TX_POINTER decreases one.
S * |        |          |The Maximum value shown in TX_POINTER is 15. When the using level of TX FIFO Buffer equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15.     
S * |[22]    |TX_EMPTY  |Transmitter FIFO Empty (Read Only)
S * |        |          |This bit indicates TX FIFO is empty or not.
S * |        |          |0 = TX FIFO is not empty.     
S * |        |          |1 = TX FIFO is empty.
S * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into UA_THR (TX FIFO not empty).     
S * |[23]    |TX_FULL   |Transmitter FIFO Full (Read Only)
S * |        |          |This bit indicates TX FIFO full or not.
S * |        |          |0 = TX FIFO is not full.
S * |        |          |1 = TX FIFO is full.
S * |        |          |Note: This bit is set when the using level of TX FIFO Buffer equal to 16; otherwise, it is cleared by hardware.     
S * |[24]    |TX_OVER_IF|Tx Overflow Error Interrupt Flag     
S * |        |          |If TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1.
S * |        |          |0 = TX FIFO is not overflow.
S * |        |          |1 = TX FIFO is overflow.
S * |        |          |Note: This bit can be cleared by writing "1" to it.     
S * |[28]    |TE_FLAG   |Transmitter Empty Flag (Read Only)
S * |        |          |This bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.
S * |        |          |0 = TX FIFO is not empty or the STOP bit of the last byte has been not transmitted.
S * |        |          |1 = TX FIFO is empty and the STOP bit of the last byte has been transmitted.
S * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
S * @var UART_T::ISR
S * Offset: 0x1C  UART Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only)
S * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set.
S * |        |          |If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.
S * |        |          |0 = No RDA interrupt flag is generated.
S * |        |          |1 = RDA interrupt flag is generated.
S * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4])).
S * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only)
S * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
S * |        |          |If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.
S * |        |          |0 = No THRE interrupt flag is generated.
S * |        |          |1 = THRE interrupt flag is generated.
S * |        |          |Note: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).
S * |[2]     |RLS_IF    |Receive Line Interrupt Flag (Read Only)
S * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set).
S * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
S * |        |          |0 = No RLS interrupt flag is generated.
S * |        |          |1 = RLS interrupt flag is generated.
S * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received address byte character (bit9 = '1') bit.
S * |        |          |At the same time, the bit of UA_FSR[RS485_ADD_DETF] is also set.
S * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.
S * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.
S * |[3]     |MODEM_IF  |MODEM Interrupt Flag (Read Only) 
S * |        |          |This bit is set when the CTS pin has state change (DCTSF (UA_MSR[0]) = 1).
S * |        |          |If MODEM_IEN (UA_IER [3]) is enabled, the Modem interrupt will be generated.
S * |        |          |0 = No Modem interrupt flag is generated.
S * |        |          |1 = Modem interrupt flag is generated.
S * |        |          |Note: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).
S * |[4]     |TOUT_IF   |Time-Out Interrupt Flag (Read Only)
S * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
S * |        |          |If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.
S * |        |          |0 = No Time-out interrupt flag is generated.
S * |        |          |1 = Time-out interrupt flag is generated.
S * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it
S * |[5]     |BUF_ERR_IF|Buffer Error Interrupt Flag (Read Only)
S * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set).
S * |        |          |When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct.
S * |        |          |If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.
S * |        |          |0 = No buffer error interrupt flag is generated.
S * |        |          |1 = Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is generated.
S * |        |          |1 = Buffer error interrupt flag is generated.
S * |        |          |Note: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared
S * |[7]     |LIN_RX_BREAK_IF|LIN Bus RX Break Field Detected Flag
S * |        |          |This bit is set when RX received LIN Break Field. If LIN_RX_BRK_IEN(UA_IER[8]) is enabled the LIN RX Break interrupt will be generated.
S * |        |          |0 = No LIN RX Break received.
S * |        |          |1 = LIN RX Break received.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator (Read Only)
S * |        |          |This bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.
S * |        |          |0 = No RDA interrupt is generated.
S * |        |          |1 = RDA interrupt is generated.
S * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator (Read Only)
S * |        |          |This bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.
S * |        |          |0 = No THRE interrupt is generated.
S * |        |          |1 = THRE interrupt is generated.
S * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator (Read Only)
S * |        |          |This bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.
S * |        |          |0 = No RLS interrupt is generated.
S * |        |          |1 = RLS interrupt is generated
S * |[11]    |MODEM_INT |MODEM Status Interrupt Indicator (Read Only)
S * |        |          |This bit is set if MODEM_IEN(UA_IER[3]) and MODEM_IF(UA_ISR[4]) are both set to 1
S * |        |          |0 = No Modem interrupt is generated.
S * |        |          |1 = Modem interrupt is generated.
S * |[12]    |TOUT_INT  |Time-Out Interrupt Indicator (Read Only)
S * |        |          |This bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.
S * |        |          |0 = No Tout interrupt is generated.
S * |        |          |1 = Tout interrupt is generated.
S * |[13]    |BUF_ERR_INT|Buffer Error Interrupt Indicator (Read Only)
S * |        |          |This bit is set if BUF_ERR_IEN(UA_IER[5]) and BUF_ERR_IF(UA_ISR[5]) are both set to 1.
S * |        |          |0 = No buffer error interrupt is generated.
S * |        |          |1 = Buffer error interrupt is generated.
S * |[15]    |LIN_RX_BREAK_INT|LIN Bus RX Break Field Detected Interrupt Indicator (Read Only)
S * |        |          |This bit is set if LIN_RX_BRK_IEN(UA_IER[8]) and LIN_RX_BRK_IFLIN_IF(UA_ISR[7]) are both set to 1.
S * |        |          |0 = No LIN RX Break interrupt is generated.
S * |        |          |1 = LIN RX Break interrupt is generated.
S * @var UART_T::TOR
S * Offset: 0x20  UART Time-out Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TOIC      |Time-Out Interrupt Comparator
S * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.
S * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UA_TOR[7:0])), a receiver time-out interrupt (INT_TOUT) is generated if TOUT_IEN (UA_IER [4]) enabled.
S * |        |          |A new incoming data word or RX FIFO empty will clear TOUT_INT(UA_IER[9]).
S * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC (UA_TOR[7:0]) value should be set between 40 and 255.
S * |        |          |So, for example, if TOIC (UA_TOR[7:0]) is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
S * |[15:8]  |DLY       |TX Delay Time Value
S * |        |          |This field is used to programming the transfer delay time between the last stop bit and next start bit.
S * @var UART_T::BAUD
S * Offset: 0x24  UART Baud Rate Divisor Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |BRD       |Baud Rate Divider
S * |        |          |The field indicates the baud rate divider.
S * |[27:24] |DIVIDER_X |Divider X
S * |        |          |The baud rate divider M = X+1.
S * |[28]    |DIV_X_ONE |Divider X Equal To 1
S * |        |          |0 = Divider M is X+1 (the equation of M = X+1, but DIVIDER_X[27:24] must >= 8).
S * |        |          |1 = Divider M is 1 (the equation of M = 1, but BRD [15:0] must >= 3).  
S * |[29]    |DIV_X_EN  |Divider X Enable
S * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is
S * |        |          |Baud Rate = Clock / [M * (BRD + 2)]; The default value of M is 16.
S * |        |          |0 = Divider X Disabled (the equation of M = 16).
S * |        |          |1 = Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must >= 8).
S * |        |          |Note: In IrDA mode, this bit must disable.
S * @var UART_T::IRCR
S * Offset: 0x28  UART IrDA Control Register 
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |TX_SELECT |TX_SELECT
S * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled.
S * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
S * |[5]     |INV_TX    |IrDA inverse Transmitting Output Signal Control
S * |        |          |0 = None inverse transmitting signal.
S * |        |          |1 = Inverse transmitting output signal.
S * |[6]     |INV_RX    |IrDA inverse Receive Input Signal Control
S * |        |          |0 = None inverse receiving input signal.
S * |        |          |1 = Inverse receiving input signal.
S * @var UART_T::ALT_CSR
S * Offset: 0x2C  UART Alternate Control/Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |LIN_BKFL  |UART LIN Break Field Length
S * |        |          |This field indicates a 4-bit LIN TX break field count.
S * |        |          |Note1: This break field length is UA_LIN_BKFL + 1.
S * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
S * |[6]     |LIN_RX_EN |LIN RX Enable
S * |        |          |0 = LIN RX mode Disabled.
S * |        |          |1 = LIN RX mode Enabled.
S * |[7]     |LIN_TX_EN |LIN TX Break Mode Enable
S * |        |          |0 = LIN TX Break mode Disabled.
S * |        |          |1 = LIN TX Break mode Enabled.
S * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
S * |[8]     |RS485_NMM |RS-485 Normal Multi-Drop Operation Mode (NMM)
S * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
S * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
S * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
S * |[9]     |RS485_AAD |RS-485 Auto Address Detection Operation Mode (AAD)
S * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
S * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
S * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
S * |[10]    |RS485_AUD |RS-485 Auto Direction Mode (AUD)
S * |        |          |0 = RS-485 Auto Direction Operation mode (AUO) Disabled.
S * |        |          |1 = RS-485 Auto Direction Operation mode (AUO) Enabled.
S * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
S * |[15]    |RS485_ADD_EN|RS-485 Address Detection Enable
S * |        |          |This bit is used to enable RS-485 Address Detection mode.
S * |        |          |0 = Address detection mode Disabled.
S * |        |          |1 = Address detection mode Enabled.
S * |        |          |Note: This bit is used for RS-485 any operation mode.
S * |[31:24] |ADDR_MATCH|Address Match Value
S * |        |          |This field contains the RS-485 address match values.
S * |        |          |Note: This field is used for RS-485 auto address detection mode.
S * @var UART_T::FUN_SEL
S * Offset: 0x30  UART Function Select Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |FUN_SEL   |Function Select Enable
S * |        |          |00 = UART Function.
S * |        |          |01 = LIN Function.
S * |        |          |10 = IrDA Function.
S * |        |          |11 = RS-485 Function.
S */
S
S    union {
S        __IO uint32_t DATA;          /* Offset: 0x00 UART Transmit Holding Register                                      */
S        __IO uint32_t THR;           /* Offset: 0x00 UART Transmit Holding Register                                      */
S        __IO uint32_t RBR;           /* Offset: 0x00 UART Receive Buffer Register                                        */
S    };
S    __IO uint32_t IER;           /* Offset: 0x04  UART Interrupt Enable Register                                     */
S    __IO uint32_t FCR;           /* Offset: 0x08  UART FIFO Control Register                                         */
S    __IO uint32_t LCR;           /* Offset: 0x0C  UART Line Control Register                                         */
S    __IO uint32_t MCR;           /* Offset: 0x10  UART Modem Control Register                                        */
S    __IO uint32_t MSR;           /* Offset: 0x14  UART Modem Status Register                                         */
S    __IO uint32_t FSR;           /* Offset: 0x18  UART FIFO Status Register                                          */
S    __IO uint32_t ISR;           /* Offset: 0x1C  UART Interrupt Status Register                                     */
S    __IO uint32_t TOR;           /* Offset: 0x20  UART Time-out Register                                             */
S    __IO uint32_t BAUD;          /* Offset: 0x24  UART Baud Rate Divisor Register                                    */
S    __IO uint32_t IRCR;          /* Offset: 0x28  UART IrDA Control Register                                         */
S    __IO uint32_t ALT_CSR;       /* Offset: 0x2C  UART Alternate Control/Status Register                             */
S    __IO uint32_t FUN_SEL;       /* Offset: 0x30  UART Function Select Register                                      */
S} UART_T;
S
S
S
S/** @addtogroup UART_CONST UART Bit Field Definition
S  Constant Definitions for UART Controller
S  @{
S */
S
S/* UART THR Bit Field Definitions */
S#define UART_THR_THR_Pos            0                                       /*!< UART_T::THR: THR Position  */
S#define UART_THR_THR_Msk            (0xFul << UART_THR_THR_Pos)             /*!< UART_T::THR: THR Mask      */
S
S/* UART RBR Bit Field Definitions */
S#define UART_RBR_RBR_Pos            0                                       /*!< UART_T::RBR: RBR Position */
S#define UART_RBR_RBR_Msk            (0xFul << UART_RBR_RBR_Pos)             /*!< UART_T::RBR: RBR Mask      */
S
S/* UART IER Bit Field Definitions */
S#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART_T::IER: AUTO_CTS_EN Position      */
S#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART_T::IER: AUTO_CTS_EN Mask           */
S
S#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART_T::IER: AUTO_RTS_EN Position      */
S#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART_T::IER: AUTO_RTS_EN Mask           */
S
S#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART_T::IER: TIME_OUT_EN Position      */
S#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART_T::IER: TIME_OUT_EN Mask           */
S
S#define UART_IER_LIN_RX_BRK_IEN_Pos 8                                       /*!< UART_T::IER: LIN_RX_BRK_IEN Position   */
S#define UART_IER_LIN_RX_BRK_IEN_Msk (1ul << UART_IER_LIN_RX_BRK_IEN_Pos)    /*!< UART_T::IER: LIN_RX_BRK_IEN Mask        */
S
S#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART_T::IER: WAKE_EN Position          */
S#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART_T::IER: WAKE_EN Mask               */
S
S#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART_T::IER: BUF_ERR_IEN Position      */
S#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART_T::IER: BUF_ERR_IEN Mask           */
S
S#define UART_IER_RTO_IEN_Pos        4                                       /*!< UART_T::IER: RTO_IEN Position          */
S#define UART_IER_RTO_IEN_Msk        (1ul << UART_IER_RTO_IEN_Pos)           /*!< UART_T::IER: RTO_IEN Mask               */
S
S#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART_T::IER: MODEM_IEN Position        */
S#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART_T::IER: MODEM_IEN Mask             */
S
S#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART_T::IER: RLS_IEN Position          */
S#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART_T::IER: RLS_IEN Mask               */
S
S#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART_T::IER: THRE_IEN Position         */
S#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART_T::IER: THRE_IEN Mask              */
S
S#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART_T::IER: RDA_IEN Position           */
S#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART_T::IER: RDA_IEN Mask               */
S
S/* UART FCR Bit Field Definitions */
S#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART_T::FCR: RTS_TRI_LEV Position       */
S#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART_T::FCR: RTS_TRI_LEV Mask           */
S
S#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART_T::FCR: RX_DIS Position            */
S#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART_T::FCR: RX_DIS Mask                */
S
S#define UART_FCR_RFITL_Pos          4                                       /*!< UART_T::FCR: RFITL Position             */
S#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART_T::FCR: RFITL Mask                 */
S
S#define UART_FCR_TFR_Pos            2                                       /*!< UART_T::FCR: TFR Position               */
S#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART_T::FCR: TFR Mask                   */
S
S#define UART_FCR_RFR_Pos            1                                       /*!< UART_T::FCR: RFR Position               */
S#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART_T::FCR: RFR Mask                   */
S
S/* UART LCR Bit Field Definitions */
S#define UART_LCR_BCB_Pos            6                                       /*!< UART_T::LCR: BCB Position               */
S#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART_T::LCR: BCB Mask                   */
S
S#define UART_LCR_SPE_Pos            5                                       /*!< UART_T::LCR: SPE Position               */
S#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART_T::LCR: SPE Mask                   */
S
S#define UART_LCR_EPE_Pos            4                                       /*!< UART_T::LCR: EPE Position               */
S#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART_T::LCR: EPE Mask                   */
S
S#define UART_LCR_PBE_Pos            3                                       /*!< UART_T::LCR: PBE Position               */
S#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART_T::LCR: PBE Mask                   */
S
S#define UART_LCR_NSB_Pos            2                                       /*!< UART_T::LCR: NSB Position               */
S#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART_T::LCR: NSB Mask                   */
S
S#define UART_LCR_WLS_Pos            0                                       /*!< UART_T::LCR: WLS Position               */
S#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART_T::LCR: WLS Mask                   */
S
S/* UART MCR Bit Field Definitions */
S#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART_T::MCR: RTS_ST Position            */
S#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART_T::MCR: RTS_ST Mask                */
S
S#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART_T::MCR: LEV_RTS Position           */
S#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART_T::MCR: LEV_RTS Mask               */
S
S#define UART_MCR_RTS_Pos            1                                       /*!< UART_T::MCR: RTS Position               */
S#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART_T::MCR: RTS Mask                   */
S
S/* UART MSR Bit Field Definitions */
S#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART_T::MSR: LEV_CTS Position           */
S#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART_T::MSR: LEV_CTS Mask               */
S
S#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART_T::MSR: CTS_ST Position            */
S#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART_T::MSR: CTS_ST Mask                */
S
S#define UART_MSR_DCTSF_Pos          0                                       /*!< UART_T::MSR: DCTST Position             */
S#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART_T::MSR: DCTST Mask                 */
S
S/* UART FSR Bit Field Definitions */
S#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART_T::FSR: TE_FLAG Position           */
S#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART_T::FSR: TE_FLAG Mask               */
S
S#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART_T::FSR: TX_OVER_IF Position        */
S#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART_T::FSR: TX_OVER_IF Mask            */
S
S#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART_T::FSR: TX_FULL Position           */
S#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART_T::FSR: TX_FULL Mask               */
S
S#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART_T::FSR: TX_EMPTY Position          */
S#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART_T::FSR: TX_EMPTY Mask              */
S
S#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART_T::FSR: TX_POINTER Position        */
S#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART_T::FSR: TX_POINTER Mask            */
S
S#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART_T::FSR: RX_FULL Position           */
S#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART_T::FSR: RX_FULL Mask               */
S
S#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART_T::FSR: RX_EMPTY Position          */
S#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART_T::FSR: RX_EMPTY Mask              */
S
S#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART_T::FSR: RX_POINTERS Position       */
S#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART_T::FSR: RX_POINTER Mask            */
S
S#define UART_FSR_BIF_Pos            6                                       /*!< UART_T::FSR: BIF Position               */
S#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART_T::FSR: BIF Mask                   */
S
S#define UART_FSR_FEF_Pos            5                                       /*!< UART_T::FSR: FEF Position               */
S#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART_T::FSR: FEF Mask                   */
S
S#define UART_FSR_PEF_Pos            4                                       /*!< UART_T::FSR: PEF Position               */
S#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART_T::FSR: PEF Mask                   */
S
S#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART_T::FSR: RS485_ADD_DETF Position    */
S#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART_T::FSR: RS485_ADD_DETF Mask        */
S
S#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART_T::FSR: RX_OVER_IF Position        */
S#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART_T::FSR: RX_OVER_IF Mask            */
S
S/* UART ISR Bit Field Definitions */
S#define UART_ISR_LIN_RX_BREAK_INT_Pos    15                                      /*!< UART_T::ISR: LIN_RX_BREAK_INT Position       */
S#define UART_ISR_LIN_RX_BREAK_INT_Msk    (1ul << UART_ISR_LIN_RX_BREAK_INT_Pos)  /*!< UART_T::ISR: LIN_RX_BREAK_INT Mask           */
S
S#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART_T::ISR: BUF_ERR_INT Position       */
S#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART_T::ISR: BUF_ERR_INT Mask           */
S
S#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART_T::ISR: TOUT_INT Position          */
S#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART_T::ISR: TOUT_INT Mask              */
S
S#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART_T::ISR: MODEM_INT Position         */
S#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART_T::ISR: MODEM_INT Mask             */
S
S#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART_T::ISR: RLS_INT Position           */
S#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART_T::ISR: RLS_INT Mask               */
S
S#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART_T::ISR: THRE_INT Position          */
S#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART_T::ISR: THRE_INT Mask              */
S
S#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART_T::ISR: RDA_INT Position           */
S#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART_T::ISR: RDA_INT Mask               */
S
S#define UART_ISR_LIN_RX_BREAK_IF_Pos 7                                      /*!< UART_T::ISR: LIN RX BREAK IF Position   */
S#define UART_ISR_LIN_RX_BREAK_IF_Msk (1ul << UART_ISR_LIN_RX_BREAK_IF_Pos)  /*!< UART_T::ISR: LIN RX BREAK IF Mask       */
S
S#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART_T::ISR: BUF_ERR_IF Position        */
S#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART_T::ISR: BUF_ERR_IF Mask            */
S
S#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART_T::ISR: TOUT_IF Position           */
S#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART_T::ISR: TOUT_IF Mask               */
S
S#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART_T::ISR: MODEM_IF Position          */
S#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART_T::ISR: MODEM_IF Mask              */
S
S#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART_T::ISR: RLS_IF Position            */
S#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART_T::ISR: RLS_IF Mask                */
S
S#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART_T::ISR: THRE_IF Position           */
S#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART_T::ISR: THRE_IF Mask               */
S
S#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART_T::ISR: RDA_IF Position            */
S#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART_T::ISR: RDA_IF Mask                */
S
S/* UART TOR Bit Field Definitions */
S#define UART_TOR_DLY_Pos            8                                       /*!< UART_T::TOR: DLY Position               */
S#define UART_TOR_DLY_Msk            (0xFFul << UART_TOR_DLY_Pos)            /*!< UART_T::TOR: DLY Mask                   */
S
S#define UART_TOR_TOIC_Pos           0                                       /*!< UART_T::TOR: TOIC Position              */
S#define UART_TOR_TOIC_Msk           (0xFFul << UART_TOR_TOIC_Pos)           /*!< UART_T::TOR: TOIC Mask                  */
S
S/* UART BAUD Bit Field Definitions */
S#define UART_BAUD_DIV_X_EN_Pos      29                                      /*!< UART_T::BAUD: DIV_X_EN Position         */
S#define UART_BAUD_DIV_X_EN_Msk      (1ul << UART_BAUD_DIV_X_EN_Pos)         /*!< UART_T::BAUD: DIV_X_EN Mask             */
S
S#define UART_BAUD_DIV_X_ONE_Pos     28                                      /*!< UART_T::BAUD: DIV_X_ONE Position        */
S#define UART_BAUD_DIV_X_ONE_Msk     (1ul << UART_BAUD_DIV_X_ONE_Pos)        /*!< UART_T::BAUD: DIV_X_ONE Mask            */
S
S#define UART_BAUD_DIVIDER_X_Pos     24                                      /*!< UART_T::BAUD: DIVIDER_X Position        */
S#define UART_BAUD_DIVIDER_X_Msk     (0xFul << UART_BAUD_DIVIDER_X_Pos)      /*!< UART_T::BAUD: DIVIDER_X Mask            */
S
S#define UART_BAUD_BRD_Pos           0                                       /*!< UART_T::BAUD: BRD Position              */
S#define UART_BAUD_BRD_Msk           (0xFFFFul << UART_BAUD_BRD_Pos)         /*!< UART_T::BAUD: BRD Mask                  */
S
S/* UART IRCR Bit Field Definitions */
S#define UART_IRCR_INV_RX_Pos        6                                       /*!< UART_T::IRCR: INV_RX Position           */
S#define UART_IRCR_INV_RX_Msk        (1ul << UART_IRCR_INV_RX_Pos)           /*!< UART_T::IRCR: INV_RX Mask               */
S
S#define UART_IRCR_INV_TX_Pos        5                                       /*!< UART_T::IRCR: INV_TX Position           */
S#define UART_IRCR_INV_TX_Msk        (1ul << UART_IRCR_INV_TX_Pos)           /*!< UART_T::IRCR: INV_TX Mask               */
S
S#define UART_IRCR_TX_SELECT_Pos     1                                       /*!< UART_T::IRCR: TX_SELECT Position        */
S#define UART_IRCR_TX_SELECT_Msk     (1ul << UART_IRCR_TX_SELECT_Pos)        /*!< UART_T::IRCR: TX_SELECT Mask            */
S
S/* UART ALT_CSR Bit Field Definitions */
S#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART_T::ALT_CSR: ADDR_MATCH Position    */
S#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART_T::ALT_CSR: ADDR_MATCH Mask        */
S
S#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART_T::ALT_CSR: RS485_ADD_EN Position  */
S#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART_T::ALT_CSR: RS485_ADD_EN Mask      */
S
S#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART_T::ALT_CSR: RS485_AUD Position     */
S#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART_T::ALT_CSR: RS485_AUD Mask         */
S
S#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART_T::ALT_CSR: RS485_AAD Position     */
S#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART_T::ALT_CSR: RS485_AAD Mask         */
S
S#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART_T::ALT_CSR: RS485_NMM Position     */
S#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART_T::ALT_CSR: RS485_NMM Mask         */
S
S#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Position     */
S#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Mask         */
S
S#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART_T::ALT_CSR: LIN RX Enable Position     */
S#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN RX Enable Mask         */
S
S#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART_T::ALT_CSR: UART LIN Break Field Length Position     */
S#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART_T::ALT_CSR: UART LIN Break Field Length Mask         */
S
S/* UART FUN_SEL Bit Field Definitions */
S#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART_T::FUN_SEL: FUN_SEL Position       */
S#define UART_FUN_SEL_FUN_SEL_Msk        (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)      /*!< UART_T::FUN_SEL: FUN_SEL Mask           */
S/**@}*/ /* UART_CONST */
S/**@}*/ /* UART */
S
S
S
S/*----------------------------- WDT Controller -----------------------------*/
S/** @addtogroup WDT WDT Controller(WDT)
S  Memory Mapped Structure for Watchdog Timer
S  @{
S */
S
Stypedef struct
S{
S
S
S/**
S * @var WDT_T::WTCR
S * Offset: 0x00  Watchdog Timer Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WTR       |Clear Watchdog Timer
S * |        |          |Set this bit will clear the Watchdog timer.
S * |        |          |0= Writing 0 to this bit has no effect
S * |        |          |1= Reset the contents of the Watchdog timer
S * |        |          |NOTE: This bit will auto clear after few clock cycle
S * |[1]     |WTRE      |Watchdog Timer Reset Enable
S * |        |          |Setting this bit will enable the Watchdog timer reset function.
S * |        |          |0= Disable Watchdog timer reset function
S * |        |          |1= Enable Watchdog timer reset function
S * |[2]     |WTRF      |Watchdog Timer Reset Flag
S * |        |          |When the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by
S * |        |          |software to determine the source of reset. Software is responsible to clear it manually by writing 1 to
S * |        |          |it. If WTRE is disabled, then the Watchdog timer has no effect on this bit.
S * |        |          |0= Watchdog timer reset does not occur
S * |        |          |1= Watchdog timer reset occurs
S * |        |          |NOTE: This bit is cleared by writing 1 to this bit.
S * |[3]     |WTIF      |Watchdog Timer Interrupt Flag
S * |        |          |If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the
S * |        |          |Watchdog timer interrupt has occurred. If the Watchdog timer interrupt is not enabled, then this bit
S * |        |          |indicates that a timeout period has elapsed.
S * |        |          |0= Watchdog timer interrupt does not occur
S * |        |          |1= Watchdog timer interrupt occurs
S * |        |          |NOTE: Write 1 to clear this bit to zero.
S * |[4]     |WTWKE     |Watchdog Timer Wakeup Function Enable bit
S * |        |          |0 = Disable Watchdog timer Wakeup CPU function.
S * |        |          |1 = Enable the Wakeup function that Watchdog timer timeout can wake up CPU from power-down
S * |        |          |mode.
S * |[5]     |WTWKF     |Watchdog Timer Wakeup Flag
S * |        |          |If Watchdog timer causes CPU wakes up from power-down mode, this bit will be set to high. It must
S * |        |          |be cleared by software with a write 1 to this bit.
S * |        |          |1 = CPU wake up from sleep or power-down mode by Watchdog timeout.
S * |        |          |0 = Watchdog timer does not cause CPU wakeup.
S * |        |          |NOTE: Write 1 to clear this bit to zero.
S * |[6]     |WTIE      |Watchdog Timer Interrupt Enable
S * |        |          |0= Disable the Watchdog timer interrupt
S * |        |          |1= Enable the Watchdog timer interrupt
S * |[7]     |WTE       |Watchdog Timer Enable
S * |        |          |0= Disable the Watchdog timer (This action will reset the internal counter)
S * |        |          |1= Enable the Watchdog timer
S * |[10:8]  |WTIS      |Watchdog Timer Interval Select (write protection bit)
S * |        |          |These three bits select the timeout interval for the Watchdog timer.
S * @var WDT_T::WTCRALT
S * Offset: 0x04  Watchdog Timer Alternative Control Register
S * ---------------------------------------------------------------------------------------------------
S */
S
S    __IO uint32_t WTCR;          /* Offset: 0x00  Watchdog Timer Control Register                                    */
S    __IO uint32_t WTCRALT;       /* Offset: 0x04  Watchdog Timer Alternative Control Register                        */
S
S} WDT_T;
S
S
S
S/** @addtogroup WDT_CONST WDT Bit Field Definition
S  Constant Definitions for WDT Controller
S  @{
S */
S
S/* WDT WTCR Bit Field Definitions */
S#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT_T::WTCR: DBGACK_WDT Position */
S#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT_T::WTCR: DBGACK_WDT Mask */
S
S#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT_T::WTCR: WTIS Position */
S#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT_T::WTCR: WTIS Mask */
S
S#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT_T::WTCR: WTE Position */
S#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT_T::WTCR: WTE Mask */
S
S#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT_T::WTCR: WTIE Position */
S#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT_T::WTCR: WTIE Mask */
S
S#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT_T::WTCR: WTWKF Position */
S#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT_T::WTCR: WTWKF Mask */
S
S#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT_T::WTCR: WTWKE Position */
S#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT_T::WTCR: WTWKE Mask */
S
S#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT_T::WTCR: WTIF Position */
S#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT_T::WTCR: WTIF Mask */
S
S#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT_T::WTCR: WTRF Position */
S#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT_T::WTCR: WTRF Mask */
S
S#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT_T::WTCR: WTRE Position */
S#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT_T::WTCR: WTRE Mask */
S
S#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT_T::WTCR: WTR Position */
S#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT_T::WTCR: WTR Mask */
S
S/* WDT WTCRALT Bit Field Definitions */
S#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT_T::WTCRALT: WTRDSEL Position */
S#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT_T::WTCRALT: WTRDSEL Mask */
S/**@}*/ /* WDT_CONST */
S/**@}*/ /* WDT */
S
S
S/*----------------------------- WWDT Controller -----------------------------*/
S/** @addtogroup WWDT Window Watchdog Timer (WWDT)
S  Register data structure of Window Watchdog Timer and relative constant definitions.
S  @{
S */
S
Stypedef struct
S{
S
S
S
S/**
S * @var WWDT_T::WWDTRLD
S * ===================================================================================================
S * Offset: 0x00  WWDT Reload Counter Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |WWDTRLD   |WWDT Reload Counter Register
S * |        |          |Writing 0x00005AA5 to this register will reload the Window Watchdog Timer counter value to 0x3F.
S * |        |          |Note: Software can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP.
S * |        |          |If software writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal will generate immediately.
S * @var WWDT_T::WWDTCR
S * Offset: 0x04  Window Watchdog Timer Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WWDTEN    |WWDT Enable
S * |        |          |Set this bit to enable Window Watchdog Timer counter counting.
S * |        |          |0 = Window Watchdog Timer counter is stopped.
S * |        |          |1 = Window Watchdog Timer counter is starting counting.
S * |[1]     |WWDTIE    |WWDT Interrupt Enable
S * |        |          |Setting this bit to enable the Window Watchdog Timer time-out interrupt function.
S * |        |          |0 = WWDT time-out interrupt function Disabled if WWDTIF (WWDTSR[0] WWDT compare match interrupt flag) is 1.
S * |        |          |1 = WWDT time-out interrupt function Enabled if WWDTIF (WWDTSR[0] WWDT compare match interrupt flag) is 1.
S * |[11:8]  |PERIODSEL |WWDT Pre-scale Period Select
S * |        |          |These 4-bit select the pre-scale period for the WWDT counter period.
S * |        |          |PERIODSEL Pre-scale Value Time out Period Max. Time out Interval (WWDT_CLK=10 kHz)
S * |        |          |Timeout period = Pre-scale * 64 * WWDT_CLK.
S * |        |          |PERIODSEL={0,1,2,3, 4, 5, 6,  7,  8,  9, 10, 11, 12,  13,  14,  15}
S * |        |          |Pre-scale={1,2,4,8,16,32,64,128,192,256,384,512,768,1024,1536,2048}
S * |[21:16] |WINCMP    |WWDT Window Compare Register
S * |        |          |Set this register to adjust the valid reload window.
S * |        |          |Note: Software can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP.
S * |        |          |If Software writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal will generate immediately.
S * |[31]    |DBGACK_WWDT|ICE debug mode acknowledge Disable
S * |        |          |0 = WWDT counter stopped if system is in Debug mode.
S * |        |          |1 = WWDT still counted even system is in Debug mode.
S * @var WWDT_T::WWDTSR
S * Offset: 0x08  Window Watchdog Timer Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
S * |        |          |When current WWDT counter value matches to WWCMP, this bit is set to 1. This bit will be cleared by writing 1 to itself.
S * |[1]     |WWDTRF    |WWDT Reset Flag
S * |        |          |When WWDT counter counts down to 0 or writes WWDTRLD during current WWDT counter value larger than WINCMP,
S * |        |          |chip will be reset and this bit is set to 1. This bit will be cleared to 0 by writing 1 to itself.
S * @var WWDT_T::WWDTCVR
S * Offset: 0x0C  Watchdog Timer Alternative Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |WWDTCVAL  |WWDT Counter Value
S * |        |          |This register reflects the current WWDT counter value and this register is read only.
S */
S
S    __IO uint32_t WWDTRLD;       /* Offset: 0x00  WWDT Reload Counter Register                                       */
S    __IO uint32_t WWDTCR;        /* Offset: 0x04  Window Watchdog Timer Control Register                             */
S    __IO uint32_t WWDTSR;        /* Offset: 0x08  Window Watchdog Timer Status Register                              */
S    __IO uint32_t WWDTCVR;       /* Offset: 0x0C  Watchdog Timer Alternative Control Register                        */
S
S} WWDT_T;
S
S
S
S/** @addtogroup WWDT_CONST WWDT Bit Field Definition
S  Constant Definitions for WWDT Controller
S  @{
S */
S
S/* WWDT WWDTRLD Bit Field Definitions */
S#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT_T::WWDTRLD: WWDTRLD Position */
S#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT_T::WWDTRLD: WWDTRLD Mask */
S
S/* WWDT WWDTCR Bit Field Definitions */
S#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT_T::WWDTCR: DBGACK_WWDT Position */
S#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT_T::WWDTCR: DBGACK_WWDT Mask */
S
S#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT_T::WWDTCR: WINCMP Position */
S#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT_T::WWDTCR: WINCMP Mask */
S
S#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT_T::WWDTCR: PERIODSEL Position */
S#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT_T::WWDTCR: PERIODSEL Mask */
S
S#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT_T::WWDTCR: WWDTIE Position */
S#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT_T::WWDTCR: WWDTIE Mask */
S
S#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT_T::WWDTCR: WWDTEN Position */
S#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_WWDTEN_Pos)             /*!< WWDT_T::WWDTCR: WWDTEN Mask */
S
S/* WWDT WWDTSR Bit Field Definitions */
S#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT_T::WWDTSR: WWDTRF Position */
S#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT_T::WWDTSR: WWDTRF Mask */
S
S#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT_T::WWDTSR: WWDTIF Position */
S#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT_T::WWDTSR: WWDTIF Mask */
S
S/* WWDT WWDTCVR Bit Field Definitions */
S#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT_T::WWDTCVR: WWDTRF Position */
S#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT_T::WWDTCVR: WWDTRF Mask */
S/**@}*/ /* end of group WWDT_CONST */
S/**@}*/ /* end of group WWDT */
S/**@}*/ /* end of group REGISTER */
S
S
S/******************************************************************************/
S/*                         Peripheral memory map                              */
S/******************************************************************************/
S/** @addtogroup PERIPHERAL_BASE Peripheral Memory Base
S  Memory Mapped Structure for Series Peripheral
S  @{
S */
S/* Peripheral and SRAM base address */
S#define FLASH_BASE          ((     uint32_t)0x00000000)
S#define SRAM_BASE           ((     uint32_t)0x20000000)
S#define AHB_BASE            ((     uint32_t)0x50000000)
S#define APB1_BASE           ((     uint32_t)0x40000000)
S#define APB2_BASE           ((     uint32_t)0x40100000)
S
S/* Peripheral memory map */
S#define GPIO_BASE           (AHB_BASE       + 0x4000)                   /*!< GPIO Base Address                                   */
S#define P0_BASE             (GPIO_BASE              )                   /*!< GPIO P0 Base Address                                */
S#define P1_BASE             (GPIO_BASE      + 0x0040)                   /*!< GPIO P1 Base Address                                */
S#define P2_BASE             (GPIO_BASE      + 0x0080)                   /*!< GPIO P2 Base Address                                */
S#define P3_BASE             (GPIO_BASE      + 0x00C0)                   /*!< GPIO P3 Base Address                                */
S#define P4_BASE             (GPIO_BASE      + 0x0100)                   /*!< GPIO P4 Base Address                                */
S#define GPIO_DBNCECON_BASE  (GPIO_BASE      + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
S#define GPIO_PIN_DATA_BASE  (GPIO_BASE      + 0x0200)                   /*!< GPIO Pin Data Input/Output Control Base Address     */
S
S#define UART0_BASE          (APB1_BASE      + 0x50000)                  /*!< UART0 Base Address                               */
S#define UART1_BASE          (APB2_BASE      + 0x50000)                  /*!< UART1 Base Address                               */
S
S#define TIMER0_BASE         (APB1_BASE      + 0x10000)                  /*!< Timer0 Base Address                              */
S#define TIMER1_BASE         (APB1_BASE      + 0x10020)                  /*!< Timer1 Base Address                              */
S#define TIMER2_BASE         (APB2_BASE      + 0x10000)                  /*!< Timer2 Base Address                              */
S#define TIMER3_BASE         (APB2_BASE      + 0x10020)                  /*!< Timer3 Base Address                              */
S
S#define WDT_BASE            (APB1_BASE      + 0x4000)                   /*!< Watch Dog Timer Base Address                     */
S
S#define WWDT_BASE           (APB1_BASE      + 0x4100)                   /*!< Window Watch Dog Timer Base Address              */
S
S#define SPI0_BASE           (APB1_BASE      + 0x30000)                  /*!< SPI0 Base Address                                */
S#define SPI1_BASE           (APB1_BASE      + 0x34000)                  /*!< SPI1 Base Address                                */
S
S#define I2C0_BASE           (APB1_BASE      + 0x20000)                  /*!< I2C0 Base Address                                */
S#define I2C1_BASE           (APB2_BASE      + 0x20000)                  /*!< I2C1 Base Address                                */
S
S#define RTC_BASE            (APB1_BASE      + 0x08000)                  /*!< RTC Base Address                                 */
S
S#define ADC_BASE            (APB1_BASE      + 0xE0000)                  /*!< ADC Base Address                                 */
S
S#define ACMP01_BASE         (APB1_BASE      + 0xD0000)                  /*!< ACMP01 Base Address                              */
S#define ACMP23_BASE         (APB2_BASE      + 0xD0000)                  /*!< ACMP23 Base Address                              */
S
S#define CLK_BASE            (AHB_BASE       + 0x00200)                  /*!< System Clock Controller Base Address             */
S
S#define GCR_BASE            (AHB_BASE       + 0x00000)                  /*!< System Global Controller Base Address            */
S
S#define INT_BASE            (AHB_BASE       + 0x00300)                  /*!< Interrupt Source Controller Base Address         */
S
S#define FMC_BASE            (AHB_BASE       + 0x0C000)                  /*!< Flash Memory Controller Base Address             */
S
S#define PWMA_BASE           (APB1_BASE      + 0x40000)                  /*!< PWMA Base Address                                */
S#define PWMB_BASE           (APB2_BASE      + 0x40000)                  /*!< PWMB Base Address                                */
S
S#define EBI_BASE            (AHB_BASE       + 0x10000)                  /*!< EBI Base Address                                 */
S
S#define HDIV_BASE           (AHB_BASE       + 0x14000)                  /*!< HDIV Base Address                                */
S
S/**@}*/ /* PERIPHERAL */
S
S/******************************************************************************/
S/*                         Peripheral declaration                             */
S/******************************************************************************/
S
S/** @addtogroup PMODULE Peripheral Pointer
S  The Declaration of Peripheral Pointer
S  @{
S */
S#define P0                  ((GPIO_T *) P0_BASE)                        /*!< GPIO PORT0 Configuration Struct                        */
S#define P1                  ((GPIO_T *) P1_BASE)                        /*!< GPIO PORT1 Configuration Struct                        */
S#define P2                  ((GPIO_T *) P2_BASE)                        /*!< GPIO PORT2 Configuration Struct                        */
S#define P3                  ((GPIO_T *) P3_BASE)                        /*!< GPIO PORT3 Configuration Struct                        */
S#define P4                  ((GPIO_T *) P4_BASE)                        /*!< GPIO PORT4 Configuration Struct                        */
S#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */
S
S#define UART0               ((UART_T *) UART0_BASE)                     /*!< UART0 Configuration Struct                       */
S#define UART1               ((UART_T *) UART1_BASE)                     /*!< UART1 Configuration Struct                       */
S
S#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< TIMER0 Configuration Struct                      */
S#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< TIMER1 Configuration Struct                      */
S#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< TIMER2 Configuration Struct                      */
S#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< TIMER3 Configuration Struct                      */
S
S#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watch Dog Timer Configuration Struct             */
S
S#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watch Dog Timer Configuration Struct      */
S
S#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
S#define SPI1                ((SPI_T *) SPI1_BASE)                       /*!< SPI1 Configuration Struct                        */
S
S#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
S#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
S
S#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
S
S#define ACMP01              ((ACMP_T *) ACMP01_BASE)                    /*!< ACMP01 Configuration Struct                      */
S#define ACMP23              ((ACMP_T *) ACMP23_BASE)                    /*!< ACMP23 Configuration Struct                      */
S
S#define CLK                 ((CLK_T *) CLK_BASE)                        /*!< System Clock Controller Configuration Struct     */
S
S#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
S
S#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
S
S#define FMC                 ((FMC_T *) FMC_BASE)                        /*!< Flash Memory Controller */
S
S#define PWMA                ((PWM_T *) PWMA_BASE)                       /*!< PWMA Configuration Struct                        */
S#define PWMB                ((PWM_T *) PWMB_BASE)                       /*!< PWMB Configuration Struct                        */
S
S#define EBI                 ((EBI_T *) EBI_BASE)                        /*!< EBI Configuration Struct                         */
S
S#define HDIV                ((HDIV_T *) HDIV_BASE)                      /*!< HDIV Configuration Struct                         */
S
S/**@}*/ /* end of group PMODULE */
S
S
S//=============================================================================
Stypedef volatile unsigned char  vu8;
Stypedef volatile unsigned long  vu32;
Stypedef volatile unsigned short vu16;
S#define M8(adr)  (*((vu8  *) (adr)))
S#define M16(adr) (*((vu16 *) (adr)))
S#define M32(adr) (*((vu32 *) (adr)))
S
S#define outpw(port,value)   (*((volatile unsigned int *)(port))=(value))
S#define inpw(port)          ((*((volatile unsigned int *)(port))))
S#define outpb(port,value)   (*((volatile unsigned char *)(port))=(value))
S#define inpb(port)          ((*((volatile unsigned char *)(port))))
S#define outps(port,value)   (*((volatile unsigned short *)(port))=(value))
S#define inps(port)          ((*((volatile unsigned short *)(port))))
S
S#define outp32(port,value)  (*((volatile unsigned int *)(port))=(value))
S#define inp32(port)         ((*((volatile unsigned int *)(port))))
S#define outp8(port,value)   (*((volatile unsigned char *)(port))=(value))
S#define inp8(port)          ((*((volatile unsigned char *)(port))))
S#define outp16(port,value)  (*((volatile unsigned short *)(port))=(value))
S#define inp16(port)         ((*((volatile unsigned short *)(port))))
S
S
S#define E_SUCCESS   0
S#ifndef NULL
S#define NULL        0
S#endif
S
S#define TRUE        1
S#define FALSE       0
S
S#define ENABLE      1
S#define DISABLE     0
S
S/* Bit Mask Definitions */
S#define BIT0    0x00000001
S#define BIT1    0x00000002
S#define BIT2    0x00000004
S#define BIT3    0x00000008
S#define BIT4    0x00000010
S#define BIT5    0x00000020
S#define BIT6    0x00000040
S#define BIT7    0x00000080
S#define BIT8    0x00000100
S#define BIT9    0x00000200
S#define BIT10   0x00000400
S#define BIT11   0x00000800
S#define BIT12   0x00001000
S#define BIT13   0x00002000
S#define BIT14   0x00004000
S#define BIT15   0x00008000
S#define BIT16   0x00010000
S#define BIT17   0x00020000
S#define BIT18   0x00040000
S#define BIT19   0x00080000
S#define BIT20   0x00100000
S#define BIT21   0x00200000
S#define BIT22   0x00400000
S#define BIT23   0x00800000
S#define BIT24   0x01000000
S#define BIT25   0x02000000
S#define BIT26   0x04000000
S#define BIT27   0x08000000
S#define BIT28   0x10000000
S#define BIT29   0x20000000
S#define BIT30   0x40000000
S#define BIT31   0x80000000
S
S
S/* Byte Mask Definitions */
S#define BYTE0_Msk               (0x000000FF)
S#define BYTE1_Msk               (0x0000FF00)
S#define BYTE2_Msk               (0x00FF0000)
S#define BYTE3_Msk               (0xFF000000)
S
S#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
S#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
S#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
S#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
S
S
S/******************************************************************************/
S/*                         Peripheral header files                            */
S/******************************************************************************/
S#include "sys.h"
S#include "clk.h"
S#include "adc.h"
S#include "ebi.h"
S#include "fmc.h"
S#include "gpio.h"
S#include "i2c.h"
S#include "pwm.h"
S#include "spi.h"
S#include "timer.h"
S#include "wdt.h"
S#include "wwdt.h"
S#include "uart.h"
S#include "hdiv.h"
S#include "acmp.h"
N#endif
N
N/* Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved. */
N
N
N
L 18 "..\..\..\..\Library\StdDriver\inc\fmc.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup FMC_Driver FMC Driver
N  @{
N*/
N
N/** @addtogroup FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_FLASH_PAGE_SIZE     0x200           /*!< Flash Page Size (512 Bytes) */
N#define FMC_LDROM_SIZE          0x1000          /*!< LDROM Size (4 KBytes)       */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCON constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCON_BS_LDROM     0x2     /*!< ISPCON setting to select to boot from LDROM */
N#define FMC_ISPCON_BS_APROM     0x0     /*!< ISPCON setting to select to boot from APROM */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ        0x00     /*!< ISP Command: Read Flash       */
N#define FMC_ISPCMD_PROGRAM     0x21     /*!< ISP Command: Program Flash    */
N#define FMC_ISPCMD_PAGE_ERASE  0x22     /*!< ISP Command: Page Erase Flash */
N#define FMC_ISPCMD_VECMAP      0x2e     /*!< ISP Command: Set VECMAP       */
N#define FMC_ISPCMD_READ_UID    0x04     /*!< ISP Command: Read Unique ID   */
N#define FMC_ISPCMD_READ_CID    0x0B     /*!< ISP Command: Read Company ID   */
N#define FMC_ISPCMD_READ_DID    0x0C     /*!< ISP Command: Read Device ID    */
N
N
N/*@}*/ /* end of group FMC_EXPORTED_CONSTANTS */
N
N/** @addtogroup FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FMC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Enable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCON control register to enable ISP function.
N *
N */
N#define FMC_ENABLE_ISP()          (FMC->ISPCON |=  FMC_ISPCON_ISPEN_Msk)
N
N
N/**
N * @brief      Disable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear ISPEN bit of ISPCON control register to disable ISP function.
N *
N */
N#define FMC_DISABLE_ISP()         (FMC->ISPCON &= ~FMC_ISPCON_ISPEN_Msk)
N
N
N/**
N * @brief      Enable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set LDUEN bit of ISPCON control register to enable LDROM update function.
N *             User needs to set LDUEN bit before they can update LDROM.
N *
N */
N#define FMC_ENABLE_LD_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_LDUEN_Msk)
N
N
N
N/**
N * @brief      Disable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCON control register to disable LDROM update function.
N *
N */
N#define FMC_DISABLE_LD_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_LDUEN_Msk)  /*!< Disable LDROM Update Function  */
N
N
N
N/**
N * @brief      Enable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set CFGUEN bit of ISPCON control register to enable User Configuration update function.
N *             User needs to set CFGUEN bit before they can update User Configuration area.
N *
N */
N#define FMC_ENABLE_CFG_UPDATE()   (FMC->ISPCON |=  FMC_ISPCON_CFGUEN_Msk)
N
N/**
N * @brief      Disable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear CFGUEN bit of ISPCON control register to disable User Configuration update function.
N *
N */
N#define FMC_DISABLE_CFG_UPDATE()  (FMC->ISPCON &= ~FMC_ISPCON_CFGUEN_Msk) /*!< Disable CONFIG Update Function */
N
N
N/**
N * @brief      Enable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set APUEN bit of ISPCON control register to enable APROM update function.
N *             User needs to set APUEN bit before they can update APROM in APROM boot mode.
N *
N */
N#define FMC_ENABLE_AP_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_APUEN_Msk)
N
N
N/**
N * @brief      Disable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear APUEN bit of ISPCON control register to disable APROM update function.
N *
N */
N#define FMC_DISABLE_AP_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_APUEN_Msk)  /*!< Disable APROM Update Function  */
N
N/**
N * @brief      Get ISP fail flag
N *
N * @param      None
N *
N * @retval     0 Previous ISP command execution result is successful
N * @retval     1 Previous ISP command execution result is fail
N *
N * @details    ISPFF flag of ISPCON is used to indicate ISP command success or fail.
N *             This function will return the ISPFF flag to identify ISP command OK or fail.
N *
N */
N#define FMC_GET_FAIL_FLAG()       ((FMC->ISPCON & FMC_ISPCON_ISPFF_Msk) ? 1 : 0)
N
N
N/**
N * @brief      Select booting from APROM
N *
N * @param      None
N *
N * @return     None
N *
N * @details    If MCU is working without IAP, user need to set BS bit of ISPCON and reset CPU to execute the code of LDROM/APROM.
N *             This function is used to set BS bit of ISPCON to boot to APROM.
N *
N * @note       To valid new BS bit setting, user also need to trigger CPU reset or System Reset Request after setting BS bit.
N *
N */
N#define FMC_SET_APROM_BOOT()      (FMC->ISPCON &= ~FMC_ISPCON_BS_Msk)
N
N/**
N * @brief      Select booting from APROM
N *
N * @param      None
N *
N * @return     None
N *
N * @details    If MCU is working without IAP, user need to set/clear BS bit of ISPCON and reset CPU to execute the code of APROM/LDROM.
N *             This function is used to clear BS bit of ISPCON to boot to LDROM.
N *
N * @note       To valid new BS bit setting, user also need to trigger CPU reset or System Reset Request after clear BS bit.
N *
N */
N#define FMC_SET_LDROM_BOOT()      (FMC->ISPCON |= FMC_ISPCON_BS_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Program 32-bit data into specified address of flash
N *
N * @param[in]  u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  u32data  32-bit Data to program
N *
N * @return     None
N *
N * @details    To program word data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of Technical Reference Manual.
N *
N */
Nstatic __INLINE void FMC_Write(uint32_t u32addr, uint32_t u32data)
Xstatic __inline void FMC_Write(uint32_t u32addr, uint32_t u32data)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PROGRAM;   /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x21;    
N    FMC->ISPADR = u32addr;              /* Set Target ROM Address. The address must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;               
N    FMC->ISPDAT = u32data;              /* Set Data to Program */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = u32data;               
N    FMC->ISPTRG = 0x1;                  /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                   
N    __ISB();                            /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                             
N    while(FMC->ISPTRG);                 /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                  
N}
N
N/**
N * @brief       Read 32-bit Data from specified address of flash
N *
N * @param[in]   u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N *
N * @return      The data of specified address
N *
N * @details     To read word data from Flash include APROM, LDROM, Data Flash, and CONFIG.
N *
N */
Nstatic __INLINE uint32_t FMC_Read(uint32_t u32addr)
Xstatic __inline uint32_t FMC_Read(uint32_t u32addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x00;  
N    FMC->ISPADR = u32addr;         /* Set Target ROM Address. The address must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;          
N    FMC->ISPTRG = 0x1;             /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;              
N    __ISB();                       /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                        
N    while(FMC->ISPTRG);            /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);             
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N * @brief      Flash page erase
N *
N * @param[in]  u32addr  Flash address including APROM, LDROM, Data Flash, and CONFIG
N *
N * @details    To do flash page erase. The target address could be APROM, LDROM, Data Flash, or CONFIG.
N *             The page size is 512 bytes.
N *
N * @retval      0 Success
N * @retval     -1 Erase failed
N *
N */
Nstatic __INLINE int32_t FMC_Erase(uint32_t u32addr)
Xstatic __inline int32_t FMC_Erase(uint32_t u32addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x22;  
N    FMC->ISPADR = u32addr;               /* Set Target ROM Address. The address must be page alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;                
N    FMC->ISPTRG = 0x1;                   /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                    
N    __ISB();                             /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                              
N    while(FMC->ISPTRG);                  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                   
N
N    /* Check ISPFF flag to know whether erase OK or fail. */
N    if(FMC->ISPCON & FMC_ISPCON_ISPFF_Msk)
X    if(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCON & (1ul << 6))
N    {
N        FMC->ISPCON |= FMC_ISPCON_ISPFF_Msk;
X        ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCON |= (1ul << 6);
N        return -1;
N    }
N    return 0;
N}
N
N/**
N * @brief       Read Unique ID
N *
N * @param[in]   u8index  UID index. 0 = UID[31:0], 1 = UID[63:32], 2 = UID[95:64]
N *
N * @return      The 32-bit unique ID data of specified UID index.
N *
N * @details     To read out 96-bit Unique ID.
N *
N */
Nstatic __INLINE uint32_t FMC_ReadUID(uint8_t u8index)
Xstatic __inline uint32_t FMC_ReadUID(uint8_t u8index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;  
N    FMC->ISPADR = (u8index << 2);      /* Set UID Address. It must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = (u8index << 2);       
N    FMC->ISPTRG = 0x1;                 /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                  
N    __ISB();                           /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                            
N    while(FMC->ISPTRG);                /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                 
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N  * @brief    Read company ID
N  *
N  * @param    None
N  *
N  * @return   The company ID (32-bit)
N  *
N  * @details  The company ID of Nuvoton is fixed to be 0xDA
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadCID(void)
Xstatic __inline uint32_t FMC_ReadCID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_CID;           /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0B;            
N    FMC->ISPADR = 0x0;                           /* Must keep 0x0 when read CID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = 0x0;                            
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;          /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);           
N    __ISB();                                     /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                      
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) ;  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0)) ;   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief    Read product ID
N  *
N  * @param    None
N  *
N  * @return   The product ID (32-bit)
N  *
N  * @details  This function is used to read product ID.
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadPID(void)
Xstatic __inline uint32_t FMC_ReadPID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_DID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0C;           
N    FMC->ISPADR = 0x04;                         /* Must keep 0x4 when read PID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = 0x04;                          
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);          
N    __ISB();                                    /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                     
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief      To read UCID
N  *
N  * @param[in]  u32Index    Index of the UCID to read. u32Index must be 0, 1, 2, or 3.
N  *
N  * @return     The UCID of specified index
N  *
N  * @details    This function is used to read unique chip ID (UCID).
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadUCID(uint32_t u32Index)
Xstatic __inline uint32_t FMC_ReadUCID(uint32_t u32Index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;           
N    FMC->ISPADR = (0x04 * u32Index) + 0x10;     /* The UCID is at offset 0x10 with word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = (0x04 * u32Index) + 0x10;      
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);          
N    __ISB();                                    /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                     
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N
N/**
N * @brief       Set vector mapping address
N *
N * @param[in]   u32PageAddr  The page address to remap to address 0x0. The address must be page alignment.
N *
N * @return      None
N *
N * @details     This function is used to set VECMAP to map specified page to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
Xstatic __inline void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_VECMAP; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x2e;  
N    FMC->ISPADR = u32PageAddr;       /* The address of specified page which will be map to address 0x0. It must be page alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32PageAddr;        
N    FMC->ISPTRG = 0x1;               /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                
N    __ISB();                         /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                          
N    while(FMC->ISPTRG);              /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);               
N}
N
N
N/**
N * @brief       Get current vector mapping address.
N *
N * @param       None
N *
N * @return      The current vector mapping address.
N *
N * @details     To get VECMAP value which is the page address for remapping to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE uint32_t FMC_GetVECMAP(void)
Xstatic __inline uint32_t FMC_GetVECMAP(void)
N{
N    return (FMC->ISPSTA & FMC_ISPSTA_VECMAP_Msk);
X    return (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPSTA & (0xffful << 9));
N}
N
Nextern void FMC_Open(void);
Nextern void FMC_Close(void);
Nextern void FMC_EnableAPUpdate(void);
Nextern void FMC_DisableAPUpdate(void);
Nextern void FMC_EnableConfigUpdate(void);
Nextern void FMC_DisableConfigUpdate(void);
Nextern void FMC_EnableLDUpdate(void);
Nextern void FMC_DisableLDUpdate(void);
Nextern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern void FMC_SetBootSource(int32_t i32BootSrc);
Nextern int32_t FMC_GetBootSource(void);
Nextern uint32_t FMC_ReadDataFlashBaseAddr(void);
N
N/*@}*/ /* end of group FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group FMC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif
N
L 5969 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "gpio.h"
L 1 "..\..\..\..\Library\StdDriver\inc\gpio.h" 1
N/**************************************************************************//**
N * @file     GPIO.h
N * @version  V2.1
N * $Revision: 15 $
N * $Date: 17/10/05 1:49p $
N * @brief    M051 Series General Purpose I/O Driver Header File
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N#include "M051Series.h"
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N#define GPIO_PIN_MAX            8 /*!< Specify Maximum Pins of Each GPIO Port */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_PMD_INPUT          0x0UL /*!< Input Mode */
N#define GPIO_PMD_OUTPUT         0x1UL /*!< Output Mode */
N#define GPIO_PMD_OPEN_DRAIN     0x2UL /*!< Open-Drain Mode */
N#define GPIO_PMD_QUASI          0x3UL /*!< Quasi-bidirectional Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING         0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING        0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE      0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH           0x01010000UL /*!< Interrupt enable by Level-High */
N#define GPIO_INT_LOW            0x01000001UL /*!< Interrupt enable by Level-Level */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IMD_EDGE           0UL /*!< IMD Setting for Edge Trigger Mode */
N#define GPIO_IMD_LEVEL          1UL /*!< IMD Setting for Edge Level Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBNCECON Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_CLK_ON         0x00000020UL /*!< DBNCECON setting for all IO pins edge detection circuit is always active after reset */
N#define GPIO_INT_CLK_OFF        0x00000000UL /*!< DBNCECON setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */
N
N#define GPIO_DBCLKSRC_LIRC      0x00000010UL /*!< DBNCECON setting for de-bounce counter clock source is the internal 10 kHz */
N#define GPIO_DBCLKSRC_HCLK      0x00000000UL /*!< DBNCECON setting for de-bounce counter clock source is the HCLK */
N
N#define GPIO_DBCLKSEL_1         0x00000000UL /*!< DBNCECON setting for sampling cycle = 1 clocks */
N#define GPIO_DBCLKSEL_2         0x00000001UL /*!< DBNCECON setting for sampling cycle = 2 clocks */
N#define GPIO_DBCLKSEL_4         0x00000002UL /*!< DBNCECON setting for sampling cycle = 4 clocks */
N#define GPIO_DBCLKSEL_8         0x00000003UL /*!< DBNCECON setting for sampling cycle = 8 clocks */
N#define GPIO_DBCLKSEL_16        0x00000004UL /*!< DBNCECON setting for sampling cycle = 16 clocks */
N#define GPIO_DBCLKSEL_32        0x00000005UL /*!< DBNCECON setting for sampling cycle = 32 clocks */
N#define GPIO_DBCLKSEL_64        0x00000006UL /*!< DBNCECON setting for sampling cycle = 64 clocks */
N#define GPIO_DBCLKSEL_128       0x00000007UL /*!< DBNCECON setting for sampling cycle = 128 clocks */
N#define GPIO_DBCLKSEL_256       0x00000008UL /*!< DBNCECON setting for sampling cycle = 256 clocks */
N#define GPIO_DBCLKSEL_512       0x00000009UL /*!< DBNCECON setting for sampling cycle = 512 clocks */
N#define GPIO_DBCLKSEL_1024      0x0000000AUL /*!< DBNCECON setting for sampling cycle = 1024 clocks */
N#define GPIO_DBCLKSEL_2048      0x0000000BUL /*!< DBNCECON setting for sampling cycle = 2048 clocks */
N#define GPIO_DBCLKSEL_4096      0x0000000CUL /*!< DBNCECON setting for sampling cycle = 4096 clocks */
N#define GPIO_DBCLKSEL_8192      0x0000000DUL /*!< DBNCECON setting for sampling cycle = 8192 clocks */
N#define GPIO_DBCLKSEL_16384     0x0000000EUL /*!< DBNCECON setting for sampling cycle = 16384 clocks */
N#define GPIO_DBCLKSEL_32768     0x0000000FUL /*!< DBNCECON setting for sampling cycle = 32768 clocks */
N
N/** Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N *  Example 1:
N *
N *      P00 = 1;
N *
N *  It is used to set P0.0 to high;
N *
N *  Example 2:
N *
N *      if (P00)
N *          P00 = 0;
N *
N *  If P0.0 pin status is high, then set P0.0 data output to low.
N */
N#define GPIO_PIN_ADDR(port, pin)    (*((volatile uint32_t *)((GPIO_PIN_DATA_BASE+(0x20*(port))) + ((pin)<<2))))
N#define P00             GPIO_PIN_ADDR(0, 0) /*!< Specify P00 Pin Data Input/Output */
N#define P01             GPIO_PIN_ADDR(0, 1) /*!< Specify P01 Pin Data Input/Output */
N#define P02             GPIO_PIN_ADDR(0, 2) /*!< Specify P02 Pin Data Input/Output */
N#define P03             GPIO_PIN_ADDR(0, 3) /*!< Specify P03 Pin Data Input/Output */
N#define P04             GPIO_PIN_ADDR(0, 4) /*!< Specify P04 Pin Data Input/Output */
N#define P05             GPIO_PIN_ADDR(0, 5) /*!< Specify P05 Pin Data Input/Output */
N#define P06             GPIO_PIN_ADDR(0, 6) /*!< Specify P06 Pin Data Input/Output */
N#define P07             GPIO_PIN_ADDR(0, 7) /*!< Specify P07 Pin Data Input/Output */
N#define P10             GPIO_PIN_ADDR(1, 0) /*!< Specify P10 Pin Data Input/Output */
N#define P11             GPIO_PIN_ADDR(1, 1) /*!< Specify P11 Pin Data Input/Output */
N#define P12             GPIO_PIN_ADDR(1, 2) /*!< Specify P12 Pin Data Input/Output */
N#define P13             GPIO_PIN_ADDR(1, 3) /*!< Specify P13 Pin Data Input/Output */
N#define P14             GPIO_PIN_ADDR(1, 4) /*!< Specify P14 Pin Data Input/Output */
N#define P15             GPIO_PIN_ADDR(1, 5) /*!< Specify P15 Pin Data Input/Output */
N#define P16             GPIO_PIN_ADDR(1, 6) /*!< Specify P16 Pin Data Input/Output */
N#define P17             GPIO_PIN_ADDR(1, 7) /*!< Specify P17 Pin Data Input/Output */
N#define P20             GPIO_PIN_ADDR(2, 0) /*!< Specify P20 Pin Data Input/Output */
N#define P21             GPIO_PIN_ADDR(2, 1) /*!< Specify P21 Pin Data Input/Output */
N#define P22             GPIO_PIN_ADDR(2, 2) /*!< Specify P22 Pin Data Input/Output */
N#define P23             GPIO_PIN_ADDR(2, 3) /*!< Specify P23 Pin Data Input/Output */
N#define P24             GPIO_PIN_ADDR(2, 4) /*!< Specify P24 Pin Data Input/Output */
N#define P25             GPIO_PIN_ADDR(2, 5) /*!< Specify P25 Pin Data Input/Output */
N#define P26             GPIO_PIN_ADDR(2, 6) /*!< Specify P26 Pin Data Input/Output */
N#define P27             GPIO_PIN_ADDR(2, 7) /*!< Specify P27 Pin Data Input/Output */
N#define P30             GPIO_PIN_ADDR(3, 0) /*!< Specify P30 Pin Data Input/Output */
N#define P31             GPIO_PIN_ADDR(3, 1) /*!< Specify P31 Pin Data Input/Output */
N#define P32             GPIO_PIN_ADDR(3, 2) /*!< Specify P32 Pin Data Input/Output */
N#define P33             GPIO_PIN_ADDR(3, 3) /*!< Specify P33 Pin Data Input/Output */
N#define P34             GPIO_PIN_ADDR(3, 4) /*!< Specify P34 Pin Data Input/Output */
N#define P35             GPIO_PIN_ADDR(3, 5) /*!< Specify P35 Pin Data Input/Output */
N#define P36             GPIO_PIN_ADDR(3, 6) /*!< Specify P36 Pin Data Input/Output */
N#define P37             GPIO_PIN_ADDR(3, 7) /*!< Specify P37 Pin Data Input/Output */
N#define P40             GPIO_PIN_ADDR(4, 0) /*!< Specify P40 Pin Data Input/Output */
N#define P41             GPIO_PIN_ADDR(4, 1) /*!< Specify P41 Pin Data Input/Output */
N#define P42             GPIO_PIN_ADDR(4, 2) /*!< Specify P42 Pin Data Input/Output */
N#define P43             GPIO_PIN_ADDR(4, 3) /*!< Specify P43 Pin Data Input/Output */
N#define P44             GPIO_PIN_ADDR(4, 4) /*!< Specify P44 Pin Data Input/Output */
N#define P45             GPIO_PIN_ADDR(4, 5) /*!< Specify P45 Pin Data Input/Output */
N#define P46             GPIO_PIN_ADDR(4, 6) /*!< Specify P46 Pin Data Input/Output */
N#define P47             GPIO_PIN_ADDR(4, 7) /*!< Specify P47 Pin Data Input/Output */
N/*@}*/ /* end of group GPIO_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT7.
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(port, u32PinMask)         ((port)->ISRC = (u32PinMask))
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT7.
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(port, u32PinMask)     ((port)->DBEN &= ~(u32PinMask))
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT7.
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(port, u32PinMask)      ((port)->DBEN |= (u32PinMask))
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT7.
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(port, u32PinMask) ((port)->OFFD |= ((u32PinMask)<<16))
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT7.
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(port, u32PinMask)  ((port)->OFFD &= ~((u32PinMask)<<16))
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT7.
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(port, u32PinMask)    ((port)->DMASK &= ~(u32PinMask))    
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT7.
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(port, u32PinMask) ((port)->DMASK |= (u32PinMask))
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT7.
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(port, u32PinMask)     ((port)->ISRC & (u32PinMask))
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   u32ClkSrc   The de-bounce counter clock source. It could be GPIO_DBCLKSRC_HCLK or GPIO_DBCLKSRC_LIRC.
N * @param[in]   u32ClkSel   The de-bounce sampling cycle selection. It could be 
N *                            - \ref GPIO_DBCLKSEL_1
N *                            - \ref GPIO_DBCLKSEL_2
N *                            - \ref GPIO_DBCLKSEL_4
N *                            - \ref GPIO_DBCLKSEL_8
N *                            - \ref GPIO_DBCLKSEL_16 
N *                            - \ref GPIO_DBCLKSEL_32 
N *                            - \ref GPIO_DBCLKSEL_64 
N *                            - \ref GPIO_DBCLKSEL_128 
N *                            - \ref GPIO_DBCLKSEL_256 
N *                            - \ref GPIO_DBCLKSEL_512 
N *                            - \ref GPIO_DBCLKSEL_1024 
N *                            - \ref GPIO_DBCLKSEL_2048 
N *                            - \ref GPIO_DBCLKSEL_4096 
N *                            - \ref GPIO_DBCLKSEL_8192 
N *                            - \ref GPIO_DBCLKSEL_16384 
N *                            - \ref GPIO_DBCLKSEL_32768
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: _GPIO_SET_DEBOUNCE_TIME(GPIO_DBCLKSRC_LIRC, GPIO_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (4)*(1/(10*1000)) s = 4*0.0001 s = 400 us,
N *              and system will sampling interrupt input once per 400 us.
N */
N#define GPIO_SET_DEBOUNCE_TIME(u32ClkSrc, u32ClkSel)    (GPIO->DBNCECON = (GPIO_DBNCECON_ICLK_ON_Msk | (u32ClkSrc) | (u32ClkSel)))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N *
N * @return      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(port)  ((port)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32Data     GPIO port data.
N *
N * @return      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(port, u32Data)    ((port)->DOUT = (u32Data))
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   u32Pin      Pxy
N *
N * @return      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(u32Pin) ((u32Pin) ^= 1)
N
N/**
N * @brief       Enable External GPIO Interrupt 0
N *
N * @param[in]   port            GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32Pin          The pin of specified GPIO port. It could be 0 ~ 7.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT0    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO Interrupt 0
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT0   GPIO_DisableInt
N
N
N/**
N * @brief       Enable External GPIO Interrupt 1
N *
N * @param[in]   port            GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32Pin          The pin of specified GPIO port. It could be 0 ~ 7.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT1    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO Interrupt 1
N *
N * @param[in]   port        GPIO port. It could be P0, P1, P2, P3 or P4.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT1   GPIO_DisableInt
N
N
Nvoid GPIO_SetMode(GPIO_T *port, uint32_t u32PinMask, uint32_t u32Mode);
Nvoid GPIO_EnableInt(GPIO_T *port, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *port, uint32_t u32Pin);
N
N
N/*@}*/ /* end of group GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group GPIO_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5970 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "i2c.h"
L 1 "..\..\..\..\Library\StdDriver\inc\i2c.h" 1
N/**************************************************************************//**
N * @file     I2C.h
N * @version  V3.0
N * $Revision: 18 $
N * $Date: 15/08/03 2:52p $
N * @brief    M051 Series I2C Driver Header File
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#include "M051Series.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup I2C_Driver I2C Driver
N  @{
N*/
N
N/** @addtogroup I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2CON constant definitions.                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_I2CON_STA_SI            0x28UL /*!< I2CON setting for I2C control bits. It would set STA and SI bits          */
N#define I2C_I2CON_STA_SI_AA         0x2CUL /*!< I2CON setting for I2C control bits. It would set STA, SI and AA bits      */
N#define I2C_I2CON_STO_SI            0x18UL /*!< I2CON setting for I2C control bits. It would set STO and SI bits          */
N#define I2C_I2CON_STO_SI_AA         0x1CUL /*!< I2CON setting for I2C control bits. It would set STO, SI and AA bits      */
N#define I2C_I2CON_SI                0x08UL /*!< I2CON setting for I2C control bits. It would set SI bit                   */
N#define I2C_I2CON_SI_AA             0x0CUL /*!< I2CON setting for I2C control bits. It would set SI and AA bits           */
N#define I2C_I2CON_STA               0x20UL /*!< I2CON setting for I2C control bits. It would set STA bit                  */
N#define I2C_I2CON_STO               0x10UL /*!< I2CON setting for I2C control bits. It would set STO bit                  */
N#define I2C_I2CON_AA                0x04UL /*!< I2CON setting for I2C control bits. It would set AA bit                   */
N
N#define I2C_GCMODE_ENABLE           1      /*!< Enable  I2C GC Mode                                                       */
N#define I2C_GCMODE_DISABLE          0      /*!< Disable I2C GC Mode                                                       */
N
N/*@}*/ /* end of group I2C_EXPORTED_CONSTANTS */
N
N/** @addtogroup I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N/**
N *    @brief        The macro is used to set I2C bus condition at One Time
N *
N *    @param[in]    i2c        Specify I2C port
N *    @param[in]    u8Ctrl     A byte writes to I2C control register
N *
N *    @return       None
N *
N *    @details      Set I2CON register to control I2C bus conditions of START, STOP, SI, ACK.
N */
N#define I2C_SET_CONTROL_REG(i2c, u8Ctrl) ((i2c)->I2CON = ((i2c)->I2CON & ~0x3c) | (u8Ctrl))
N
N/**
N *    @brief        The macro is used to set START condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus START condition in I2CON register.
N */
N#define I2C_START(i2c)  ((i2c)->I2CON = ((i2c)->I2CON & ~I2C_I2CON_SI_Msk) | I2C_I2CON_STA_Msk)
N
N/**
N *    @brief        The macro is used to wait I2C bus status get ready
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      When a new status is presented of I2C bus, the SI flag will be set in I2CON register.
N */
N#define I2C_WAIT_READY(i2c)     while(!((i2c)->I2CON & I2C_I2CON_SI_Msk))
N
N/**
N *    @brief        The macro is used to Read I2C Bus Data Register
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       A byte of I2C data register
N *
N *    @details      I2C controller read data from bus and save it in I2CDAT register.
N */
N#define I2C_GET_DATA(i2c)   ((i2c)->I2CDAT)
N
N/**
N *    @brief        Write a Data to I2C Data Register
N *
N *    @param[in]    i2c         Specify I2C port
N *    @param[in]    u8Data      A byte that writes to data register
N *
N *    @return       None
N *
N *    @details      When write a data to I2CDAT register, the I2C controller will shift it to I2C bus.
N */
N#define I2C_SET_DATA(i2c, u8Data) ((i2c)->I2CDAT = (u8Data))
N
N/**
N *    @brief        Get I2C Bus status code
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       I2C status code
N *
N *    @details      To get this status code to monitor I2C bus event.
N */
N#define I2C_GET_STATUS(i2c) ((i2c)->I2CSTATUS)
N
N/**
N *    @brief        Get Time-out flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       I2C Bus time-out is not happened
N *    @retval       1       I2C Bus time-out is happened
N *
N *    @details      When I2C bus occurs time-out event, the time-out flag will be set.
N */
N#define I2C_GET_TIMEOUT_FLAG(i2c)   ( ((i2c)->I2CTOC & I2C_I2CTOC_TIF_Msk) == I2C_I2CTOC_TIF_Msk ? 1:0 )
N
N/**
N *    @brief        To get wake-up flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       Chip is not woken-up from power-down mode
N *    @retval       1       Chip is woken-up from power-down mode
N *
N *    @details      I2C bus occurs wake-up event, wake-up flag will be set.
N */
N#define I2C_GET_WAKEUP_FLAG(i2c) ( ((i2c)->I2CWKUPSTS & I2C_I2CWKUPSTS_WKUPIF_Msk) == I2C_I2CWKUPSTS_WKUPIF_Msk ? 1:0  )
N
N/**
N *    @brief        To clear wake-up flag
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @return       None
N *
N *    @details      If wake-up flag is set, use this macro to clear it.
N */
N#define I2C_CLEAR_WAKEUP_FLAG(i2c)  ((i2c)->I2CWKUPSTS |= I2C_I2CWKUPSTS_WKUPIF_Msk)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N *    @brief        The macro is used to set STOP condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus STOP condition in I2CON register and wait STOP condition finish.
N */
Nstatic __INLINE void I2C_STOP(I2C_T *i2c)
Xstatic __inline void I2C_STOP(I2C_T *i2c)
N{
N    (i2c)->I2CON |= (I2C_I2CON_SI_Msk | I2C_I2CON_STO_Msk);
X    (i2c)->I2CON |= ((1ul << 3) | (1ul << 4));
N    while((i2c)->I2CON & I2C_I2CON_STO_Msk);
X    while((i2c)->I2CON & (1ul << 4));
N}
N
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetBusClockFreq(I2C_T *i2c);
Nuint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nuint8_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
Nvoid I2C_EnableWakeup(I2C_T *i2c);
Nvoid I2C_DisableWakeup(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
N
N/*@}*/ /* end of group I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group I2C_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N#endif //__I2C_H__
L 5971 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "pwm.h"
L 1 "..\..\..\..\Library\StdDriver\inc\pwm.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V1.00
N * $Revision: 11 $
N * $Date: 15/05/20 2:07p $
N * @brief    M051 series PWM driver header file
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N#define PWM_CHANNEL_NUM                     (4)   /*!< PWM channel number */
N#define PWM_CLK_DIV_1                       (4UL) /*!< PWM clock divide by 1 */
N#define PWM_CLK_DIV_2                       (0UL) /*!< PWM clock divide by 2 */
N#define PWM_CLK_DIV_4                       (1UL) /*!< PWM clock divide by 4 */
N#define PWM_CLK_DIV_8                       (2UL) /*!< PWM clock divide by 8 */
N#define PWM_CLK_DIV_16                      (3UL) /*!< PWM clock divide by 16 */
N#define PWM_EDGE_ALIGNED                    (0UL) /*!< PWM working in edge aligned type */
N#define PWM_CENTER_ALIGNED                  (1UL) /*!< PWM working in center aligned type */
N#define PWM_DUTY_TRIGGER_ADC                (PWM_TCON_PWM0DTEN_Msk)     /*!< PWM trigger ADC while counter matches CMR in edge-aligned or center-aligned mode */
N#define PWM_PERIOD_TRIGGER_ADC              (PWM_TCON_PWM0TEN_Msk)      /*!< PWM trigger ADC while counter matches 0 in edge-aligned mode or matches (CNR+1) or zero in center-aligned mode */
N#define PWM_DUTY_INT_DOWN_COUNT_MATCH_CMR   (0)                         /*!< PWM duty interrupt triggered if down count match CMR */
N#define PWM_DUTY_INT_UP_COUNT_MATCH_CMR     (PWM_PIER_INT01DTYPE_Msk)   /*!< PWM duty interrupt triggered if up down match CMR */
N#define PWM_PERIOD_INT_UNDERFLOW            (0)                         /*!< PWM period interrupt triggered if counter underflow */
N#define PWM_PERIOD_INT_MATCH_CNR            (PWM_PIER_INT01TYPE_Msk)    /*!< PWM period interrupt triggered if counter match CNR */
N#define PWM_CAPTURE_INT_RISING_LATCH        (PWM_CCR0_CRL_IE0_Msk)      /*!< PWM capture interrupt if channel has rising transition */
N#define PWM_CAPTURE_INT_FALLING_LATCH       (PWM_CCR0_CFL_IE0_Msk)      /*!< PWM capture interrupt if channel has falling transition */
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWM Group channel number constants definitions                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CH0                             0x0                         /*!< PWM Group A/B channel 0 */
N#define PWM_CH1                             0x1                         /*!< PWM Group A/B channel 1 */
N#define PWM_CH2                             0x2                         /*!< PWM Group A/B channel 2 */
N#define PWM_CH3                             0x3                         /*!< PWM Group A/B channel 3 */
N#define PWM_CCR_MASK                        0x000F000F                  /*!< PWM CCR0/CCR2 bit0~3 and bit16~19 mask */
N
N/*@}*/ /* end of group PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief Enable timer synchronous mode of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to enable timer synchronous mode of specified channel(s)
N */
N#define PWM_ENABLE_TIMER_SYNC(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N        for(i = 0; i < 4; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->PSCR |= (PWM_PSCR_PSSEN0_Msk << (i * 8)); \
N        } \
N    }while(0)
X#define PWM_ENABLE_TIMER_SYNC(pwm, u32ChannelMask)     do{         int i;        for(i = 0; i < 4; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->PSCR |= (PWM_PSCR_PSSEN0_Msk << (i * 8));         }     }while(0)
N
N/**
N * @brief Disable timer synchronous mode of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to disable timer synchronous mode of specified channel(s)
N */
N#define PWM_DISABLE_TIMER_SYNC(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N        for(i = 0; i < 4; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->PSCR &= ~(PWM_PSCR_PSSEN0_Msk << (i * 8)); \
N        } \
N    }while(0)
X#define PWM_DISABLE_TIMER_SYNC(pwm, u32ChannelMask)     do{         int i;        for(i = 0; i < 4; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->PSCR &= ~(PWM_PSCR_PSSEN0_Msk << (i * 8));         }     }while(0)
N
N/**
N * @brief Enable output inverter of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to enable capture input inverter for specified channel(s)
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N                (pwm)->PCR &= ~(PWM_PCR_CH0INV_Msk|PWM_PCR_CH1INV_Msk|PWM_PCR_CH2INV_Msk|PWM_PCR_CH3INV_Msk);\
N        for(i = 0; i < 4; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->PCR |= (PWM_PCR_CH0INV_Msk << (PWM_PCR_CH0INV_Pos * (i * 4))); \
N        } \
N    }while(0)
X#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask)     do{         int i;                (pwm)->PCR &= ~(PWM_PCR_CH0INV_Msk|PWM_PCR_CH1INV_Msk|PWM_PCR_CH2INV_Msk|PWM_PCR_CH3INV_Msk);        for(i = 0; i < 4; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->PCR |= (PWM_PCR_CH0INV_Msk << (PWM_PCR_CH0INV_Pos * (i * 4)));         }     }while(0)
N
N/**
N * @brief Get captured rising data of specified channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @return uint32_t Return the timer counter, 0~0xFFFF
N * @details This macro is used to get captured rising data for specified channel
N */
N#define PWM_GET_CAPTURE_RISING_DATA(pwm, u32ChannelNum) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CRLR0)) + (u32ChannelNum) * 8))))
N
N/**
N * @brief Get captured falling data of specified channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @return uint32_t Return the timer counter, 0~0xFFFF
N * @details This macro is used to get captured falling data for specified channel
N */
N#define PWM_GET_CAPTURE_FALLING_DATA(pwm, u32ChannelNum) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CFLR0)) + (u32ChannelNum) * 8))))
N
N/**
N * @brief Set the prescaler of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFF
N * @return None
N * @details This macro is used to set timer pre-scale for specified channel
N * @note    - If u32Prescaler = 0, corresponding PWM-timer will be stopped
N *          - If u32Prescaler = x (x not equal to 0), it means Clock input is divided by (x + 1) before it is fed to the corresponding PWM counter.
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) \
N    ((pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8)))
X#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler)     ((pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8)))
N
N/**
N * @brief Set the divider of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32Divider Clock divider of specified channel. Valid values are
N *              - \ref PWM_CLK_DIV_1
N *              - \ref PWM_CLK_DIV_2
N *              - \ref PWM_CLK_DIV_4
N *              - \ref PWM_CLK_DIV_8
N *              - \ref PWM_CLK_DIV_16
N * @return None
N * @details    This macro is used to set Timer clock source divider selection for specified channel
N */
N#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider) \
N    ((pwm)->CSR = ((pwm)->CSR & ~(PWM_CSR_CSR0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
X#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider)     ((pwm)->CSR = ((pwm)->CSR & ~(PWM_CSR_CSR0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
N
N/**
N * @brief Set the duty of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32CMR Duty of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details    This macro is used to set PWM Comparator value for specified channel
N * @note This new setting will take effect on next PWM period
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CMR0)) + (u32ChannelNum) * 12))) = (u32CMR))
N
N/**
N * @brief Set the period of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details    This macro is used to set timer loaded value(CNR) for specified channel.\n
N *             Loaded value determines the PWM period.
N * @note This new setting will take effect on next PWM period
N * @note PWM counter will stop if period length set to 0
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR)  (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CNR0)) + (u32ChannelNum) * 12))) = (u32CNR))
N
N/**
N * @brief Set the PWM aligned type
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32AlignedType PWM aligned type, valid values are:
N *                  - \ref PWM_EDGE_ALIGNED
N *                  - \ref PWM_CENTER_ALIGNED
N * @return None
N * @details This macro is used to set the PWM aligned type
N */
N#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType) \
N    do{ \
N        int i; \
N        for(i = 0; i < 4; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->PCR = ((pwm)->PCR & ~(PWM_PCR_PWM01TYPE_Msk << (i >> 1))) | ((u32AlignedType) << (PWM_PCR_PWM01TYPE_Pos + (i >> 1))); \
N        } \
N    }while(0)
X#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType)     do{         int i;         for(i = 0; i < 4; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->PCR = ((pwm)->PCR & ~(PWM_PCR_PWM01TYPE_Msk << (i >> 1))) | ((u32AlignedType) << (PWM_PCR_PWM01TYPE_Pos + (i >> 1)));         }     }while(0)
N
N
Nuint32_t PWM_ConfigCaptureChannel(PWM_T *pwm,
N                                  uint32_t u32ChannelNum,
N                                  uint32_t u32UnitTimeNsec,
N                                  uint32_t u32CaptureEdge);
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
N                                 uint32_t u32ChannelNum,
N                                 uint32_t u32Frequncy,
N                                 uint32_t u32DutyCycle);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nuint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
Nvoid PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
Nvoid PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
N
N
N/*@}*/ /* end of group PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group PWM_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5972 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "spi.h"
L 1 "..\..\..\..\Library\StdDriver\inc\spi.h" 1
N/**************************************************************************//**
N * @file     spi.h
N * @version  V3.00
N * $Revision: 11 $
N * $Date: 15/05/22 3:34p $
N * @brief    M051 series SPI driver header file
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __SPI_H__
N#define __SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0        (SPI_CNTRL_TX_NEG_Msk)                          /*!< CLKP=0; RX_NEG=0; TX_NEG=1 */
N#define SPI_MODE_1        (SPI_CNTRL_RX_NEG_Msk)                          /*!< CLKP=0; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_2        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_RX_NEG_Msk)     /*!< CLKP=1; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_3        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_TX_NEG_Msk)     /*!< CLKP=1; RX_NEG=0; TX_NEG=1 */
N
N#define SPI_SLAVE         (SPI_CNTRL_SLAVE_Msk)                           /*!< Set as slave */
N#define SPI_MASTER        (0x0)                                           /*!< Set as master */
N
N#define SPI_SS                (SPI_SSR_SSR_Msk)                           /*!< Set SS */
N#define SPI_SS_ACTIVE_HIGH    (SPI_SSR_SS_LVL_Msk)                        /*!< SS active high */
N#define SPI_SS_ACTIVE_LOW     (0x0)                                       /*!< SS active low */
N
N#define SPI_UNIT_INT_MASK                (0x01)                           /*!< Unit transfer interrupt mask */
N#define SPI_SSTA_INT_MASK                (0x02)                           /*!< Slave 3-Wire mode start interrupt mask */
N#define SPI_FIFO_TX_INT_MASK             (0x04)                           /*!< FIFO TX interrupt mask */
N#define SPI_FIFO_RX_INT_MASK             (0x08)                           /*!< FIFO RX interrupt mask */
N#define SPI_FIFO_RXOV_INT_MASK           (0x10)                           /*!< FIFO RX overrun interrupt mask */
N#define SPI_FIFO_TIMEOUT_INT_MASK        (0x20)                           /*!< FIFO RX timeout interrupt mask */
N
N#define SPI_BUSY_MASK                    (0x01)                           /*!< Busy status mask */
N#define SPI_RX_EMPTY_MASK                (0x02)                           /*!< RX empty status mask */
N#define SPI_RX_FULL_MASK                 (0x04)                           /*!< RX full status mask */
N#define SPI_TX_EMPTY_MASK                (0x08)                           /*!< TX empty status mask */
N#define SPI_TX_FULL_MASK                 (0x10)                           /*!< TX full status mask */
N
N#define SPI_FIFO_SIZE                    (4)                              /*!< M051 Series provides separate 4-layer transmit and receive FIFO buffers */
N
N/*@}*/ /* end of group SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N
N
N
N
N/**
N  * @brief      Abort the current transfer in slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Set the SLV_ABORT bit of SPI_CNTRL2 register to abort the current transfer in Slave 3-wire mode.
N  */
N#define SPI_ABORT_3WIRE_TRANSFER(spi)   ((spi)->CNTRL2 |= SPI_CNTRL2_SLV_ABORT_Msk)
N
N/**
N  * @brief      Clear the slave 3-wire mode start interrupt flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Write 1 to SLV_START_INTSTS bit of SPI_CNTRL2 register to clear the Slave 3-wire mode start interrupt flag.
N  */
N#define SPI_CLR_3WIRE_START_INT_FLAG(spi)   ((spi)->CNTRL2 |= SPI_CNTRL2_SLV_START_INTSTS_Msk)
N
N/**
N  * @brief      Clear the unit transfer interrupt flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Write 1 to IF bit of SPI_CNTRL register to clear the unit transfer interrupt flag.
N  */
N#define SPI_CLR_UNIT_TRANS_INT_FLAG(spi)   ((spi)->CNTRL |= SPI_CNTRL_IF_Msk)
N
N/**
N  * @brief      Disable slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Clear NOSLVSEL bit of SPI_CNTRL2 register to disable Slave 3-wire mode.
N  */
N#define SPI_DISABLE_3WIRE_MODE(spi)   ((spi)->CNTRL2 &= ~SPI_CNTRL2_NOSLVSEL_Msk)
N
N/**
N  * @brief      Enable slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Set NOSLVSEL bit of SPI_CNTRL2 register to enable Slave 3-wire mode.
N  */
N#define SPI_ENABLE_3WIRE_MODE(spi)   ((spi)->CNTRL2 |= SPI_CNTRL2_NOSLVSEL_Msk)
N
N/**
N  * @brief      Get the count of available data in RX FIFO.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     The count of available data in RX FIFO.
N  * @details    Read RX_FIFO_COUNT (SPI_STATUS[15:12]) to get the count of available data in RX FIFO.
N  */
N#define SPI_GET_RX_FIFO_COUNT(spi)   (((spi)->STATUS & SPI_STATUS_RX_FIFO_COUNT_Msk) >> SPI_STATUS_RX_FIFO_COUNT_Pos)
N
N/**
N  * @brief      Get the RX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 RX FIFO is not empty
N  * @retval     1 RX FIFO is empty
N  * @details    Read RX_EMPTY bit of SPI_STATUS register to get the RX FIFO empty flag.
N  */
N#define SPI_GET_RX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_RX_EMPTY_Msk)>>SPI_STATUS_RX_EMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not empty
N  * @retval     1 TX FIFO is empty
N  * @details    Read TX_EMPTY bit of SPI_STATUS register to get the TX FIFO empty flag.
N  */
N#define SPI_GET_TX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TX_EMPTY_Msk)>>SPI_STATUS_TX_EMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO full flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not full
N  * @retval     1 TX FIFO is full
N  * @details    Read TX_FULL bit of SPI_STATUS register to get the TX FIFO full flag.
N  */
N#define SPI_GET_TX_FIFO_FULL_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TX_FULL_Msk)>>SPI_STATUS_TX_FULL_Pos)
N
N/**
N  * @brief      Get the datum read from RX0 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     Data in RX0 register
N  * @details    Read SPI_RX0 register to get the received datum.
N  */
N#define SPI_READ_RX0(spi)   ((spi)->RX0)
N
N/**
N  * @brief      Get the datum read from RX1 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     Data in RX1 register.
N  * @details    Read SPI_RX1 register to get the received datum.
N  */
N#define SPI_READ_RX1(spi)   ((spi)->RX1)
N
N/**
N  * @brief      Write datum to TX0 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32TxData The datum which user attempt to transfer through SPI bus.
N  * @return     None
N  * @details    Write u32TxData to TX0 register.
N  */
N#define SPI_WRITE_TX0(spi, u32TxData)   ((spi)->TX0 = (u32TxData))
N
N/**
N  * @brief      Write datum to TX1 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32TxData The datum which user attempt to transfer through SPI bus.
N  * @return     None
N  * @details    Write u32TxData to TX1 register.
N  */
N#define SPI_WRITE_TX1(spi, u32TxData)   ((spi)->TX1 = (u32TxData))
N
N/**
N  * @brief      Set SPIn_SS pin to high state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Disable automatic slave selection function and set SPIn_SS pin to high state.
N  */
N#define SPI_SET_SS_HIGH(spi)   ((spi)->SSR = ((spi)->SSR & (~SPI_SSR_AUTOSS_Msk)) | (SPI_SSR_SS_LVL_Msk | SPI_SSR_SSR_Msk))
N
N/**
N  * @brief      Set SPIn_SS pin to low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Disable automatic slave selection function and set SPIn_SS pin to low state.
N  */
N#define SPI_SET_SS_LOW(spi)   ((spi)->SSR = ((spi)->SSR & (~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk))) | SPI_SSR_SSR_Msk)
N
N/**
N  * @brief      Enable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Set REORDER bit of SPI_CNTRL register to enable Byte Reorder function.
N  */
N#define SPI_ENABLE_BYTE_REORDER(spi)   ((spi)->CNTRL = ((spi)->CNTRL & (~SPI_CNTRL_REORDER_Msk)) | (1<<SPI_CNTRL_REORDER_Pos))
N
N/**
N  * @brief      Disable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Clear REORDER bit of SPI_CNTRL register to disable Byte Reorder function.
N  */
N#define SPI_DISABLE_BYTE_REORDER(spi)   ((spi)->CNTRL &= ~SPI_CNTRL_REORDER_Msk)
N
N/**
N  * @brief      Set the length of suspend interval.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32SuspCycle Decides the length of suspend interval. It could be 0 ~ 15.
N  * @return     None
N  * @details    Set the length of suspend interval according to u32SuspCycle.
N  *             On M05xxBN, if DIV_ONE feature is disabled, the length of suspend interval is ((u32SuspCycle + 2) * the length of SPI bus clock cycle + 1 system clock cycle).
N  *             On M05xxBN, if DIV_ONE feature is enabled, the length of suspend interval is ((u32SuspCycle * 2 + 3.5) * the length of system clock cycle).
N  *             On M05xxDN/DE, the length of suspend interval is ((u32SuspCycle + 0.5) * the length of SPI bus clock cycle).
N  */
N#define SPI_SET_SUSPEND_CYCLE(spi, u32SuspCycle)   ((spi)->CNTRL = ((spi)->CNTRL & ~SPI_CNTRL_SP_CYCLE_Msk) | ((u32SuspCycle) << SPI_CNTRL_SP_CYCLE_Pos))
N
N/**
N  * @brief      Set the SPI transfer sequence with LSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Set LSB bit of SPI_CNTRL register to set the SPI transfer sequence with LSB first.
N  */
N#define SPI_SET_LSB_FIRST(spi)   ((spi)->CNTRL |= SPI_CNTRL_LSB_Msk)
N
N/**
N  * @brief      Set the SPI transfer sequence with MSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    Clear LSB bit of SPI_CNTRL register to set the SPI transfer sequence with MSB first.
N  */
N#define SPI_SET_MSB_FIRST(spi)   ((spi)->CNTRL &= ~SPI_CNTRL_LSB_Msk)
N
N/**
N  * @brief      Set the data width of a SPI transaction.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32Width The bit width of transfer data.
N  * @return     None
N  * @details    The data width can be 8 ~ 32 bits.
N  */
N#define SPI_SET_DATA_WIDTH(spi, u32Width)   ((spi)->CNTRL = ((spi)->CNTRL & ~SPI_CNTRL_TX_BIT_LEN_Msk) | (((u32Width)&0x1F) << SPI_CNTRL_TX_BIT_LEN_Pos))
N
N/**
N  * @brief      Get the SPI busy state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 SPI module is not busy
N  * @retval     1 SPI module is busy
N  * @details    This macro will return the busy state of SPI controller.
N  */
N#define SPI_IS_BUSY(spi)   ( ((spi)->CNTRL & SPI_CNTRL_GO_BUSY_Msk)>>SPI_CNTRL_GO_BUSY_Pos )
N
N/**
N  * @brief      Set the GO_BUSY bit to trigger SPI transfer.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None
N  * @details    User can use this macro to trigger the data transfer after all configurations are ready.
N  */
N#define SPI_TRIGGER(spi)   ((spi)->CNTRL |= SPI_CNTRL_GO_BUSY_Msk)
N
N
N/* Function prototype declaration */
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid SPI_Close(SPI_T *spi);
Nvoid SPI_ClearRxFIFO(SPI_T *spi);
Nvoid SPI_ClearTxFIFO(SPI_T *spi);
Nvoid SPI_DisableAutoSS(SPI_T *spi);
Nvoid SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
Nvoid SPI_DisableFIFO(SPI_T *spi);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nvoid SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask);
N
N/*@}*/ /* end of group SPI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SPI_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SPI_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 5973 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "timer.h"
L 1 "..\..\..\..\Library\StdDriver\inc\timer.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V3.00
N * $Revision: 10 $
N * $Date: 15/05/20 2:07p $
N * @brief    M051 series Timer driver header file
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N
N#define TIMER_ONESHOT_MODE                  (0UL << TIMER_TCSR_MODE_Pos) /*!< Timer working in one-shot mode */
N#define TIMER_PERIODIC_MODE                 (1UL << TIMER_TCSR_MODE_Pos) /*!< Timer working in periodic mode */
N#define TIMER_TOGGLE_MODE                   (2UL << TIMER_TCSR_MODE_Pos) /*!< Timer working in toggle-output mode */
N#define TIMER_CONTINUOUS_MODE               (3UL << TIMER_TCSR_MODE_Pos) /*!< Timer working in continuous counting mode */
N#define TIMER_CONTINUOUS_MODE               (3UL << TIMER_TCSR_MODE_Pos) /*!< Timer working in continuous counting mode */
N#define TIMER_CAPTURE_FROM_TXEX_PIN         (0UL << TIMER_TCSR_CAP_SRC_Pos) /*!< Timer capture source is from TxEX pin */
N#define TIMER_CAPTURE_FROM_INTERNAL_ACMP    (1UL << TIMER_TCSR_CAP_SRC_Pos) /*!< Timer capture source is from internal ACMP output signal */
N#define TIMER_TOUT_PIN_FROM_TX_PIN          (0UL << TIMER_TCSR_TOUT_SEL_Pos) /*!< Timer toggle-output pin is from Tx pin */
N#define TIMER_TOUT_PIN_FROM_TXEX_PIN        (1UL << TIMER_TCSR_TOUT_SEL_Pos) /*!< Timer toggle-output pin is from TxEX pin */
N#define TIMER_CAPTURE_FREE_COUNTING_MODE    (0UL << TIMER_TEXCON_RSTCAPSEL_Pos) /*!< Timer capture event to get timer counter value */
N#define TIMER_CAPTURE_COUNTER_RESET_MODE    (1UL << TIMER_TEXCON_RSTCAPSEL_Pos) /*!< Timer capture event to reset timer counter */
N#define TIMER_CAPTURE_FALLING_EDGE              (0UL << TIMER_TEXCON_TEX_EDGE_Pos) /*!< Falling edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_EDGE               (1UL << TIMER_TEXCON_TEX_EDGE_Pos) /*!< Rising edge trigger timer capture */
N#define TIMER_CAPTURE_FALLING_AND_RISING_EDGE   (2UL << TIMER_TEXCON_TEX_EDGE_Pos) /*!< Both falling and rising edge trigger timer capture */
N#define TIMER_COUNTER_FALLING_EDGE          (0UL << TIMER_TEXCON_TX_PHASE_Pos) /*!< Counter increase on falling edge */
N#define TIMER_COUNTER_RISING_EDGE           (1UL << TIMER_TEXCON_TX_PHASE_Pos) /*!< Counter increase on rising edge */
N
N/*@}*/ /* end of group TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Set Timer Compared Value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer compare value. Valid values are between 2 to 0xFFFFFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set timer compared value to adjust timer time-out interval.
N  * @note       1. Never write 0x0 or 0x1 in this field, or the core will run into unknown state. \n
N  *             2. If update timer compared value in continuous counting mode, timer counter value will keep counting continuously. \n
N  *                But if timer is operating at other modes, the timer up counter will restart counting and start from 0.
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value)        ((timer)->TCMPR = (u32Value))
N
N/**
N  * @brief      Set Timer Prescale Value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer prescale value. Valid values are between 0 to 0xFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set timer prescale value and timer source clock will be divided by (prescale + 1) \n
N  *             before it is fed into timer.
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value)   ((timer)->TCSR = ((timer)->TCSR & ~TIMER_TCSR_PRESCALE_Msk) | (u32Value))
N
N/**
N  * @brief      Check specify Timer Status
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer 24-bit up counter is inactive
N  * @retval     1   Timer 24-bit up counter is active
N  *
N  * @details    This macro is used to check if specify Timer counter is inactive or active.
N  */
N#define TIMER_IS_ACTIVE(timer)                      ((timer)->TCSR & TIMER_TCSR_CACT_Msk ? 1 : 0)
N
N/**
N  * @brief      Select Toggle-output Pin
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32ToutSel  Toggle-output pin selection, valid values are:
N  *                         - \ref TIMER_TOUT_PIN_FROM_TX_PIN
N  *                         - \ref TIMER_TOUT_PIN_FROM_TXEX_PIN
N  *
N  * @return     None
N  *
N  * @details    This macro is used to select timer toggle-output pin is output on Tx or TxEX pin.
N  */
N#define TIMER_SELECT_TOUT_PIN(timer, u32ToutSel)    ((timer)->TCSR = ((timer)->TCSR & ~TIMER_TCSR_TOUT_SEL_Msk) | (u32ToutSel))
N
N/**
N  * @brief      Start Timer Counting
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to start Timer counting.
N  */
Nstatic __INLINE void TIMER_Start(TIMER_T *timer)
Xstatic __inline void TIMER_Start(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_CEN_Msk;
X    timer->TCSR |= (1ul << 30);
N}
N
N/**
N  * @brief      Stop Timer Counting
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to stop/suspend Timer counting.
N  */
Nstatic __INLINE void TIMER_Stop(TIMER_T *timer)
Xstatic __inline void TIMER_Stop(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_CEN_Msk;
X    timer->TCSR &= ~(1ul << 30);
N}
N
N/**
N  * @brief      Enable Timer Interrupt Wake-up Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer interrupt wake-up function and interrupt source could be time-out interrupt, \n
N  *             counter event interrupt or capture trigger interrupt.
N  * @note       To wake the system from Power-down mode, timer clock source must be selected LIRC.
N  */
Nstatic __INLINE void TIMER_EnableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_EnableWakeup(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR |= (1ul << 23);
N}
N
N/**
N  * @brief      Disable Timer Wake-up Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer interrupt wake-up function.
N  */
Nstatic __INLINE void TIMER_DisableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_DisableWakeup(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR &= ~(1ul << 23);
N}
N
N/**
N  * @brief      Enable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the detect de-bounce function of capture pin.
N  */
Nstatic __INLINE void TIMER_EnableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON |= (1ul << 6);
N}
N
N/**
N  * @brief      Disable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the detect de-bounce function of capture pin.
N  */
Nstatic __INLINE void TIMER_DisableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON &= ~(1ul << 6);
N}
N
N/**
N  * @brief      Enable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the detect de-bounce function of counter pin.
N  */
Nstatic __INLINE void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON |= (1ul << 7);
N}
N
N/**
N  * @brief      Disable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the detect de-bounce function of counter pin.
N  */
Nstatic __INLINE void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON &= ~(1ul << 7);
N}
N
N/**
N  * @brief      Enable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableInt(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_IE_Msk;
X    timer->TCSR |= (1ul << 29);
N}
N
N/**
N  * @brief      Disable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableInt(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_IE_Msk;
X    timer->TCSR &= ~(1ul << 29);
N}
N
N/**
N  * @brief      Enable Capture Trigger Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON |= (1ul << 5);
N}
N
N/**
N  * @brief      Disable Capture Trigger Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON &= ~(1ul << 5);
N}
N
N/**
N  * @brief      Get Timer Time-out Interrupt Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer time-out interrupt did not occur
N  * @retval     1   Timer time-out interrupt occurred
N  *
N  * @details    This function indicates timer time-out interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
N{
N    return (timer->TISR & TIMER_TISR_TIF_Msk ? 1 : 0);
X    return (timer->TISR & (1ul << 0) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer Time-out Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears timer time-out interrupt flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TIF_Msk;
X    timer->TISR = (1ul << 0);
N}
N
N/**
N  * @brief      Get Timer Capture Interrupt Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer capture interrupt did not occur
N  * @retval     1   Timer capture interrupt occurred
N  *
N  * @details    This function indicates timer capture trigger interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
N{
N    return timer->TEXISR;
N}
N
N/**
N  * @brief      Clear Timer Capture Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears timer capture trigger interrupt flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
N{
N    timer->TEXISR = TIMER_TEXISR_TEXIF_Msk;
X    timer->TEXISR = (1ul << 0);
N}
N
N/**
N  * @brief      Get Timer Wake-up Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer does not cause CPU wake-up
N  * @retval     1   Timer interrupt event cause CPU wake-up
N  *
N  * @details    This function indicates timer interrupt event has waked up system or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
N{
N    return (timer->TISR & TIMER_TISR_TWF_Msk ? 1 : 0);
X    return (timer->TISR & (1ul << 1) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer Wake-up Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears the timer wake-up system flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearWakeupFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TWF_Msk;
X    timer->TISR = (1ul << 1);
N}
N
N/**
N  * @brief      Get Capture value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     24-bit Capture Value
N  *
N  * @details    This function reports the current 24-bit timer capture value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureData(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
N{
N    return timer->TCAP;
N}
N
N/**
N  * @brief      Get Counter value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     24-bit Counter Value
N  *
N  * @details    This function reports the current 24-bit timer counter value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCounter(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
N{
N    return timer->TDR;
N}
N
Nuint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid TIMER_Close(TIMER_T *timer);
Nvoid TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
Nvoid TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
Nvoid TIMER_DisableCapture(TIMER_T *timer);
Nvoid TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
Nvoid TIMER_DisableEventCounter(TIMER_T *timer);
Nuint32_t TIMER_GetModuleClock(TIMER_T *timer);
N
N/*@}*/ /* end of group TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group TIMER_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5974 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "wdt.h"
L 1 "..\..\..\..\Library\StdDriver\inc\wdt.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V3.00
N * $Revision: 5 $
N * $Date: 15/05/20 2:07p $
N * @brief    M051 series WDT driver header file
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup WDT_Driver WDT Driver
N  @{
N*/
N
N/** @addtogroup WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* WTCR Constants Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_TIMEOUT_2POW4           (0UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^4 * WDT clocks */
N#define WDT_TIMEOUT_2POW6           (1UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^6 * WDT clocks */
N#define WDT_TIMEOUT_2POW8           (2UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^8 * WDT clocks */
N#define WDT_TIMEOUT_2POW10          (3UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^10 * WDT clocks */
N#define WDT_TIMEOUT_2POW12          (4UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^12 * WDT clocks */
N#define WDT_TIMEOUT_2POW14          (5UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^14 * WDT clocks */
N#define WDT_TIMEOUT_2POW16          (6UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^16 * WDT clocks */
N#define WDT_TIMEOUT_2POW18          (7UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^18 * WDT clocks */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* WTCRALT Constants Definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_RESET_DELAY_1026CLK     (0UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 1026 * WDT clocks */
N#define WDT_RESET_DELAY_130CLK      (1UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 130 * WDT clocks */
N#define WDT_RESET_DELAY_18CLK       (2UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 18 * WDT clocks */
N#define WDT_RESET_DELAY_3CLK        (3UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 3 * WDT clocks */
N
N/*@}*/ /* end of group WDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out reset system flag.
N  */
N#define WDT_CLEAR_RESET_FLAG()          (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTRF_Msk)
N
N/**
N  * @brief      Clear WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out interrupt flag.
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG()    (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTIF_Msk)
N
N/**
N  * @brief      Clear WDT Wake-up Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out wake-up system flag.
N  */
N#define WDT_CLEAR_TIMEOUT_WAKEUP_FLAG() (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTIF_Msk)) | WDT_WTCR_WTWKF_Msk)
N
N/**
N  * @brief      Get WDT Time-out Reset Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out reset system did not occur
N  * @retval     1   WDT time-out reset system occurred
N  *
N  * @details    This macro indicates system has been reset by WDT time-out reset or not.
N  */
N#define WDT_GET_RESET_FLAG()            (WDT->WTCR & WDT_WTCR_WTRF_Msk ? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out interrupt did not occur
N  * @retval     1   WDT time-out interrupt occurred
N  *
N  * @details    This macro indicates WDT time-out interrupt occurred or not.
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG()      (WDT->WTCR & WDT_WTCR_WTIF_Msk ? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Wake-up Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out interrupt does not cause CPU wake-up
N  * @retval     1   WDT time-out interrupt event cause CPU wake-up
N  *
N  * @details    This macro indicates WDT time-out interrupt event has waked up system or not.
N  */
N#define WDT_GET_TIMEOUT_WAKEUP_FLAG()   (WDT->WTCR & WDT_WTCR_WTWKF_Msk ? 1 : 0)
N
N/**
N  * @brief      Reset WDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reset the internal 18-bit WDT up counter value.
N  * @note       If WDT is activated and time-out reset system function is enabled also, user should \n
N  *             reset the 18-bit WDT up counter value to avoid generate WDT time-out reset signal to \n
N  *             reset system before the WDT time-out reset delay period expires.
N  */
N#define WDT_RESET_COUNTER()             (WDT->WTCR  = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk | WDT_WTCR_WTRF_Msk)) | WDT_WTCR_WTR_Msk)
N
N/**
N  * @brief      Stop WDT Counting
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will stop WDT counting and disable WDT module.
N  */
Nstatic __INLINE void WDT_Close(void)
Xstatic __inline void WDT_Close(void)
N{
N    WDT->WTCR = 0;
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR = 0;
N    return;
N}
N
N/**
N  * @brief      Enable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will enable the WDT time-out interrupt function.
N  */
Nstatic __INLINE void WDT_EnableInt(void)
Xstatic __inline void WDT_EnableInt(void)
N{
N    WDT->WTCR |= WDT_WTCR_WTIE_Msk;
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR |= (1ul << 6);
N    return;
N}
N
N/**
N  * @brief      Disable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will disable the WDT time-out interrupt function.
N  */
Nstatic __INLINE void WDT_DisableInt(void)
Xstatic __inline void WDT_DisableInt(void)
N{
N    // Do not touch write 1 clear bits
N    WDT->WTCR &= ~(WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRF_Msk | WDT_WTCR_WTIF_Msk);
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR &= ~((1ul << 6) | (1ul << 2) | (1ul << 3));
N    return;
N}
N
Nvoid WDT_Open(uint32_t u32TimeoutInterval, uint32_t u32ResetDelay, uint32_t u32EnableReset, uint32_t u32EnableWakeup);
N
N/*@}*/ /* end of group WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group WDT_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5975 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "wwdt.h"
L 1 "..\..\..\..\Library\StdDriver\inc\wwdt.h" 1
N/**************************************************************************//**
N * @file     wwdt.h
N * @version  V3.00
N * $Revision: 9 $
N * $Date: 15/05/20 2:07p $
N * @brief    M051 series WWDT driver header file
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WWDT_H__
N#define __WWDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup WWDT_Driver WWDT Driver
N  @{
N*/
N
N/** @addtogroup WWDT_EXPORTED_CONSTANTS WWDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* WWDTCR Constants Definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WWDT_PRESCALER_1        (0 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 1 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2        (1 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 2 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_4        (2 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 4 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_8        (3 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 8 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_16       (4 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 16 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_32       (5 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 32 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_64       (6 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 64 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_128      (7 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 128 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_192      (8 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 192 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_256      (9 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 256 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_384      (10 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 384 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_512      (11 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 512 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_768      (12 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 768 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1024     (13 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 1024 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1536     (14 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 1536 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2048     (15 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 2048 * (64*WWDT_CLK) */
N
N#define WWDT_RELOAD_WORD        (0x00005AA5)                      /*!< Fill this value to WWDTRLD register to reload WWDT counter */
N
N/*@}*/ /* end of group WWDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup WWDT_EXPORTED_FUNCTIONS WWDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WWDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT time-out reset system flag.
N  */
N#define WWDT_CLEAR_RESET_FLAG()     (WWDT->WWDTSR = WWDT_WWDTSR_WWDTRF_Msk)
N
N/**
N  * @brief      Clear WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT compared match interrupt flag.
N  */
N#define WWDT_CLEAR_INT_FLAG()       (WWDT->WWDTSR = WWDT_WWDTSR_WWDTIF_Msk)
N
N/**
N  * @brief      Get WWDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT time-out reset system did not occur
N  * @retval     1   WWDT time-out reset system occurred
N  *
N  * @details    This macro is used to indicate system has been reset by WWDT time-out reset or not.
N  */
N#define WWDT_GET_RESET_FLAG()       ((((WWDT->WWDTSR) & WWDT_WWDTSR_WWDTRF_Msk) == WWDT_WWDTSR_WWDTRF_Msk)? 1:0)
N
N/**
N  * @brief      Get WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT compare match interrupt did not occur
N  * @retval     1   WWDT compare match interrupt occurred
N  *
N  * @details    This macro is used to indicate WWDT counter value matches CMPDAT value or not.
N  */
N#define WWDT_GET_INT_FLAG()         ((((WWDT->WWDTSR) & WWDT_WWDTSR_WWDTIF_Msk) == WWDT_WWDTSR_WWDTIF_Msk)? 1:0)
N
N/**
N  * @brief      Get WWDT Counter
N  *
N  * @param      None
N  *
N  * @return     WWDT Counter Value
N  *
N  * @details    This macro reflects the current WWDT counter value.
N  */
N#define WWDT_GET_COUNTER()          (WWDT->WWDTCVR)
N
N/**
N  * @brief      Reload WWDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reload the WWDT counter value to 0x3F.
N  * @note       User can only write WWDTRLD register to reload WWDT counter value when current WWDT counter value \n
N  *             between 0 and CMPDAT value. If user writes WWDTRLD when current WWDT counter value is larger than CMPDAT, \n
N  *             WWDT reset signal will generate immediately to reset system.
N  */
N#define WWDT_RELOAD_COUNTER()       (WWDT->WWDTRLD = WWDT_RELOAD_WORD)
N
Nvoid WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);
N
N/*@}*/ /* end of group WWDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group WWDT_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WWDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5976 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "uart.h"
L 1 "..\..\..\..\Library\StdDriver\inc\uart.h" 1
N/**************************************************************************//**
N * @file     UART.h
N * @version  V3.00
N * $Revision: 23 $
N * $Date: 15/05/29 4:19p $
N * @brief    M051 series UART driver header file
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __UART_H__
N#define __UART_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART FIFO size constants definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART0_FIFO_SIZE 16 /*!< UART0 supports separated receive/transmit 16/16 bytes entry FIFO */
N#define UART1_FIFO_SIZE 16 /*!< UART1 supports separated receive/transmit 16/16 bytes entry FIFO */   
N    
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FCR_RFITL_1BYTE        (0x0 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 1 byte */
N#define UART_FCR_RFITL_4BYTES       (0x1 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 4 bytes */
N#define UART_FCR_RFITL_8BYTES       (0x2 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 8 bytes */
N#define UART_FCR_RFITL_14BYTES      (0x3 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 14 bytes */
N
N#define UART_FCR_RTS_TRI_LEV_1BYTE        (0x0 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 1 byte */
N#define UART_FCR_RTS_TRI_LEV_4BYTES       (0x1 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 4 bytes */
N#define UART_FCR_RTS_TRI_LEV_8BYTES       (0x2 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 8 bytes */
N#define UART_FCR_RTS_TRI_LEV_14BYTES      (0x3 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 14 bytes */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5        (0) /*!< UA_LCR setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6        (1) /*!< UA_LCR setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7        (2) /*!< UA_LCR setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8        (3) /*!< UA_LCR setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for two stop bit when 6, 7, 8-bit word length */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_LOW_LEV_ACTIVE    (0x1 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is Low Level Active */
N#define UART_RTS_IS_HIGH_LEV_ACTIVE   (0x0 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is High Level Active */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_IRCR constants definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_IRCR_TX_SELECT         (0x1 << UART_IRCR_TX_SELECT_Pos) /*!< Set IrDA function Tx mode */
N#define UART_IRCR_RX_SELECT         (0x0 << UART_IRCR_TX_SELECT_Pos) /*!< Set IrDA function Rx mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART    (0x0 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_LIN     (0x1 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set LIN Function             */
N#define UART_FUNC_SEL_IrDA    (0x2 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485   (0x3 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set RS485 Function           */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART BAUDRATE MODE constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_BAUD_MODE0     (0) /*!< Set UART Baudrate Mode is Mode0 */
N#define UART_BAUD_MODE2     (UART_BAUD_DIV_X_EN_Msk | UART_BAUD_DIV_X_ONE_Msk) /*!< Set UART Baudrate Mode is Mode2 */
N
N
N
N/*@}*/ /* end of group UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N
N/**
N *    @brief        Calculate UART baudrate mode0 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode0 divider
N *
N *    @details      This macro calculate UART baudrate mode0 divider.
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)*8)) / (u32BaudRate) >> 4)-2)
N
N/**
N *    @brief        Calculate UART baudrate mode2 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode2 divider
N *
N *    @details      This macro calculate UART baudrate mode2 divider.
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)/2)) / (u32BaudRate))-2)
N
N
N/**
N *    @brief        Write data
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *    @param[in]    u8Data  Data byte to transmit
N *
N *    @return       None
N *
N *    @details      This macro write Data to Tx data register.
N */
N#define UART_WRITE(uart, u8Data)    ((uart)->THR = (u8Data))
N
N
N/**
N *    @brief        Read data
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       The oldest data byte in RX FIFO
N *
N *    @details      This macro read Rx data register.
N */
N#define UART_READ(uart)    ((uart)->RBR)
N
N
N/**
N *    @brief        Get Tx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Tx FIFO is not empty
N *    @retval       >=1 Tx FIFO is empty
N *
N *    @details      This macro get Tx empty register value.
N */
N#define UART_GET_TX_EMPTY(uart)    ((uart)->FSR & UART_FSR_TX_EMPTY_Msk)
N
N
N/**
N *    @brief        Get Rx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Rx FIFO is not empty
N *    @retval       >=1 Rx FIFO is empty
N *
N *    @details      This macro get Rx empty register value.
N */
N#define UART_GET_RX_EMPTY(uart)    ((uart)->FSR & UART_FSR_RX_EMPTY_Msk)
N
N/**
N *    @brief        Check specified uart port transmission is over.
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Transmission is not over.
N *    @retval       1   Transmission is over.
N *
N *    @details      This macro return if Tx FIFO is empty and specified uart port transmission is over nor not.
N */
N#define UART_IS_TX_EMPTY(uart)    (((uart)->FSR & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos)
N
N
N/**
N *    @brief        Wait specified uart port transmission is over
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro wait specified uart port transmission is over.
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!((((uart)->FSR) & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos))
N
N/**
N *    @brief        Check RX is ready or not
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0 The number of bytes in the RX FIFO is less than the RFITL
N *    @retval       1 The number of bytes in the RX FIFO equals or larger than RFITL
N *
N *    @details      This macro check receive data available interrupt flag is set or not.
N */
N#define UART_IS_RX_READY(uart)    (((uart)->ISR & UART_ISR_RDA_IF_Msk)>>UART_ISR_RDA_IF_Pos)
N
N
N/**
N *    @brief        Check TX FIFO is full or not
N *
N *    @param[in]    uart   The pointer of the specified UART module
N *
N *    @retval       1 TX FIFO is full
N *    @retval       0 TX FIFO is not full
N *
N *    @details      This macro check TX FIFO is full or not.
N */
N#define UART_IS_TX_FULL(uart)    (((uart)->FSR & UART_FSR_TX_FULL_Msk)>>UART_FSR_TX_FULL_Pos)
N
N/**
N *    @brief        Check RX FIFO is full or not
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       1 RX FIFO is full
N *    @retval       0 RX FIFO is not full
N *
N *    @details      This macro check RX FIFO is full or not.
N */
N#define UART_IS_RX_FULL(uart)    (((uart)->FSR & UART_FSR_RX_FULL_Msk)>>UART_FSR_RX_FULL_Pos)
N
N
N/**
N *    @brief        Get Tx full register value
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0   Tx FIFO is not full.
N *    @retval       >=1 Tx FIFO is full.
N *
N *    @details      This macro get Tx full register value.
N */
N#define UART_GET_TX_FULL(uart)    ((uart)->FSR & UART_FSR_TX_FULL_Msk)
N
N
N/**
N *    @brief        Get Rx full register value
N *
N *    @param[in]    uart   The pointer of the specified UART module
N *
N *    @retval       0   Rx FIFO is not full.
N *    @retval       >=1 Rx FIFO is full.
N *
N *    @details      This macro get Rx full register value.
N */
N#define UART_GET_RX_FULL(uart)    ((uart)->FSR & UART_FSR_RX_FULL_Msk)
N
N
N
N/**
N *    @brief        Enable specified UART interrupt
N *
N *    @param[in]    uart        The pointer of the specified UART module
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - UART_IER_LIN_RX_BRK_IEN_Msk  : Lin bus Rx break field interrupt
N *                              - UART_IER_WAKE_EN_Msk         : Wakeup interrupt
N *                              - UART_IER_BUF_ERR_IEN_Msk     : Buffer Error interrupt
N *                              - UART_IER_RTO_IEN_Msk         : Rx time-out interrupt
N *                              - UART_IER_MODEM_IEN_Msk       : Modem interrupt
N *                              - UART_IER_RLS_IEN_Msk         : Rx Line status interrupt
N *                              - UART_IER_THRE_IEN_Msk        : Tx empty interrupt
N *                              - UART_IER_RDA_IEN_Msk         : Rx ready interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    ((uart)->IER |= (u32eIntSel))
N
N
N/**
N *    @brief        Disable specified UART interrupt
N *
N *    @param[in]    uart        The pointer of the specified UART module
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - UART_IER_LIN_RX_BRK_IEN_Msk  : Lin bus Rx break field interrupt
N *                              - UART_IER_WAKE_EN_Msk         : Wakeup interrupt
N *                              - UART_IER_BUF_ERR_IEN_Msk     : Buffer Error interrupt
N *                              - UART_IER_RTO_IEN_Msk         : Rx time-out interrupt
N *                              - UART_IER_MODEM_IEN_Msk       : Modem interrupt
N *                              - UART_IER_RLS_IEN_Msk         : Rx Line status interrupt
N *                              - UART_IER_THRE_IEN_Msk        : Tx empty interrupt
N *                              - UART_IER_RDA_IEN_Msk         : Rx ready interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    ((uart)->IER &= ~ (u32eIntSel))
N
N
N/**
N *    @brief        Get specified interrupt indicator status
N *
N *    @param[in]    uart            The pointer of the specified UART module
N *    @param[in]    u32eIntTypeFlag Interrupt Type Flag, should be
N  *                                 - UART_ISR_LIN_RX_BREAK_INT_Msk : LIN Bus Interrupt Indicator
N *                                  - UART_ISR_BUF_ERR_INT_Msk      : Buffer Error Interrupt Indicator
N *                                  - UART_ISR_TOUT_INT_Msk         : Rx Time-out Interrupt Indicator
N *                                  - UART_ISR_MODEM_INT_Msk        : MODEM Status Interrupt Indicator
N *                                  - UART_ISR_RLS_INT_Msk          : Rx Line Status Interrupt Indicator
N *                                  - UART_ISR_THRE_INT_Msk         : Tx Empty Interrupt Indicator
N *                                  - UART_ISR_RDA_INT_Msk          : Rx Ready Interrupt Indicator
N *                                  - UART_ISR_LIN_RX_BREAK_IF_Msk  : LIN Bus Interrupt Flag
N *                                  - UART_ISR_BUF_ERR_IF_Msk       : Buffer Error Interrupt Flag
N *                                  - UART_ISR_TOUT_IF_Msk          : Rx Time-out Interrupt Flag
N *                                  - UART_ISR_MODEM_IF_Msk         : MODEM Status Interrupt Flag
N *                                  - UART_ISR_RLS_IF_Msk           : Rx Line Status Interrupt Flag
N *                                  - UART_ISR_THRE_IF_Msk          : Tx Empty Interrupt Flag
N *                                  - UART_ISR_RDA_IF_Msk           : Rx Ready Interrupt Flag
N *
N *    @retval       0 The specified interrupt is not happened.
N *                  1 The specified interrupt is happened.
N *
N *    @details      This macro get specified interrupt flag or interrupt indicator status.
N */
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    (((uart)->ISR & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief        Set RTS pin to low
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to low.
N */
N__STATIC_INLINE void UART_CLEAR_RTS(UART_T* uart)
Xstatic __inline void UART_CLEAR_RTS(UART_T* uart)
N{
N    (uart)->MCR |= UART_MCR_LEV_RTS_Msk;
X    (uart)->MCR |= (1ul << 9);
N    (uart)->MCR &= ~UART_MCR_RTS_Msk;
X    (uart)->MCR &= ~(1ul << 1);
N}
N
N/**
N *    @brief        Set RTS pin to high
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *    @return       None
N *
N *    @details      This macro set RTS pin to high.
N */
N__STATIC_INLINE void UART_SET_RTS(UART_T* uart)
Xstatic __inline void UART_SET_RTS(UART_T* uart)
N{
N    (uart)->MCR |= UART_MCR_LEV_RTS_Msk | UART_MCR_RTS_Msk;
X    (uart)->MCR |= (1ul << 9) | (1ul << 1);
N}
N
N
N/**
N *    @brief        Clear RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @return       None
N *
N *    @details      This macro clear RS-485 address byte detection flag.
N */
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    ((uart)->FSR = UART_FSR_RS485_ADD_DETF_Msk)
N
N
N/**
N *    @brief        Get RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The pointer of the specified UART module
N *
N *    @retval       0 Receiver detects a data that is not an address bit.
N *    @retval       1 Receiver detects a data that is an address bit.
N *
N *    @details      This macro get RS-485 address byte detection flag.
N */
N#define UART_RS485_GET_ADDR_FLAG(uart)    (((uart)->FSR  & UART_FSR_RS485_ADD_DETF_Msk) >> UART_FSR_RS485_ADD_DETF_Pos)
N
N
Nvoid UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart);
Nvoid UART_DisableFlowCtrl(UART_T* uart);
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_EnableFlowCtrl(UART_T* uart);
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nuint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nvoid UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
Nvoid UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength);
Nuint32_t UART_Write(UART_T* uart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N/*@}*/ /* end of group UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group UART_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
N
L 5977 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "hdiv.h"
L 1 "..\..\..\..\Library\StdDriver\inc\hdiv.h" 1
N/**************************************************************************//**
N * @file     hdiv.h
N * @version  V2.1
N * $Revision: 5 $
N * $Date: 14/07/18 4:37p $
N * @brief    M051 Series DIV Driver Header File
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __DIVIDER_H__
N#define __DIVIDER_H__
N
N
N/**
N * @brief      Division function to calculate (x/y)
N *
N * @param[in]  x the dividend of the division
N * @param[in]  y the divisor of the division
N *
N * @return     The result of (x/y)
N *
N * @details    This is a division function to calculate x/y
N *
N */
Nstatic __INLINE int32_t HDIV_Div(int32_t x, int16_t y)
Xstatic __inline int32_t HDIV_Div(int32_t x, int16_t y)
N{
N    uint32_t *p32;
N
N    p32 = (uint32_t *)HDIV_BASE;
X    p32 = (uint32_t *)((( uint32_t)0x50000000) + 0x14000);
N    *p32++ = x;
N    *p32++ = y;
N    return *p32;
N}
N
N
N/**
N * @brief      To calculate the remainder of x/y, i.e., the result of x mod y.
N *
N * @param[in]  x the dividend of the division
N * @param[in]  y the divisor of the division
N *
N * @return     The remainder of (x/y)
N *
N * @details    This function is used to calculate the remainder of x/y.
N */
Nstatic __INLINE int16_t HDIV_Mod(int32_t x, int16_t y)
Xstatic __inline int16_t HDIV_Mod(int32_t x, int16_t y)
N{
N    uint32_t *p32;
N
N    p32 = (uint32_t *)HDIV_BASE;
X    p32 = (uint32_t *)((( uint32_t)0x50000000) + 0x14000);
N    *p32++ = x;
N    *p32++ = y;
N    return p32[1];
N}
N
N
N#endif
N
N
L 5978 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#include "acmp.h"
L 1 "..\..\..\..\Library\StdDriver\inc\acmp.h" 1
N/**************************************************************************//**
N * @file     acmp.h
N * @version  V3.00
N * $Revision: 10 $
N * $Date: 15/05/20 2:07p $
N * @brief    M051 series Analog Comparator(ACMP) driver header file
N *
N * @note
N * SPDX-License-Identifier: Apache-2.0
N *
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __ACMP_H__
N#define __ACMP_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup ACMP_Driver ACMP Driver
N  @{
N*/
N
N/** @addtogroup ACMP_EXPORTED_CONSTANTS ACMP Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ACMP_CR constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ACMP_CR_OUTPUT_INV           (1UL << ACMP_CR_ACMPOINV_Pos) /*!< ACMP_CR setting for ACMP output inverse function. */
N#define ACMP_CR_VNEG_BANDGAP         (1UL << ACMP_CR_NEGSEL_Pos)   /*!< ACMP_CR setting for selecting band-gap voltage as the source of ACMP V-. */
N#define ACMP_CR_VNEG_PIN             (0UL << ACMP_CR_NEGSEL_Pos)   /*!< ACMP_CR setting for selecting the voltage of ACMP negative input pin as the source of ACMP V-. */
N#define ACMP_CR_HYSTERESIS_ENABLE    (1UL << ACMP_CR_HYSEN_Pos)    /*!< ACMP_CR setting for enabling the hysteresis function. */
N#define ACMP_CR_HYSTERESIS_DISABLE   (0UL << ACMP_CR_HYSEN_Pos)    /*!< ACMP_CR setting for disabling the hysteresis function. */
N#define ACMP_CR_INT_ENABLE           (1UL << ACMP_CR_ACMPIE_Pos)   /*!< ACMP_CR setting for enabling the interrupt function. */
N#define ACMP_CR_INT_DISABLE          (0UL << ACMP_CR_ACMPIE_Pos)   /*!< ACMP_CR setting for disabling the interrupt function. */
N#define ACMP_CR_ACMP_ENABLE          (1UL << ACMP_CR_ACMPEN_Pos)   /*!< ACMP_CR setting for enabling the ACMP analog circuit. */
N#define ACMP_CR_ACMP_DISABLE         (0UL << ACMP_CR_ACMPEN_Pos)   /*!< ACMP_CR setting for disabling the ACMP analog circuit. */
N
N/*@}*/ /* end of group ACMP_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ACMP_EXPORTED_FUNCTIONS ACMP Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro is used to enable output inverse function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set ACMPOINV bit of ACMP_CR register to enable output inverse function.
N  */
N#define ACMP_ENABLE_OUTPUT_INVERSE(acmp, u32ChNum) ((acmp)->CR[(u32ChNum)%2] |= ACMP_CR_ACMPOINV_Msk)
N
N/**
N  * @brief This macro is used to disable output inverse function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear ACMPOINV bit of ACMP_CR register to disable output inverse function.
N  */
N#define ACMP_DISABLE_OUTPUT_INVERSE(acmp, u32ChNum) ((acmp)->CR[(u32ChNum)%2] &= ~ACMP_CR_ACMPOINV_Msk)
N
N/**
N  * @brief This macro is used to select ACMP negative input source
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Src Comparator negative input selection.  Including :
N  *                  - \ref ACMP_CR_VNEG_PIN
N  *                  - \ref ACMP_CR_VNEG_BANDGAP
N  * @return None
N  * @details This macro will set NEGSEL bit of ACMP_CR register to determine the source of negative input.
N  */
N#define ACMP_SET_NEG_SRC(acmp, u32ChNum, u32Src) ((acmp)->CR[(u32ChNum)%2] = ((acmp)->CR[(u32ChNum)%2] & ~ACMP_CR_NEGSEL_Msk) | (u32Src))
N
N/**
N  * @brief This macro is used to enable hysteresis function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set HYSEN bit of ACMP_CR register to enable hysteresis function.
N  */
N#define ACMP_ENABLE_HYSTERESIS(acmp, u32ChNum) ((acmp)->CR[(u32ChNum)%2] |= ACMP_CR_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to disable hysteresis function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear HYSEN bit of ACMP_CR register to disable hysteresis function.
N  */
N#define ACMP_DISABLE_HYSTERESIS(acmp, u32ChNum) ((acmp)->CR[(u32ChNum)%2] &= ~ACMP_CR_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to enable interrupt
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set ACMPIE bit of ACMP_CR register to enable interrupt function.
N  */
N#define ACMP_ENABLE_INT(acmp, u32ChNum) ((acmp)->CR[(u32ChNum)%2] |= ACMP_CR_ACMPIE_Msk)
N
N/**
N  * @brief This macro is used to disable interrupt
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear ACMPIE bit of ACMP_CR register to disable interrupt function.
N  */
N#define ACMP_DISABLE_INT(acmp, u32ChNum) ((acmp)->CR[(u32ChNum)%2] &= ~ACMP_CR_ACMPIE_Msk)
N
N
N/**
N  * @brief This macro is used to enable ACMP
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set ACMPEN bit of ACMP_CR register to enable analog comparator.
N  */
N#define ACMP_ENABLE(acmp, u32ChNum) ((acmp)->CR[(u32ChNum)%2] |= ACMP_CR_ACMPEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear ACMPEN bit of ACMP_CR register to disable analog comparator.
N  */
N#define ACMP_DISABLE(acmp, u32ChNum) ((acmp)->CR[(u32ChNum)%2] &= ~ACMP_CR_ACMPEN_Msk)
N
N/**
N  * @brief This macro is used to get ACMP output value
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return  ACMP output value
N  * @details This macro will return the ACMP output value.
N  */
N#define ACMP_GET_OUTPUT(acmp, u32ChNum) (((acmp)->SR & (ACMP_SR_ACMPO0_Msk<<((u32ChNum)%2)))?1:0)
N
N/**
N  * @brief This macro is used to get ACMP interrupt flag
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   ACMP interrupt occurred or not
N  * @details This macro will return the ACMP interrupt flag.
N  */
N#define ACMP_GET_INT_FLAG(acmp, u32ChNum) (((acmp)->SR & (ACMP_SR_ACMPF0_Msk<<((u32ChNum)%2)))?1:0)
N
N/**
N  * @brief This macro is used to clear ACMP interrupt flag
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   None
N  * @details This macro will write 1 to CMPFn bit of CMPSR register to clear interrupt flag.
N  */
N#define ACMP_CLR_INT_FLAG(acmp, u32ChNum) ((acmp)->SR = (ACMP_SR_ACMPF0_Msk<<((u32ChNum)%2)))
N
N
N/* Function prototype declaration */
Nvoid ACMP_Open(ACMP_T *, uint32_t u32ChNum, uint32_t u32NegSrc, uint32_t u32HysteresisEn);
Nvoid ACMP_Close(ACMP_T *, uint32_t u32ChNum);
N
N/*@}*/ /* end of group ACMP_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ACMP_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ACMP_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 5979 "..\..\..\..\Library\Device\Nuvoton\M051Series\Include\M051Series.h" 2
N#endif
N
N/* Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved. */
N
N
N
L 18 "..\..\..\..\Library\StdDriver\src\retarget.c" 2
N
N#if defined ( __CC_ARM   )
X#if 1L
N#if (__ARMCC_VERSION < 400000)
X#if (5060960 < 400000)
N#else
N/* Insist on keeping widthprec, to avoid X propagation by benign code in C-lib */
N#pragma import _printf_widthprec
N#endif
N#endif
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Global variables                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#if !(defined(__ICCARM__) && (__VER__ >= 6010000))
X#if !(0L && (__VER__ >= 6010000))
Nstruct __FILE
N{
N    int handle; /* Add whatever you need here */
N};
N#endif
NFILE __stdout;
NFILE __stdin;
N
Nenum { r0, r1, r2, r3, r12, lr, pc, psr};
N
N/**
N * @brief       Helper function to dump register while hard fault occurred
N * @param[in]   stack pointer points to the dumped registers in SRAM
N * @return      None
N * @details     This function is implement to print r0, r1, r2, r3, r12, lr, pc, psr
N */
Nstatic void stackDump(uint32_t stack[])
N{   
N    printf("r0  = 0x%x\n", stack[r0]);
N    printf("r1  = 0x%x\n", stack[r1]);
N    printf("r2  = 0x%x\n", stack[r2]);
N    printf("r3  = 0x%x\n", stack[r3]);
N    printf("r12 = 0x%x\n", stack[r12]);
N    printf("lr  = 0x%x\n", stack[lr]);
N    printf("pc  = 0x%x\n", stack[pc]);
N    printf("psr = 0x%x\n", stack[psr]);
N}
N
N/**
N * @brief       Hard fault handler
N * @param[in]   stack pointer points to the dumped registers in SRAM
N * @return      None
N * @details     Replace while(1) at the end of this function with chip reset if WDT is not enabled for end product
N */
Nvoid Hard_Fault_Handler(uint32_t stack[])
N{
N    printf("In Hard Fault Handler\n");
N
N    stackDump(stack);
N
N    // Replace while(1) with chip reset if WDT is not enabled for end product
N    while(1);
N    //SYS->IPRSTC1 = SYS_IPRSTC1_CHIP_RST_Msk;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Routine to write a char                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#if defined(DEBUG_ENABLE_SEMIHOST)
X#if 0L
S/* The static buffer is used to speed up the semihost */
Sstatic char g_buf[16];
Sstatic char g_buf_len = 0;
S
S/* Make sure won't goes here only because --gnu is defined , so
S   add !__CC_ARM and !__ICCARM__ checking */
S# if defined ( __GNUC__ ) && !(__CC_ARM) && !(__ICCARM__)
S
S# elif defined(__ICCARM__)
S
S
Svoid SH_End(void)
S{
S    asm("MOVS   R0,#1 \n"        //; Set return value to 1
S        "BX     lr    \n"            //; Return
S       );
S}
S
Svoid SH_ICE(void)
S{
S  asm("CMP   R2,#0   \n"
S      "BEQ   SH_End  \n"
S      "STR   R0,[R2] \n"       //; Save the return value to *pn32Out_R0
S     );
S}
S
S/**
S *
S * @brief      The function to process semihosted command
S * @param[in]  n32In_R0  : semihost register 0
S * @param[in]  n32In_R1  : semihost register 1
S * @param[out] pn32Out_R0: semihost register 0
S * @retval     0: No ICE debug
S * @retval     1: ICE debug
S *
S */
Sint32_t SH_DoCommand(int32_t n32In_R0, int32_t n32In_R1, int32_t *pn32Out_R0)
S{
S    asm("BKPT   0xAB   \n"       //; This instruction will cause ICE trap or system HardFault
S        "B      SH_ICE \n"
S        "SH_HardFault: \n"       //; Captured by HardFault
S        "MOVS   R0,#0  \n"       //; Set return value to 0
S        "BX     lr     \n"       //; Return
S        );
S
S    return 1;                    //; Return 1 when it is trap by ICE
S}
S
S/**
S * @brief       Get LR value and branch to Hard_Fault_Handler function
S * @param       None
S * @return      None
S * @details     This function is use to get LR value and branch to Hard_Fault_Handler function.
S */
Svoid Get_LR_and_Branch(void)
S{
S    asm("MOV     R1, LR               \n" //; LR current value
S        "B       Hard_Fault_Handler   \n"
S       );
S}
S
S/**
S * @brief       Get MSP value and branch to Get_LR_and_Branch function
S * @param       None
S * @return      None
S * @details     This function is use to get stack pointer value and branch to Get_LR_and_Branch function.
S */
Svoid Stack_Use_MSP(void)
S{
S    asm("MRS     R0, MSP           \n" //; read MSP
S        "B       Get_LR_and_Branch \n"
S       );
S}
S
S/**
S * @brief       Get stack pointer value and branch to Get_LR_and_Branch function
S * @param       None
S * @return      None
S * @details     This function is use to get stack pointer value and branch to Get_LR_and_Branch function.
S */
Svoid HardFault_Handler_Ret(void)
S{
S    asm("MOVS    r0, #4                        \n"
S        "MOV     r1, LR                        \n"
S        "TST     r0, r1                        \n" //; check LR bit 2
S        "BEQ     Stack_Use_MSP                 \n" //; stack use MSP
S        "MRS     R0, PSP                       \n" //; stack use PSP, read PSP
S        "B       Get_LR_and_Branch             \n"
S       );
S}
S
S/**
S * @brief    This function is implemented to support semihost
S * @param    None
S * @returns  None
S * @details  This function is implement to support semihost message print.
S *
S */
Svoid SP_Read_Ready(void)
S{
S    asm("LDR     R1, [R0, #24] \n"        //; Get previous PC
S        "LDRH    R3, [R1]      \n"        //; Get instruction
S        "LDR     R2, [pc, #8]  \n"        //; The special BKPT instruction
S        "CMP     R3, R2        \n"        //; Test if the instruction at previous PC is BKPT
S        "BNE     HardFault_Handler_Ret \n" //; Not BKPT
S        "ADDS    R1, #4        \n"        //; Skip BKPT and next line
S        "STR     R1, [R0, #24] \n"        //; Save previous PC
S        "BX      lr            \n"        //; Return
S        "DCD     0xBEAB        \n"        //; BKPT instruction code
S        "B       HardFault_Handler_Ret \n"
S       );
S}
S
S/**
S * @brief       Get stack pointer value and branch to Get_LR_and_Branch function
S * @param       None
S * @return      None
S * @details     This function is use to get stack pointer value and branch to Get_LR_and_Branch function.
S */
Svoid SP_is_PSP(void)
S{
S    asm(
S        "MRS     R0, PSP       \n"      //; stack use PSP, read PSP
S        "B       Get_LR_and_Branch    \n"
S    
S       );
S}
S
S/**
S * @brief    This HardFault handler is implemented to support semihost
S *
S * @param    None
S *
S * @returns  None
S *
S * @details  This function is implement to support semihost message print.
S *
S */
Svoid HardFault_Handler (void)
S{
S    asm("MOV     R0, lr        \n"
S        "LSLS    R0, #29       \n"        //; Check bit 2
S        "BMI     SP_is_PSP     \n"        //; previous stack is PSP
S        "MRS     R0, MSP       \n"        //; previous stack is MSP, read MSP
S        "B       SP_Read_Ready \n"
S       );
S
S    while(1);
S}
S
S
S# else
S
S/**
S * @brief    This HardFault handler is implemented to support semihost
S * @param    None
S * @returns  None
S * @details  This function is implement to support semihost message print.
S *
S */
S__asm int32_t HardFault_Handler(void)
S{
S    IMPORT  Hard_Fault_Handler
S
S    MOV     R0, LR
S    LSLS    R0, #29               //; Check bit 2
S    BMI     SP_is_PSP             //; previous stack is PSP
S    MRS     R0, MSP               //; previous stack is MSP, read MSP
S    B       SP_Read_Ready
SSP_is_PSP
S    MRS     R0, PSP               //; Read PSP
S
SSP_Read_Ready
S    LDR     R1, [R0, #24]         //; Get previous PC
S    LDRH    R3, [R1]              //; Get instruction
S    LDR     R2, =0xBEAB           //; The special BKPT instruction
S    CMP     R3, R2                //; Test if the instruction at previous PC is BKPT
S    BNE     HardFault_Handler_Ret //; Not BKPT
S
S    ADDS    R1, #4                //; Skip BKPT and next line
S    STR     R1, [R0, #24]         //; Save previous PC
S
S    BX      LR                    //; Return
SHardFault_Handler_Ret
S
S    /* TODO: Implement your own hard fault handler here. */
S    MOVS    r0, #4
S    MOV     r1, LR
S    TST     r0, r1                          //; check LR bit 2  
S    BEQ     Stack_Use_MSP                   //; stack use MSP
S    MRS     R0, PSP ;stack use PSP          //; stack use PSP, read PSP
S    B       Get_LR_and_Branch
SStack_Use_MSP
S    MRS     R0, MSP ; stack use MSP         //; read MSP
SGet_LR_and_Branch
S    MOV     R1, LR ; LR current value       //; LR current value       
S    LDR     R2,=__cpp(Hard_Fault_Handler)   //; branch to Hard_Fault_Handler 
S    BX      R2
S
S    B       .
S
S                 ALIGN
S}
S
S/**
S *
S * @brief      The function to process semihosted command
S * @param[in]  n32In_R0  : semihost register 0
S * @param[in]  n32In_R1  : semihost register 1
S * @param[out] pn32Out_R0: semihost register 0
S * @retval     0: No ICE debug
S * @retval     1: ICE debug
S *
S */
S__asm int32_t SH_DoCommand(int32_t n32In_R0, int32_t n32In_R1, int32_t *pn32Out_R0)
S{
S    BKPT   0xAB          //; Wait ICE or HardFault
S    //; ICE will step over BKPT directly
S    //; HardFault will step BKPT and the next line
S    B      SH_ICE
S
SSH_HardFault             //; Captured by HardFault
S    MOVS   R0, #0        //; Set return value to 0
S    BX     lr            //; Return
S
SSH_ICE                   //; Captured by ICE
S    //; Save return value
S    CMP    R2, #0
S    BEQ    SH_End
S    STR    R0, [R2]      //; Save the return value to *pn32Out_R0
S
SSH_End
S    MOVS   R0, #1        //; Set return value to 1
S    BX     lr            //; Return
S}
S#endif
S
S
N#else // Non-semihost
N
N/* Make sure won't goes here only because --gnu is defined , so
N   add !__CC_ARM and !__ICCARM__ checking */
N# if defined ( __GNUC__ ) && !(__CC_ARM) && !(__ICCARM__)
X# if 0L && !(1) && !(__ICCARM__)
S
S/**
S * @brief    This HardFault handler is implemented to show r0, r1, r2, r3, r12, lr, pc, psr
S *
S * @param    None
S *
S * @returns  None
S *
S * @details  This function is implement to print r0, r1, r2, r3, r12, lr, pc, psr.
S *
S */
Svoid HardFault_Handler(void)
S{
S    asm("MOVS    r0, #4                        \n"
S        "MOV     r1, LR                        \n"
S        "TST     r0, r1                        \n" /*; check LR bit 2 */
S        "BEQ     1f                            \n" /*; stack use MSP */
S        "MRS     R0, PSP                       \n" /*; stack use PSP, read PSP */
S        "MOV     R1, LR                        \n" /*; LR current value */
S        "B       Hard_Fault_Handler            \n"
S        "1:                                    \n"
S        "MRS     R0, MSP                       \n" /*; LR current value */
S        "B       Hard_Fault_Handler            \n"
S        ::[Hard_Fault_Handler] "r" (Hard_Fault_Handler) // input
S    );
S    while(1);
S}
S
S# elif defined(__ICCARM__)
X# elif 0L
S
Svoid Get_LR_and_Branch(void)
S{
S    asm("MOV     R1, LR                  \n" //; LR current value
S        "B       Hard_Fault_Handler      \n"
S       );
S}
S
Svoid Stack_Use_MSP(void)
S{
S    asm("MRS     R0, MSP           \n" //; read MSP
S        "B       Get_LR_and_Branch \n"
S       );
S}
S
S/**
S * @brief    This HardFault handler is implemented to show r0, r1, r2, r3, r12, lr, pc, psr
S *
S * @param    None
S *
S * @returns  None
S *
S * @details  This function is implement to print r0, r1, r2, r3, r12, lr, pc, psr.
S *
S */
Svoid HardFault_Handler(void)
S{
S    asm("MOVS    r0, #4                        \n"
S        "MOV     r1, LR                        \n"
S        "TST     r0, r1                        \n" //; check LR bit 2
S        "BEQ     Stack_Use_MSP                 \n" //; stack use MSP
S        "MRS     R0, PSP                       \n" //; stack use PSP, read PSP
S        "B       Get_LR_and_Branch             \n"
S       );
S
S    while(1);
S}
S
N# else
N
N/**
N * @brief    This HardFault handler is implemented to show r0, r1, r2, r3, r12, lr, pc, psr
N *
N * @param    None
N *
N * @return   None
N *
N * @details  The function extracts the location of stack frame and passes it to Hard_Fault_Handler function as a pointer
N *
N */
N__asm int32_t HardFault_Handler(void)
N{
N    IMPORT  Hard_Fault_Handler
N
N    MOVS    r0, #4
N    MOV     r1, LR
N    TST     r0, r1          //; check LR bit 2                 
N    BEQ     Stack_Use_MSP   //; stack use MSP
N    MRS     R0, PSP         //; stack use PSP, read PSP
N    B       Get_LR_and_Branch
NStack_Use_MSP
N    MRS     R0, MSP         //; read MSP
NGet_LR_and_Branch
N    MOV     R1, LR          //; LR current value
N    LDR     R2,=__cpp(Hard_Fault_Handler) //; branch to Hard_Fault_Handler 
N    BX      R2
N}
N
N#endif
N
N#endif
N
N
N/**
N * @brief    Routine to send a char
N *
N * @param[in] ch  A character data writes to debug port
N *
N * @returns  Send value from UART debug port
N *
N * @details  Send a target char to UART debug port .
N */
N#ifndef NONBLOCK_PRINTF
Nvoid SendChar_ToUART(int ch)
N{
N
N    while(DEBUG_PORT->FSR & UART_FSR_TX_FULL_Msk);
X    while(((UART_T *) ((( uint32_t)0x40000000) + 0x50000))->FSR & (1ul << 23));
N    if(ch == '\n')
N    {
N        DEBUG_PORT->DATA = '\r';
X        ((UART_T *) ((( uint32_t)0x40000000) + 0x50000))->DATA = '\r';
N        while(DEBUG_PORT->FSR & UART_FSR_TX_FULL_Msk);
X        while(((UART_T *) ((( uint32_t)0x40000000) + 0x50000))->FSR & (1ul << 23));
N    }
N
N    DEBUG_PORT->DATA = ch;
X    ((UART_T *) ((( uint32_t)0x40000000) + 0x50000))->DATA = ch;
N}
N
N#else
S/* Non-block implement of send char */
S#define BUF_SIZE    512
Svoid SendChar_ToUART(int ch)
S{
S    static uint8_t u8Buf[BUF_SIZE] = {0};
S    static int32_t i32Head = 0;
S    static int32_t i32Tail = 0;
S    int32_t i32Tmp;
S
S    /* Only flush the data in buffer to UART when ch == 0 */
S    if(ch)
S    {
S        // Push char
S        if(ch == '\n')
S        {
S            i32Tmp = i32Head+1;
S            if(i32Tmp > BUF_SIZE) i32Tmp = 0;
S            if(i32Tmp != i32Tail)
S            {
S                u8Buf[i32Head] = '\r';
S                i32Head = i32Tmp;
S            }
S        }
S
S        i32Tmp = i32Head + 1;
S        if(i32Tmp > BUF_SIZE) i32Tmp = 0;
S        if(i32Tmp != i32Tail)
S        {
S            u8Buf[i32Head] = ch;
S            i32Head = i32Tmp;
S        }
S    }
S    else
S    {
S        if(i32Tail == i32Head)
S            return;
S    }
S    
S    // pop char
S    do
S    {
S        i32Tmp = i32Tail + 1;
S        if(i32Tmp > BUF_SIZE) i32Tmp = 0;
S        
S        if((DEBUG_PORT->FSR & UART_FSR_TX_FULL_Msk) == 0)
S        {
S            DEBUG_PORT->DATA = u8Buf[i32Tail];
S            i32Tail = i32Tmp;
S        }
S        else
S            break; // FIFO full
S    }while(i32Tail != i32Head);
S}
N#endif
N
N/**
N * @brief    Routine to send a char
N *
N * @param[in] ch A character data writes to debug port
N *
N * @returns  Send value from UART debug port or semihost
N *
N * @details  Send a target char to UART debug port or semihost.
N */
Nvoid SendChar(int ch)
N{
N#if defined(DEBUG_ENABLE_SEMIHOST)
X#if 0L
S    g_buf[g_buf_len++] = ch;
S    g_buf[g_buf_len] = '\0';
S    if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0')
S    {
S        /* Send the char */
S        if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0)
S        {
S            g_buf_len = 0;
S            return;
S        }
S        else
S        {
S            g_buf_len = 0;
S        }
S    }
N#else
N    SendChar_ToUART(ch);
N#endif
N}
N
N/**
N * @brief    Routine to get a char
N *
N * @param    None
N *
N * @returns  Get value from UART debug port or semihost
N *
N * @details  Wait UART debug port or semihost to input a char.
N */
Nchar GetChar(void)
N{
N#ifdef DEBUG_ENABLE_SEMIHOST
S# if defined (__CC_ARM)
S    int nRet;
S    while(SH_DoCommand(0x101, 0, &nRet) != 0)
S    {
S        if(nRet != 0)
S        {
S            SH_DoCommand(0x07, 0, &nRet);
S            return (char)nRet;
S        }
S    }
S# else
S    int nRet;
S    while(SH_DoCommand(0x7, 0, &nRet) != 0)
S    {
S        if(nRet != 0)
S            return (char)nRet;
S    }
S# endif
S    return (0);
N#else
N
N    while(1)
N    {
N        if((DEBUG_PORT->FSR & UART_FSR_RX_EMPTY_Msk) == 0)
X        if((((UART_T *) ((( uint32_t)0x40000000) + 0x50000))->FSR & (1ul << 14)) == 0)
N        {
N            return (DEBUG_PORT->DATA);
X            return (((UART_T *) ((( uint32_t)0x40000000) + 0x50000))->DATA);
N        }
N    }
N
N#endif
N}
N
N/**
N * @brief    Check any char input from UART
N *
N * @param    None
N *
N * @retval   1: No any char input
N * @retval   0: Have some char input
N *
N * @details  Check UART RSR RX EMPTY or not to determine if any char input from UART
N */
N
Nint kbhit(void)
N{
N    return !((DEBUG_PORT->FSR & UART_FSR_RX_EMPTY_Msk) == 0);
X    return !((((UART_T *) ((( uint32_t)0x40000000) + 0x50000))->FSR & (1ul << 14)) == 0);
N}
N/**
N * @brief    Check if debug message finished
N *
N * @param    None
N *
N * @retval   1: Message is finished
N * @retval   0: Message is transmitting.
N *
N * @details  Check if message finished (FIFO empty of debug port)
N */
N
Nint IsDebugFifoEmpty(void)
N{
N    return ((DEBUG_PORT->FSR & UART_FSR_TE_FLAG_Msk) != 0);
X    return ((((UART_T *) ((( uint32_t)0x40000000) + 0x50000))->FSR & (1ul << 28)) != 0);
N}
N
N/**
N * @brief    C library retargetting
N *
N * @param[in]  ch  Write a character data
N *
N * @returns  None
N *
N * @details  Check if message finished (FIFO empty of debug port)
N */
N
Nvoid _ttywrch(int ch)
N{
N    SendChar(ch);
N    return;
N}
N
N
N/**
N * @brief      Write character to stream
N *
N * @param[in]  ch       Character to be written. The character is passed as its int promotion.
N * @param[in]  stream   Pointer to a FILE object that identifies the stream where the character is to be written.
N *
N * @returns    If there are no errors, the same character that has been written is returned.
N *             If an error occurs, EOF is returned and the error indicator is set (see ferror).
N *
N * @details    Writes a character to the stream and advances the position indicator.\n
N *             The character is written at the current position of the stream as indicated \n
N *             by the internal position indicator, which is then advanced one character.
N *
N * @note       The above descriptions are copied from http://www.cplusplus.com/reference/clibrary/cstdio/fputc/.
N *
N *
N */
N
Nint fputc(int ch, FILE *stream)
N{
N    SendChar(ch);
N    return ch;
N}
N
N#if defined ( __GNUC__ )
X#if 0L
S
S#if !defined (OS_USE_SEMIHOSTING)
Sint _write (int fd, char *ptr, int len)
S{
S    int i = len;
S
S    while(i--)
S    {
S        while(DEBUG_PORT->FSR & UART_FSR_TX_FULL_Msk);
S
S        if(*ptr == '\n')
S        {
S            DEBUG_PORT->DATA = '\r';
S            while(DEBUG_PORT->FSR & UART_FSR_TX_FULL_Msk);
S        }
S
S        DEBUG_PORT->DATA = *ptr++;
S	}
S    return len;
S}
S
Sint _read (int fd, char *ptr, int len)
S{
S
S    while((DEBUG_PORT->FSR & UART_FSR_RX_EMPTY_Msk) != 0);
S    *ptr = DEBUG_PORT->DATA;
S    return 1;
S
S
S}
S#endif
S
N#else
N/**
N * @brief      Get character from UART debug port or semihosting input
N *
N * @param[in]  stream   Pointer to a FILE object that identifies the stream on which the operation is to be performed.
N *
N * @returns    The character read from UART debug port or semihosting
N *
N * @details    For get message from debug port or semihosting.
N *
N */
N
Nint fgetc(FILE *stream)
N{
N    return (GetChar());
N}
N
N/**
N * @brief      Check error indicator
N *
N * @param[in]  stream   Pointer to a FILE object that identifies the stream.
N *
N * @returns    If the error indicator associated with the stream was set, the function returns a nonzero value.
N *             Otherwise, it returns a zero value.
N *
N * @details    Checks if the error indicator associated with stream is set, returning a value different
N *             from zero if it is. This indicator is generally set by a previous operation on the stream that failed.
N *
N * @note       The above descriptions are copied from http://www.cplusplus.com/reference/clibrary/cstdio/ferror/.
N *
N */
N
Nint ferror(FILE *stream)
N{
N    return EOF;
X    return (-1);
N}
N#endif
N
N#ifdef DEBUG_ENABLE_SEMIHOST
S# ifdef __ICCARM__
Svoid __exit(int return_code)
S{
S
S    /* Check if link with ICE */
S    if(SH_DoCommand(0x18, 0x20026, NULL) == 0)
S    {
S        /* Make sure all message is print out */
S        while(IsDebugFifoEmpty() == 0);
S    }
Slabel:
S    goto label;  /* endless loop */
S}
S# else
Svoid _sys_exit(int return_code)
S{
S
S    /* Check if link with ICE */
S    if(SH_DoCommand(0x18, 0x20026, NULL) == 0)
S    {
S        /* Make sure all message is print out */
S        while(IsDebugFifoEmpty() == 0);
S    }
Slabel:
S    goto label;  /* endless loop */
S}
S# endif
N#endif
N
N
N
N
N
