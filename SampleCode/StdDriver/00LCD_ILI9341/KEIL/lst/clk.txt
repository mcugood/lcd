; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork -Otime --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\M051Series\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\clk.crf ..\..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;32       */
;;;33     void CLK_DisableCKO(void)
000000  4802              LDR      r0,|L1.12|
000002  6841              LDR      r1,[r0,#4]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;34     {
;;;35         /* Disable CKO clock source */
;;;36         CLK_DisableModuleClock(FDIV_MODULE);
;;;37     }
00000a  4770              BX       lr
;;;38     
                          ENDP

                  |L1.12|
                          DCD      0x50000204

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;447      */
;;;448    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  0f81              LSRS     r1,r0,#30
;;;449    {
;;;450        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (MODULE_APBCLK(u32ModuleIdx) * 4))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000002  008a              LSLS     r2,r1,#2
000004  4904              LDR      r1,|L2.24|
000006  1851              ADDS     r1,r2,r1
000008  684a              LDR      r2,[r1,#4]
00000a  06c3              LSLS     r3,r0,#27
00000c  0edb              LSRS     r3,r3,#27
00000e  2001              MOVS     r0,#1
000010  4098              LSLS     r0,r0,r3
000012  4382              BICS     r2,r2,r0
000014  604a              STR      r2,[r1,#4]
;;;451    }
000016  4770              BX       lr
;;;452    
                          ENDP

                  |L2.24|
                          DCD      0x50000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;584      */
;;;585    void CLK_DisablePLL(void)
000000  4802              LDR      r0,|L3.12|
;;;586    {
;;;587        CLK->PLLCON |= CLK_PLLCON_PD_Msk;
000002  6a01              LDR      r1,[r0,#0x20]
000004  01c2              LSLS     r2,r0,#7
000006  4311              ORRS     r1,r1,r2
000008  6201              STR      r1,[r0,#0x20]
;;;588    }
00000a  4770              BX       lr
;;;589    
                          ENDP

                  |L3.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;654      */
;;;655    void CLK_DisableSysTick(void) 
000000  4901              LDR      r1,|L4.8|
;;;656    {    
;;;657        /* Set System Tick counter disabled */
;;;658    	SysTick->CTRL = 0;    
000002  2000              MOVS     r0,#0
000004  6108              STR      r0,[r1,#0x10]
;;;659    }
000006  4770              BX       lr
;;;660    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;378      */
;;;379    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;380    {
;;;381        CLK->PWRCON &= ~u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;382    }
000008  4770              BX       lr
;;;383    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;56       */
;;;57     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  0152              LSLS     r2,r2,#5
;;;58     {
;;;59         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;60         CLK->FRQDIV = CLK_FRQDIV_DIVIDER_EN_Msk | u32ClkDiv | u32ClkDivBy1En << CLK_FRQDIV_DIVIDER1_Pos;
000002  430a              ORRS     r2,r2,r1
000004  2110              MOVS     r1,#0x10
000006  430a              ORRS     r2,r2,r1
000008  b510              PUSH     {r4,lr}               ;58
00000a  4907              LDR      r1,|L6.40|
00000c  624a              STR      r2,[r1,#0x24]
00000e  1d09              ADDS     r1,r1,#4
;;;61     
;;;62         /* Enable CKO clock source */
;;;63         CLK_EnableModuleClock(FDIV_MODULE);
000010  4b06              LDR      r3,|L6.44|
000012  684a              LDR      r2,[r1,#4]
000014  2440              MOVS     r4,#0x40
000016  4322              ORRS     r2,r2,r4
000018  604a              STR      r2,[r1,#4]
;;;64     
;;;65         /* Select CKO clock source */
;;;66         CLK_SetModuleClock(FDIV_MODULE, u32ClkSrc, 0);
00001a  4601              MOV      r1,r0
00001c  2200              MOVS     r2,#0
00001e  4618              MOV      r0,r3
000020  f7fffffe          BL       CLK_SetModuleClock
;;;67     }
000024  bd10              POP      {r4,pc}
;;;68     
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      0x50000200
                  |L6.44|
                          DCD      0x76200006

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;413      */
;;;414    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  0f81              LSRS     r1,r0,#30
;;;415    {
;;;416        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (MODULE_APBCLK(u32ModuleIdx) * 4))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000002  008a              LSLS     r2,r1,#2
000004  4904              LDR      r1,|L7.24|
000006  1851              ADDS     r1,r2,r1
000008  684a              LDR      r2,[r1,#4]
00000a  06c3              LSLS     r3,r0,#27
00000c  0edb              LSRS     r3,r3,#27
00000e  2001              MOVS     r0,#1
000010  4098              LSLS     r0,r0,r3
000012  4302              ORRS     r2,r2,r0
000014  604a              STR      r2,[r1,#4]
;;;417    }
000016  4770              BX       lr
;;;418    
                          ENDP

                  |L7.24|
                          DCD      0x50000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;463      */
;;;464    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;465    {
000002  0007              MOVS     r7,r0
000004  460c              MOV      r4,r1
;;;466        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC;
;;;467        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;468    
;;;469        /* Disable PLL first to avoid unstable when setting PLL. */
;;;470        CLK->PLLCON = CLK_PLLCON_PD_Msk;
000006  4858              LDR      r0,|L8.360|
000008  b085              SUB      sp,sp,#0x14           ;465
00000a  4956              LDR      r1,|L8.356|
00000c  6201              STR      r1,[r0,#0x20]
;;;471    
;;;472        /* PLL source clock is from HXT */    
;;;473        if(u32PllClkSrc == CLK_PLLCON_PLL_SRC_HXT)
;;;474        {
;;;475            /* Enable HXT clock */
;;;476            CLK->PWRCON |= CLK_PWRCON_XTL12M_EN_Msk;
;;;477    
;;;478            /* Wait for HXT clock ready */
;;;479            CLK_WaitClockReady(CLK_CLKSTATUS_XTL12M_STB_Msk);
;;;480    
;;;481            /* Select PLL source clock from HXT */
;;;482            u32CLK_SRC = CLK_PLLCON_PLL_SRC_HXT;
;;;483            u32PllSrcClk = __HXT;
00000e  4d57              LDR      r5,|L8.364|
;;;484    
;;;485            /* u32NR start from 2 */
;;;486            u32NR = 2;
;;;487        }
;;;488        
;;;489        /* PLL source clock is from HIRC */    
;;;490        else
;;;491        {       
;;;492            /* Enable HIRC clock */
;;;493            CLK->PWRCON |= CLK_PWRCON_OSC22M_EN_Msk;
000010  6801              LDR      r1,[r0,#0]
000012  d013              BEQ      |L8.60|
000014  2204              MOVS     r2,#4
000016  4311              ORRS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;494    
;;;495            /* Wait for HIRC clock ready */
;;;496            CLK_WaitClockReady(CLK_CLKSTATUS_OSC22M_STB_Msk);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       CLK_WaitClockReady
;;;497    
;;;498            /* Select PLL source clock from HIRC */
;;;499            u32CLK_SRC = CLK_PLLCON_PLL_SRC_HIRC;
000020  2001              MOVS     r0,#1
000022  04c0              LSLS     r0,r0,#19
;;;500            u32PllSrcClk = __HIRC;
000024  9000              STR      r0,[sp,#0]
000026  4852              LDR      r0,|L8.368|
;;;501    
;;;502            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;503            u32NR = 4;                
000028  2604              MOVS     r6,#4
00002a  9001              STR      r0,[sp,#4]
                  |L8.44|
;;;504        }
;;;505    
;;;506        /* Select "NO" according to request frequency */
;;;507        if((u32PllFreq <= FREQ_200MHZ) && (u32PllFreq > FREQ_100MHZ))
00002c  4851              LDR      r0,|L8.372|
00002e  4952              LDR      r1,|L8.376|
000030  1820              ADDS     r0,r4,r0
000032  4288              CMP      r0,r1
000034  d80d              BHI      |L8.82|
;;;508        {
;;;509            u32NO = 0;
000036  2000              MOVS     r0,#0
000038  9002              STR      r0,[sp,#8]
00003a  e01b              B        |L8.116|
                  |L8.60|
00003c  2201              MOVS     r2,#1                 ;476
00003e  4311              ORRS     r1,r1,r2              ;476
000040  6001              STR      r1,[r0,#0]            ;476
000042  4610              MOV      r0,r2                 ;479
000044  f7fffffe          BL       CLK_WaitClockReady
000048  2000              MOVS     r0,#0                 ;482
00004a  2602              MOVS     r6,#2                 ;486
00004c  9501              STR      r5,[sp,#4]            ;486
00004e  9000              STR      r0,[sp,#0]            ;486
000050  e7ec              B        |L8.44|
                  |L8.82|
;;;510        }
;;;511        else if((u32PllFreq <= FREQ_100MHZ) && (u32PllFreq > FREQ_50MHZ))
000052  484a              LDR      r0,|L8.380|
000054  494a              LDR      r1,|L8.384|
000056  1820              ADDS     r0,r4,r0
000058  4288              CMP      r0,r1
00005a  d803              BHI      |L8.100|
;;;512        {
;;;513            u32NO = 1;
00005c  2001              MOVS     r0,#1
;;;514            u32PllFreq = u32PllFreq << 1;
00005e  0064              LSLS     r4,r4,#1
000060  9002              STR      r0,[sp,#8]
000062  e007              B        |L8.116|
                  |L8.100|
;;;515        }
;;;516        else if((u32PllFreq <= FREQ_50MHZ) && (u32PllFreq >= FREQ_25MHZ))
000064  4847              LDR      r0,|L8.388|
000066  1821              ADDS     r1,r4,r0
000068  4240              RSBS     r0,r0,#0
00006a  4281              CMP      r1,r0
00006c  d848              BHI      |L8.256|
;;;517        {
;;;518            u32NO = 3;
00006e  2003              MOVS     r0,#3
;;;519            u32PllFreq = u32PllFreq << 2;
000070  00a4              LSLS     r4,r4,#2
000072  9002              STR      r0,[sp,#8]
                  |L8.116|
;;;520        }
;;;521        else
;;;522        {
;;;523            /* Wrong frequency request. Just return default setting. */
;;;524            goto lexit;
;;;525        }
;;;526    
;;;527        /* Find best solution */
;;;528        u32Min = (uint32_t) - 1;
;;;529        u32MinNR = 0;
000074  2000              MOVS     r0,#0
000076  2500              MOVS     r5,#0                 ;528
000078  43ed              MVNS     r5,r5                 ;528
;;;530        u32MinNF = 0;
00007a  4607              MOV      r7,r0
;;;531        for(; u32NR <= 33; u32NR++)
00007c  9003              STR      r0,[sp,#0xc]
00007e  2e21              CMP      r6,#0x21
000080  d823              BHI      |L8.202|
                  |L8.130|
;;;532        {
;;;533            u32Tmp = u32PllSrcClk / u32NR;
000082  4631              MOV      r1,r6
000084  9801              LDR      r0,[sp,#4]
000086  f7fffffe          BL       __aeabi_uidivmod
;;;534            if((u32Tmp > 1600000) && (u32Tmp < 15000000))
00008a  493f              LDR      r1,|L8.392|
00008c  4684              MOV      r12,r0                ;533
00008e  1841              ADDS     r1,r0,r1
000090  483e              LDR      r0,|L8.396|
000092  4281              CMP      r1,r0
000094  d216              BCS      |L8.196|
;;;535            {
;;;536                for(u32NF = 2; u32NF <= 513; u32NF++)
;;;537                {
;;;538                    u32Tmp2 = u32Tmp * u32NF;
;;;539                    if((u32Tmp2 >= 100000000) && (u32Tmp2 <= 200000000))
000096  4b3e              LDR      r3,|L8.400|
000098  2102              MOVS     r1,#2                 ;536
                  |L8.154|
00009a  4662              MOV      r2,r12                ;538
00009c  483d              LDR      r0,|L8.404|
00009e  434a              MULS     r2,r1,r2              ;538
0000a0  1810              ADDS     r0,r2,r0
0000a2  4298              CMP      r0,r3
0000a4  d80a              BHI      |L8.188|
;;;540                    {
;;;541                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
0000a6  42a2              CMP      r2,r4
0000a8  d901              BLS      |L8.174|
0000aa  1b10              SUBS     r0,r2,r4
0000ac  e000              B        |L8.176|
                  |L8.174|
0000ae  1aa0              SUBS     r0,r4,r2
                  |L8.176|
;;;542                        if(u32Tmp3 < u32Min)
0000b0  42a8              CMP      r0,r5
0000b2  d203              BCS      |L8.188|
;;;543                        {
;;;544                            u32Min = u32Tmp3;
0000b4  0005              MOVS     r5,r0
;;;545                            u32MinNR = u32NR;
;;;546                            u32MinNF = u32NF;
0000b6  460f              MOV      r7,r1
;;;547    
;;;548                            /* Break when get good results */
;;;549                            if(u32Min == 0)
0000b8  9603              STR      r6,[sp,#0xc]
0000ba  d003              BEQ      |L8.196|
                  |L8.188|
0000bc  4836              LDR      r0,|L8.408|
0000be  1c49              ADDS     r1,r1,#1              ;536
0000c0  4281              CMP      r1,r0                 ;536
0000c2  d9ea              BLS      |L8.154|
                  |L8.196|
0000c4  1c76              ADDS     r6,r6,#1              ;536
0000c6  2e21              CMP      r6,#0x21              ;531
0000c8  d9db              BLS      |L8.130|
                  |L8.202|
;;;550                                break;
;;;551                        }
;;;552                    }
;;;553                }
;;;554            }
;;;555        }
;;;556    
;;;557        /* Enable and apply new PLL setting. */
;;;558        CLK->PLLCON = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
0000ca  9802              LDR      r0,[sp,#8]
0000cc  9900              LDR      r1,[sp,#0]
0000ce  0380              LSLS     r0,r0,#14
0000d0  4308              ORRS     r0,r0,r1
0000d2  9903              LDR      r1,[sp,#0xc]
0000d4  2201              MOVS     r2,#1
0000d6  0249              LSLS     r1,r1,#9
0000d8  0292              LSLS     r2,r2,#10
0000da  1a89              SUBS     r1,r1,r2
0000dc  4308              ORRS     r0,r0,r1
0000de  1eb9              SUBS     r1,r7,#2
0000e0  4308              ORRS     r0,r0,r1
0000e2  4921              LDR      r1,|L8.360|
0000e4  6208              STR      r0,[r1,#0x20]
;;;559    
;;;560        /* Waiting for PLL clock stable */
;;;561        CLK_WaitClockReady(CLK_CLKSTATUS_PLL_STB_Msk);
0000e6  2004              MOVS     r0,#4
0000e8  f7fffffe          BL       CLK_WaitClockReady
;;;562    
;;;563        /* Return actual PLL output clock frequency */
;;;564        return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
0000ec  9902              LDR      r1,[sp,#8]
0000ee  9803              LDR      r0,[sp,#0xc]
0000f0  1c49              ADDS     r1,r1,#1
0000f2  4341              MULS     r1,r0,r1
0000f4  9801              LDR      r0,[sp,#4]
0000f6  f7fffffe          BL       __aeabi_uidivmod
0000fa  4378              MULS     r0,r7,r0
;;;565    
;;;566    lexit:
;;;567    
;;;568        /* Apply default PLL setting and return */
;;;569        if(u32PllClkSrc == CLK_PLLCON_PLL_SRC_HXT)
;;;570            CLK->PLLCON = 0xC22E; /* 48MHz */
;;;571        else
;;;572            CLK->PLLCON = 0x8D66F; /* 48.06498462MHz */
;;;573    
;;;574        CLK_WaitClockReady(CLK_CLKSTATUS_PLL_STB_Msk);
;;;575        return CLK_GetPLLClockFreq();
;;;576    
;;;577    }
0000fc  b005              ADD      sp,sp,#0x14
0000fe  bdf0              POP      {r4-r7,pc}
                  |L8.256|
000100  2f00              CMP      r7,#0                 ;569
000102  d010              BEQ      |L8.294|
000104  4818              LDR      r0,|L8.360|
000106  4925              LDR      r1,|L8.412|
000108  6201              STR      r1,[r0,#0x20]         ;572
                  |L8.266|
00010a  2004              MOVS     r0,#4                 ;574
00010c  f7fffffe          BL       CLK_WaitClockReady
000110  a023              ADR      r0,|L8.416|
000112  6800              LDR      r0,[r0,#0]            ;574
000114  9000              STR      r0,[sp,#0]            ;574
000116  4814              LDR      r0,|L8.360|
000118  6a01              LDR      r1,[r0,#0x20]         ;574
00011a  1300              ASRS     r0,r0,#12             ;574
00011c  4201              TST      r1,r0                 ;574
00011e  d006              BEQ      |L8.302|
000120  2000              MOVS     r0,#0                 ;574
000122  b005              ADD      sp,sp,#0x14
000124  bdf0              POP      {r4-r7,pc}
                  |L8.294|
000126  4810              LDR      r0,|L8.360|
000128  491e              LDR      r1,|L8.420|
00012a  6201              STR      r1,[r0,#0x20]         ;570
00012c  e7ed              B        |L8.266|
                  |L8.302|
00012e  0308              LSLS     r0,r1,#12             ;570
000130  d500              BPL      |L8.308|
000132  4d0f              LDR      r5,|L8.368|
                  |L8.308|
000134  0388              LSLS     r0,r1,#14             ;570
000136  d502              BPL      |L8.318|
000138  4628              MOV      r0,r5                 ;570
00013a  b005              ADD      sp,sp,#0x14
00013c  bdf0              POP      {r4-r7,pc}
                  |L8.318|
00013e  0408              LSLS     r0,r1,#16
000140  0f80              LSRS     r0,r0,#30
000142  466a              MOV      r2,sp
000144  5c10              LDRB     r0,[r2,r0]
000146  05ca              LSLS     r2,r1,#23
000148  0489              LSLS     r1,r1,#18
00014a  0ec9              LSRS     r1,r1,#27
00014c  1c89              ADDS     r1,r1,#2
00014e  0dd2              LSRS     r2,r2,#23
000150  4341              MULS     r1,r0,r1
000152  08a8              LSRS     r0,r5,#2
000154  1c92              ADDS     r2,r2,#2
000156  4350              MULS     r0,r2,r0
000158  f7fffffe          BL       __aeabi_uidivmod
00015c  0080              LSLS     r0,r0,#2
00015e  b005              ADD      sp,sp,#0x14
000160  bdf0              POP      {r4-r7,pc}
;;;578    
                          ENDP

000162  0000              DCW      0x0000
                  |L8.356|
                          DCD      0x00010000
                  |L8.360|
                          DCD      0x50000200
                  |L8.364|
                          DCD      0x00b71b00
                  |L8.368|
                          DCD      0x01518000
                  |L8.372|
                          DCD      0xfa0a1eff
                  |L8.376|
                          DCD      0x05f5e0ff
                  |L8.380|
                          DCD      0xfd050f7f
                  |L8.384|
                          DCD      0x02faf07f
                  |L8.388|
                          DCD      0xfe8287c0
                  |L8.392|
                          DCD      0xffe795ff
                  |L8.396|
                          DCD      0x00cc77bf
                  |L8.400|
                          DCD      0x05f5e100
                  |L8.404|
                          DCD      0xfa0a1f00
                  |L8.408|
                          DCD      0x00000201
                  |L8.412|
                          DCD      0x0008d66f
                  |L8.416|
0001a0  01020204          DCB      1,2,2,4
                  |L8.420|
                          DCD      0x0000c22e

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;627      */
;;;628    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count) 
000000  b470              PUSH     {r4-r6}
;;;629    {
;;;630        /* Set System Tick counter disabled */
;;;631        SysTick->CTRL = 0;    
000002  4a0c              LDR      r2,|L9.52|
000004  2400              MOVS     r4,#0
000006  6114              STR      r4,[r2,#0x10]
;;;632    
;;;633        /* Set System Tick clock source */
;;;634        if( u32ClkSrc == CLK_CLKSEL0_STCLK_S_HCLK )         
000008  2804              CMP      r0,#4
00000a  d00d              BEQ      |L9.40|
;;;635            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;636        else
;;;637            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLK_S_Msk) | u32ClkSrc; 
00000c  4d0a              LDR      r5,|L9.56|
00000e  692b              LDR      r3,[r5,#0x10]
000010  2638              MOVS     r6,#0x38
000012  43b3              BICS     r3,r3,r6
000014  4303              ORRS     r3,r3,r0
000016  612b              STR      r3,[r5,#0x10]
                  |L9.24|
;;;638    
;;;639        /* Set System Tick reload value */
;;;640        SysTick->LOAD = u32Count;   
000018  6151              STR      r1,[r2,#0x14]
;;;641        
;;;642        /* Clear System Tick current value and counter flag */
;;;643        SysTick->VAL = 0;           
00001a  6194              STR      r4,[r2,#0x18]
;;;644        
;;;645        /* Set System Tick interrupt enabled and counter enabled */    
;;;646        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;       
00001c  6910              LDR      r0,[r2,#0x10]
00001e  2103              MOVS     r1,#3
000020  4308              ORRS     r0,r0,r1
000022  6110              STR      r0,[r2,#0x10]
;;;647    }
000024  bc70              POP      {r4-r6}
000026  4770              BX       lr
                  |L9.40|
000028  6910              LDR      r0,[r2,#0x10]         ;635
00002a  2304              MOVS     r3,#4                 ;635
00002c  4318              ORRS     r0,r0,r3              ;635
00002e  6110              STR      r0,[r2,#0x10]         ;635
000030  e7f2              B        |L9.24|
;;;648    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      0xe000e000
                  |L9.56|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;363      */
;;;364    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L10.12|
;;;365    {
;;;366        CLK->PWRCON |= u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4302              ORRS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;367    }
000008  4770              BX       lr
;;;368    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x50000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;152      */
;;;153    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;154    {
;;;155        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;156        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;157    }
00000a  bd10              POP      {r4,pc}
;;;158    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;127      */
;;;128    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;131        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;132    }
00000a  bd10              POP      {r4,pc}
;;;133    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;112      */
;;;113    uint32_t CLK_GetHXTFreq(void)
000000  4802              LDR      r0,|L13.12|
;;;114    {
;;;115        if(CLK->PWRCON & CLK_PWRCON_XTL12M_EN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d000              BEQ      |L13.10|
;;;116            return __HXT;
000008  4801              LDR      r0,|L13.16|
                  |L13.10|
;;;117        else
;;;118            return 0;
;;;119    }
00000a  4770              BX       lr
;;;120    
                          ENDP

                  |L13.12|
                          DCD      0x50000200
                  |L13.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetPCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLKFreq PROC
;;;139      */
;;;140    uint32_t CLK_GetPCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;141    {
;;;142        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;143        return SystemCoreClock;
000006  4801              LDR      r0,|L14.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;144    }
00000a  bd10              POP      {r4,pc}
;;;145    
                          ENDP

                  |L14.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;94       */
;;;95     void CLK_Idle(void)
000000  4805              LDR      r0,|L15.24|
;;;96     {
;;;97         /* Set the processor uses sleep as its low power mode */    
;;;98         SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4391              BICS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;99         
;;;100        /* Set chip in idle mode because of WFI command */    
;;;101        CLK->PWRCON &= ~CLK_PWRCON_PWR_DOWN_EN_Msk;
00000a  4804              LDR      r0,|L15.28|
00000c  6801              LDR      r1,[r0,#0]
00000e  2280              MOVS     r2,#0x80
000010  4391              BICS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;102        
;;;103        /* Chip enter idle mode after CPU run WFI instruction */    
;;;104        __WFI();
000014  bf30              WFI      
;;;105    }
000016  4770              BX       lr
;;;106    
                          ENDP

                  |L15.24|
                          DCD      0xe000ed00
                  |L15.28|
                          DCD      0x50000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;75       */
;;;76     void CLK_PowerDown(void)
000000  4806              LDR      r0,|L16.28|
;;;77     {
;;;78         /* Set the processor uses deep sleep as its low power mode */    
;;;79         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;80         
;;;81         /* Set system Power-down enabled and Power-down entry condition */    
;;;82         CLK->PWRCON |= (CLK_PWRCON_PWR_DOWN_EN_Msk | CLK_PWRCON_PD_WAIT_CPU_Msk);
00000a  4805              LDR      r0,|L16.32|
00000c  6801              LDR      r1,[r0,#0]
00000e  22ff              MOVS     r2,#0xff
000010  3281              ADDS     r2,r2,#0x81
000012  4311              ORRS     r1,r1,r2
000014  6001              STR      r1,[r0,#0]
;;;83         
;;;84         /* Chip enter Power-down mode after CPU run WFI instruction */    
;;;85         __WFI();
000016  bf30              WFI      
;;;86     }
000018  4770              BX       lr
;;;87     
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      0xe000ed00
                  |L16.32|
                          DCD      0x50000200

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;166      */
;;;167    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b5f8              PUSH     {r3-r7,lr}
;;;168    {
;;;169        uint32_t u32HIRCSTB;
;;;170    
;;;171        /* Read HIRC clock source stable flag */    
;;;172        u32HIRCSTB = CLK->CLKSTATUS & CLK_CLKSTATUS_OSC22M_STB_Msk;        
000002  4d1b              LDR      r5,|L17.112|
000004  4604              MOV      r4,r0                 ;168
000006  68ee              LDR      r6,[r5,#0xc]
000008  2010              MOVS     r0,#0x10
00000a  4006              ANDS     r6,r6,r0
;;;173        
;;;174        /* The range of u32Hclk is 25 MHz ~ 50 MHz */    
;;;175        if(u32Hclk > FREQ_50MHZ)
00000c  4819              LDR      r0,|L17.116|
00000e  4284              CMP      r4,r0
000010  d802              BHI      |L17.24|
;;;176            u32Hclk = FREQ_50MHZ;
;;;177        else if(u32Hclk < FREQ_25MHZ)
000012  1040              ASRS     r0,r0,#1
000014  4284              CMP      r4,r0
000016  d200              BCS      |L17.26|
                  |L17.24|
;;;178            u32Hclk = FREQ_25MHZ;
000018  4604              MOV      r4,r0
                  |L17.26|
;;;179    
;;;180        /* Switch HCLK clock source to HIRC clock for safe */
;;;181        CLK->PWRCON |= CLK_PWRCON_OSC22M_EN_Msk;
00001a  6828              LDR      r0,[r5,#0]
00001c  2704              MOVS     r7,#4
00001e  4338              ORRS     r0,r0,r7
000020  6028              STR      r0,[r5,#0]
;;;182        CLK_WaitClockReady(CLK_CLKSTATUS_OSC22M_STB_Msk);  
000022  2010              MOVS     r0,#0x10
000024  f7fffffe          BL       CLK_WaitClockReady
;;;183        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLK_S_HIRC;
000028  6928              LDR      r0,[r5,#0x10]
00002a  2107              MOVS     r1,#7
00002c  4308              ORRS     r0,r0,r1
00002e  6128              STR      r0,[r5,#0x10]
;;;184        CLK->CLKDIV &= (~CLK_CLKDIV_HCLK_N_Msk);    
000030  69a8              LDR      r0,[r5,#0x18]
000032  0900              LSRS     r0,r0,#4
000034  0100              LSLS     r0,r0,#4
000036  61a8              STR      r0,[r5,#0x18]
;;;185        
;;;186        /* Configure PLL setting if HXT clock is stable */
;;;187        if(CLK->CLKSTATUS & CLK_CLKSTATUS_XTL12M_STB_Msk)
000038  68e8              LDR      r0,[r5,#0xc]
;;;188            u32Hclk = CLK_EnablePLL(CLK_PLLCON_PLL_SRC_HXT, u32Hclk);
;;;189    
;;;190        /* Configure PLL setting if HXT clock is not stable */    
;;;191        else
;;;192        {
;;;193            u32Hclk = CLK_EnablePLL(CLK_PLLCON_PLL_SRC_HIRC, u32Hclk);
00003a  4621              MOV      r1,r4
00003c  07c0              LSLS     r0,r0,#31             ;187
00003e  d004              BEQ      |L17.74|
000040  2000              MOVS     r0,#0                 ;188
000042  f7fffffe          BL       CLK_EnablePLL
000046  4604              MOV      r4,r0                 ;188
000048  e007              B        |L17.90|
                  |L17.74|
00004a  2001              MOVS     r0,#1
00004c  04c0              LSLS     r0,r0,#19
00004e  f7fffffe          BL       CLK_EnablePLL
;;;194            
;;;195            /* Read HIRC clock source stable flag */    
;;;196            u32HIRCSTB = CLK->CLKSTATUS & CLK_CLKSTATUS_OSC22M_STB_Msk;            
000052  68ee              LDR      r6,[r5,#0xc]
000054  4604              MOV      r4,r0                 ;193
000056  2010              MOVS     r0,#0x10
000058  4006              ANDS     r6,r6,r0
                  |L17.90|
;;;197        }
;;;198    
;;;199        /* Select HCLK clock source to PLL */    
;;;200        CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_PLL, CLK_CLKDIV_HCLK(1));
00005a  2100              MOVS     r1,#0
00005c  2002              MOVS     r0,#2
00005e  f7fffffe          BL       CLK_SetHCLK
;;;201    
;;;202        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;203        if( u32HIRCSTB == 0 )
000062  2e00              CMP      r6,#0
000064  d102              BNE      |L17.108|
;;;204            CLK->PWRCON &= ~CLK_PWRCON_OSC22M_EN_Msk;      
000066  6828              LDR      r0,[r5,#0]
000068  43b8              BICS     r0,r0,r7
00006a  6028              STR      r0,[r5,#0]
                  |L17.108|
;;;205        
;;;206        return u32Hclk;
00006c  4620              MOV      r0,r4
;;;207    }
00006e  bdf8              POP      {r3-r7,pc}
;;;208    
                          ENDP

                  |L17.112|
                          DCD      0x50000200
                  |L17.116|
                          DCD      0x02faf080

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;221      */
;;;222    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;223    {
;;;224        uint32_t u32HIRCSTB;
;;;225        
;;;226        /* Read HIRC clock source stable flag */    
;;;227        u32HIRCSTB = CLK->CLKSTATUS & CLK_CLKSTATUS_OSC22M_STB_Msk;
000002  4c12              LDR      r4,|L18.76|
000004  b081              SUB      sp,sp,#4              ;223
000006  68e5              LDR      r5,[r4,#0xc]
000008  460f              MOV      r7,r1                 ;223
00000a  2010              MOVS     r0,#0x10
00000c  4005              ANDS     r5,r5,r0
;;;228        
;;;229        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;230        CLK->PWRCON |= CLK_PWRCON_OSC22M_EN_Msk;
00000e  6820              LDR      r0,[r4,#0]
000010  2604              MOVS     r6,#4
000012  4330              ORRS     r0,r0,r6
000014  6020              STR      r0,[r4,#0]
;;;231        CLK_WaitClockReady(CLK_CLKSTATUS_OSC22M_STB_Msk);  
000016  2010              MOVS     r0,#0x10
000018  f7fffffe          BL       CLK_WaitClockReady
;;;232        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLK_S_Msk)) | CLK_CLKSEL0_HCLK_S_HIRC;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  2107              MOVS     r1,#7
000020  4308              ORRS     r0,r0,r1
000022  6120              STR      r0,[r4,#0x10]
;;;233          
;;;234        /* Apply new Divider */
;;;235        CLK->CLKDIV = (CLK->CLKDIV & (~CLK_CLKDIV_HCLK_N_Msk)) | u32ClkDiv;
000024  69a0              LDR      r0,[r4,#0x18]
000026  0900              LSRS     r0,r0,#4
000028  0100              LSLS     r0,r0,#4
00002a  4338              ORRS     r0,r0,r7
00002c  61a0              STR      r0,[r4,#0x18]
;;;236    
;;;237        /* Switch HCLK to new HCLK source */
;;;238        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLK_S_Msk)) | u32ClkSrc;    
00002e  6920              LDR      r0,[r4,#0x10]
000030  4388              BICS     r0,r0,r1
000032  9901              LDR      r1,[sp,#4]
000034  4308              ORRS     r0,r0,r1
000036  6120              STR      r0,[r4,#0x10]
;;;239            
;;;240        /* Update System Core Clock */
;;;241        SystemCoreClockUpdate();
000038  f7fffffe          BL       SystemCoreClockUpdate
;;;242        
;;;243        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;244        if( u32HIRCSTB == 0 )
00003c  2d00              CMP      r5,#0
00003e  d102              BNE      |L18.70|
;;;245            CLK->PWRCON &= ~CLK_PWRCON_OSC22M_EN_Msk;              
000040  6820              LDR      r0,[r4,#0]
000042  43b0              BICS     r0,r0,r6
000044  6020              STR      r0,[r4,#0]
                  |L18.70|
;;;246    }
000046  b003              ADD      sp,sp,#0xc
000048  bdf0              POP      {r4-r7,pc}
;;;247    
                          ENDP

00004a  0000              DCW      0x0000
                  |L18.76|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;316      */
;;;317    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b470              PUSH     {r4-r6}
;;;318    {
;;;319        uint32_t u32tmp = 0, u32sel = 0, u32div = 0;
;;;320    
;;;321        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000002  0e43              LSRS     r3,r0,#25
000004  075b              LSLS     r3,r3,#29
000006  d00d              BEQ      |L19.36|
;;;322        {
;;;323            u32sel = (uint32_t)&CLK->CLKSEL0 + ((MODULE_CLKSEL(u32ModuleIdx)) * 4);
000008  0083              LSLS     r3,r0,#2
00000a  0f9b              LSRS     r3,r3,#30
00000c  4c0f              LDR      r4,|L19.76|
00000e  009b              LSLS     r3,r3,#2
000010  191b              ADDS     r3,r3,r4
;;;324            u32tmp = *(volatile uint32_t *)(u32sel);
000012  681c              LDR      r4,[r3,#0]
;;;325            u32tmp = (u32tmp & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000014  0105              LSLS     r5,r0,#4
000016  0f6d              LSRS     r5,r5,#29
000018  01c6              LSLS     r6,r0,#7
00001a  0ef6              LSRS     r6,r6,#27
00001c  40b5              LSLS     r5,r5,r6
00001e  43ac              BICS     r4,r4,r5
000020  430c              ORRS     r4,r4,r1
;;;326            *(volatile uint32_t *)(u32sel) = u32tmp;
000022  601c              STR      r4,[r3,#0]
                  |L19.36|
;;;327        }
;;;328    
;;;329        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000024  0a83              LSRS     r3,r0,#10
000026  0619              LSLS     r1,r3,#24
000028  0e09              LSRS     r1,r1,#24
00002a  d00c              BEQ      |L19.70|
;;;330        {
;;;331            u32div = (uint32_t)&CLK->CLKDIV + ((MODULE_CLKDIV(u32ModuleIdx)) * 4);
00002c  0301              LSLS     r1,r0,#12
00002e  0f89              LSRS     r1,r1,#30
000030  4c07              LDR      r4,|L19.80|
000032  0089              LSLS     r1,r1,#2
000034  1909              ADDS     r1,r1,r4
;;;332            u32tmp = *(volatile uint32_t *)(u32div);
000036  680c              LDR      r4,[r1,#0]
;;;333            u32tmp = (u32tmp & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
000038  0580              LSLS     r0,r0,#22
00003a  b2db              UXTB     r3,r3
00003c  0ec0              LSRS     r0,r0,#27
00003e  4083              LSLS     r3,r3,r0
000040  439c              BICS     r4,r4,r3
000042  4314              ORRS     r4,r4,r2
;;;334            *(volatile uint32_t *)(u32div) = u32tmp;
000044  600c              STR      r4,[r1,#0]
                  |L19.70|
;;;335        }
;;;336    }
000046  bc70              POP      {r4-r6}
000048  4770              BX       lr
;;;337    
                          ENDP

00004a  0000              DCW      0x0000
                  |L19.76|
                          DCD      0x50000210
                  |L19.80|
                          DCD      0x50000218

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;348      */
;;;349    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4a03              LDR      r2,|L20.16|
;;;350    {
;;;351        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLK_S_Msk) | u32ClkSrc;
000002  6911              LDR      r1,[r2,#0x10]
000004  2338              MOVS     r3,#0x38
000006  4399              BICS     r1,r1,r3
000008  4301              ORRS     r1,r1,r0
00000a  6111              STR      r1,[r2,#0x10]
;;;352    }
00000c  4770              BX       lr
;;;353    
                          ENDP

00000e  0000              DCW      0x0000
                  |L20.16|
                          DCD      0x50000200

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;601      */
;;;602    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b410              PUSH     {r4}
;;;603    {
;;;604        int32_t i32TimeOutCnt = 1200000;   
;;;605    
;;;606        while((CLK->CLKSTATUS & u32ClkMask) != u32ClkMask)
000002  4a0b              LDR      r2,|L21.48|
000004  4909              LDR      r1,|L21.44|
000006  68d3              LDR      r3,[r2,#0xc]
000008  4604              MOV      r4,r0                 ;603
00000a  4398              BICS     r0,r0,r3
00000c  d00a              BEQ      |L21.36|
                  |L21.14|
;;;607        {
;;;608            if(i32TimeOutCnt-- <= 0)
00000e  460b              MOV      r3,r1
000010  1e49              SUBS     r1,r1,#1
000012  2b00              CMP      r3,#0
000014  dc02              BGT      |L21.28|
;;;609                return 0;
;;;610        }
;;;611    
;;;612        return 1;
;;;613    }
000016  bc10              POP      {r4}
000018  2000              MOVS     r0,#0                 ;609
00001a  4770              BX       lr
                  |L21.28|
00001c  68d3              LDR      r3,[r2,#0xc]          ;606
00001e  4620              MOV      r0,r4                 ;606
000020  4398              BICS     r0,r0,r3              ;606
000022  d1f4              BNE      |L21.14|
                  |L21.36|
000024  bc10              POP      {r4}
000026  2001              MOVS     r0,#1                 ;612
000028  4770              BX       lr
;;;614    
                          ENDP

00002a  0000              DCW      0x0000
                  |L21.44|
                          DCD      0x00124f80
                  |L21.48|
                          DCD      0x50000200

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 132
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
