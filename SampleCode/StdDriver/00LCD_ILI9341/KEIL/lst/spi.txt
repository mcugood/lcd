; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\spi.d --cpu=Cortex-M0 --apcs=interwork -Otime --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\M051Series\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\spi.crf ..\..\..\..\Library\StdDriver\src\spi.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;201      */
;;;202    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;203    {
;;;204        uint32_t u32PllFreq = 0, u32PllReg;
;;;205        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;206        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;207    
;;;208        u32PllReg = CLK->PLLCON;
000006  9000              STR      r0,[sp,#0]
000008  4810              LDR      r0,|L1.76|
00000a  6a01              LDR      r1,[r0,#0x20]
;;;209    
;;;210        if(u32PllReg & (CLK_PLLCON_PD_Msk | CLK_PLLCON_OE_Msk))
00000c  1300              ASRS     r0,r0,#12
00000e  4201              TST      r1,r0
000010  d001              BEQ      |L1.22|
;;;211            return 0;           /* PLL is in power down mode or fix low */
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;212    
;;;213        if(u32PllReg & CLK_PLLCON_PLL_SRC_HIRC)
;;;214            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;215        else
;;;216            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;217    
;;;218        if(u32PllReg & CLK_PLLCON_BP_Msk)
;;;219            return u32FIN;      /* PLL is in bypass mode */
;;;220    
;;;221        /* PLL is output enabled in normal work mode */
;;;222        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCON_OUT_DV_Msk) >> CLK_PLLCON_OUT_DV_Pos)];
;;;223        u32NF = ((u32PllReg & CLK_PLLCON_FB_DV_Msk) >> CLK_PLLCON_FB_DV_Pos) + 2;
;;;224        u32NR = ((u32PllReg & CLK_PLLCON_IN_DV_Msk) >> CLK_PLLCON_IN_DV_Pos) + 2;
;;;225    
;;;226        /* u32FIN is shifted 2 bits to avoid overflow */
;;;227        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;228    
;;;229        return u32PllFreq;
;;;230    }
000014  bd08              POP      {r3,pc}
                  |L1.22|
000016  0308              LSLS     r0,r1,#12             ;213
000018  d501              BPL      |L1.30|
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
000020  038a              LSLS     r2,r1,#14             ;218
000022  d4f7              BMI      |L1.20|
000024  040a              LSLS     r2,r1,#16             ;222
000026  0f92              LSRS     r2,r2,#30             ;222
000028  466b              MOV      r3,sp                 ;222
00002a  5c9b              LDRB     r3,[r3,r2]            ;222
00002c  05ca              LSLS     r2,r1,#23             ;223
00002e  0489              LSLS     r1,r1,#18             ;224
000030  0dd2              LSRS     r2,r2,#23             ;223
000032  0ec9              LSRS     r1,r1,#27             ;224
000034  1c89              ADDS     r1,r1,#2              ;224
000036  0880              LSRS     r0,r0,#2              ;227
000038  1c92              ADDS     r2,r2,#2              ;227
00003a  4359              MULS     r1,r3,r1              ;227
00003c  4350              MULS     r0,r2,r0              ;227
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2              ;227
000044  bd08              POP      {r3,pc}
;;;231    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x50000200
                  |L1.80|
                          DCD      0x01518000
                  |L1.84|
                          DCD      0x00b71b00

                          AREA ||i.SPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_ClearIntFlag PROC
;;;610      */
;;;611    void SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;612    {
000002  d004              BEQ      |L2.14|
;;;613        if(u32Mask & SPI_UNIT_INT_MASK)
;;;614            spi->CNTRL |= SPI_CNTRL_IF_Msk; /* Clear unit transfer interrupt flag */
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  041b              LSLS     r3,r3,#16
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L2.14|
;;;615    
;;;616        if(u32Mask & SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L2.28|
;;;617            spi->CNTRL2 |= SPI_CNTRL2_SLV_START_INTSTS_Msk; /* Clear slave 3-wire mode start interrupt flag */
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  02db              LSLS     r3,r3,#11
000018  431a              ORRS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L2.28|
;;;618    
;;;619        /* M05xxBN does not support the following functions */
;;;620        
;;;621        if(u32Mask & SPI_FIFO_RXOV_INT_MASK)
00001c  06ca              LSLS     r2,r1,#27
00001e  d501              BPL      |L2.36|
;;;622            spi->STATUS = SPI_STATUS_RX_OVERRUN_Msk; /* Clear RX overrun interrupt flag */
000020  2204              MOVS     r2,#4
000022  6442              STR      r2,[r0,#0x44]
                  |L2.36|
;;;623    
;;;624        if(u32Mask & SPI_FIFO_TIMEOUT_INT_MASK)
000024  0689              LSLS     r1,r1,#26
000026  d502              BPL      |L2.46|
;;;625            spi->STATUS = SPI_STATUS_TIMEOUT_Msk; /* Clear RX time-out interrupt flag */
000028  2101              MOVS     r1,#1
00002a  0509              LSLS     r1,r1,#20
00002c  6441              STR      r1,[r0,#0x44]
                  |L2.46|
;;;626    }
00002e  4770              BX       lr
;;;627    
                          ENDP


                          AREA ||i.SPI_ClearRxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearRxFIFO PROC
;;;224      */
;;;225    void SPI_ClearRxFIFO(SPI_T *spi)
000000  6c01              LDR      r1,[r0,#0x40]
;;;226    {
;;;227        spi->FIFO_CTL |= SPI_FIFO_CTL_RX_CLR_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6401              STR      r1,[r0,#0x40]
;;;228    }
000008  4770              BX       lr
;;;229    
                          ENDP


                          AREA ||i.SPI_ClearTxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearTxFIFO PROC
;;;235      */
;;;236    void SPI_ClearTxFIFO(SPI_T *spi)
000000  6c01              LDR      r1,[r0,#0x40]
;;;237    {
;;;238        spi->FIFO_CTL |= SPI_FIFO_CTL_TX_CLR_Msk;
000002  2202              MOVS     r2,#2
000004  4311              ORRS     r1,r1,r2
000006  6401              STR      r1,[r0,#0x40]
;;;239    }
000008  4770              BX       lr
;;;240    
                          ENDP


                          AREA ||i.SPI_Close||, CODE, READONLY, ALIGN=2

                  SPI_Close PROC
;;;202      */
;;;203    void SPI_Close(SPI_T *spi)
000000  4a0a              LDR      r2,|L5.44|
;;;204    {
;;;205        if(spi == SPI0)
;;;206        {
;;;207            /* Reset SPI */
;;;208            SYS->IPRSTC2 |= SYS_IPRSTC2_SPI0_RST_Msk;
000002  2105              MOVS     r1,#5
000004  0709              LSLS     r1,r1,#28
000006  4290              CMP      r0,r2                 ;205
;;;209            SYS->IPRSTC2 &= ~SYS_IPRSTC2_SPI0_RST_Msk;
;;;210        }
;;;211        else
;;;212        {
;;;213            /* Reset SPI */
;;;214            SYS->IPRSTC2 |= SYS_IPRSTC2_SPI1_RST_Msk;
000008  68ca              LDR      r2,[r1,#0xc]
00000a  d106              BNE      |L5.26|
00000c  1480              ASRS     r0,r0,#18             ;208
00000e  4302              ORRS     r2,r2,r0              ;208
000010  60ca              STR      r2,[r1,#0xc]          ;208
000012  68ca              LDR      r2,[r1,#0xc]          ;209
000014  4382              BICS     r2,r2,r0              ;209
000016  60ca              STR      r2,[r1,#0xc]          ;209
;;;215            SYS->IPRSTC2 &= ~SYS_IPRSTC2_SPI1_RST_Msk;
;;;216        }
;;;217    }
000018  4770              BX       lr
                  |L5.26|
00001a  2001              MOVS     r0,#1                 ;214
00001c  0340              LSLS     r0,r0,#13             ;214
00001e  4302              ORRS     r2,r2,r0              ;214
000020  60ca              STR      r2,[r1,#0xc]          ;214
000022  68ca              LDR      r2,[r1,#0xc]          ;215
000024  4382              BICS     r2,r2,r0              ;215
000026  60ca              STR      r2,[r1,#0xc]          ;215
000028  4770              BX       lr
;;;218    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      0x40030000

                          AREA ||i.SPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_DisableAutoSS PROC
;;;246      */
;;;247    void SPI_DisableAutoSS(SPI_T *spi)
000000  6881              LDR      r1,[r0,#8]
;;;248    {
;;;249        spi->SSR &= ~(SPI_SSR_AUTOSS_Msk | SPI_SSR_SSR_Msk);
000002  2209              MOVS     r2,#9
000004  4391              BICS     r1,r1,r2
000006  6081              STR      r1,[r0,#8]
;;;250    }
000008  4770              BX       lr
;;;251    
                          ENDP


                          AREA ||i.SPI_DisableFIFO||, CODE, READONLY, ALIGN=1

                  SPI_DisableFIFO PROC
;;;405      */
;;;406    void SPI_DisableFIFO(SPI_T *spi)
000000  6801              LDR      r1,[r0,#0]
;;;407    {
;;;408        spi->CNTRL &= ~SPI_CNTRL_FIFO_Msk;
000002  2201              MOVS     r2,#1
000004  0552              LSLS     r2,r2,#21
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;409    }
00000a  4770              BX       lr
;;;410    
                          ENDP


                          AREA ||i.SPI_DisableInt||, CODE, READONLY, ALIGN=1

                  SPI_DisableInt PROC
;;;524      */
;;;525    void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;526    {
000002  d004              BEQ      |L8.14|
;;;527        /* Disable unit transfer interrupt flag */
;;;528        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;529            spi->CNTRL &= ~SPI_CNTRL_IE_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L8.14|
;;;530    
;;;531        /* Disable slave 3-wire mode start interrupt flag */
;;;532        if((u32Mask & SPI_SSTA_INT_MASK) == SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L8.28|
;;;533            spi->CNTRL2 &= ~SPI_CNTRL2_SSTA_INTEN_Msk;
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
000018  439a              BICS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L8.28|
;;;534    
;;;535        /* M05xxBN does not support the following functions */
;;;536        
;;;537        /* Disable TX threshold interrupt flag */
;;;538        if((u32Mask & SPI_FIFO_TX_INT_MASK) == SPI_FIFO_TX_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
00001e  d503              BPL      |L8.40|
;;;539            spi->FIFO_CTL &= ~SPI_FIFO_CTL_TX_INTEN_Msk;
000020  6c02              LDR      r2,[r0,#0x40]
000022  2308              MOVS     r3,#8
000024  439a              BICS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L8.40|
;;;540    
;;;541        /* Disable RX threshold interrupt flag */
;;;542        if((u32Mask & SPI_FIFO_RX_INT_MASK) == SPI_FIFO_RX_INT_MASK)
000028  070a              LSLS     r2,r1,#28
00002a  d503              BPL      |L8.52|
;;;543            spi->FIFO_CTL &= ~SPI_FIFO_CTL_RX_INTEN_Msk;
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
000030  439a              BICS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L8.52|
;;;544    
;;;545        /* Disable RX overrun interrupt flag */
;;;546        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000034  06ca              LSLS     r2,r1,#27
000036  d503              BPL      |L8.64|
;;;547            spi->FIFO_CTL &= ~SPI_FIFO_CTL_RXOV_INTEN_Msk;
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  439a              BICS     r2,r2,r3
00003e  6402              STR      r2,[r0,#0x40]
                  |L8.64|
;;;548    
;;;549        /* Disable RX time-out interrupt flag */
;;;550        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) == SPI_FIFO_TIMEOUT_INT_MASK)
000040  0689              LSLS     r1,r1,#26
000042  d504              BPL      |L8.78|
;;;551            spi->FIFO_CTL &= ~SPI_FIFO_CTL_TIMEOUT_INTEN_Msk;
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
00004a  4391              BICS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]
                  |L8.78|
;;;552    }
00004e  4770              BX       lr
;;;553    
                          ENDP


                          AREA ||i.SPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_EnableAutoSS PROC
;;;260      */
;;;261    void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  b410              PUSH     {r4}
;;;262    {
;;;263        spi->SSR = (spi->SSR & (~(SPI_SSR_AUTOSS_Msk | SPI_SSR_SS_LVL_Msk | SPI_SSR_SSR_Msk))) | (u32SSPinMask | u32ActiveLevel | SPI_SSR_AUTOSS_Msk);
000002  6883              LDR      r3,[r0,#8]
000004  240d              MOVS     r4,#0xd
000006  43a3              BICS     r3,r3,r4
000008  4311              ORRS     r1,r1,r2
00000a  430b              ORRS     r3,r3,r1
00000c  2108              MOVS     r1,#8
00000e  430b              ORRS     r3,r3,r1
000010  6083              STR      r3,[r0,#8]
;;;264    }
000012  bc10              POP      {r4}
000014  4770              BX       lr
;;;265    
                          ENDP


                          AREA ||i.SPI_EnableFIFO||, CODE, READONLY, ALIGN=1

                  SPI_EnableFIFO PROC
;;;390      */
;;;391    void SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  b410              PUSH     {r4}
;;;392    {
;;;393        spi->FIFO_CTL = (spi->FIFO_CTL & ~(SPI_FIFO_CTL_TX_THRESHOLD_Msk | SPI_FIFO_CTL_RX_THRESHOLD_Msk)) |
000002  6c03              LDR      r3,[r0,#0x40]
000004  2433              MOVS     r4,#0x33
000006  0624              LSLS     r4,r4,#24
000008  43a3              BICS     r3,r3,r4
00000a  0709              LSLS     r1,r1,#28
00000c  430b              ORRS     r3,r3,r1
00000e  0611              LSLS     r1,r2,#24
000010  430b              ORRS     r3,r3,r1
000012  6403              STR      r3,[r0,#0x40]
;;;394                         (u32TxThreshold << SPI_FIFO_CTL_TX_THRESHOLD_Pos) |
;;;395                         (u32RxThreshold << SPI_FIFO_CTL_RX_THRESHOLD_Pos);
;;;396    
;;;397        spi->CNTRL |= SPI_CNTRL_FIFO_Msk;
000014  6801              LDR      r1,[r0,#0]
000016  2201              MOVS     r2,#1
000018  0552              LSLS     r2,r2,#21
00001a  4311              ORRS     r1,r1,r2
00001c  6001              STR      r1,[r0,#0]
;;;398    }
00001e  bc10              POP      {r4}
000020  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.SPI_EnableInt||, CODE, READONLY, ALIGN=1

                  SPI_EnableInt PROC
;;;483      */
;;;484    void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;485    {
000002  d004              BEQ      |L11.14|
;;;486        /* Enable unit transfer interrupt flag */
;;;487        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;488            spi->CNTRL |= SPI_CNTRL_IE_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L11.14|
;;;489    
;;;490        /* Enable slave 3-wire mode start interrupt flag */
;;;491        if((u32Mask & SPI_SSTA_INT_MASK) == SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L11.28|
;;;492            spi->CNTRL2 |= SPI_CNTRL2_SSTA_INTEN_Msk;
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
000018  431a              ORRS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L11.28|
;;;493    
;;;494        /* M05xxBN does not support the following functions */
;;;495        
;;;496        /* Enable TX threshold interrupt flag */
;;;497        if((u32Mask & SPI_FIFO_TX_INT_MASK) == SPI_FIFO_TX_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
00001e  d503              BPL      |L11.40|
;;;498            spi->FIFO_CTL |= SPI_FIFO_CTL_TX_INTEN_Msk;
000020  6c02              LDR      r2,[r0,#0x40]
000022  2308              MOVS     r3,#8
000024  431a              ORRS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L11.40|
;;;499    
;;;500        /* Enable RX threshold interrupt flag */
;;;501        if((u32Mask & SPI_FIFO_RX_INT_MASK) == SPI_FIFO_RX_INT_MASK)
000028  070a              LSLS     r2,r1,#28
00002a  d503              BPL      |L11.52|
;;;502            spi->FIFO_CTL |= SPI_FIFO_CTL_RX_INTEN_Msk;
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
000030  431a              ORRS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L11.52|
;;;503    
;;;504        /* Enable RX overrun interrupt flag */
;;;505        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000034  06ca              LSLS     r2,r1,#27
000036  d503              BPL      |L11.64|
;;;506            spi->FIFO_CTL |= SPI_FIFO_CTL_RXOV_INTEN_Msk;
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  431a              ORRS     r2,r2,r3
00003e  6402              STR      r2,[r0,#0x40]
                  |L11.64|
;;;507    
;;;508        /* Enable RX time-out interrupt flag */
;;;509        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) == SPI_FIFO_TIMEOUT_INT_MASK)
000040  0689              LSLS     r1,r1,#26
000042  d504              BPL      |L11.78|
;;;510            spi->FIFO_CTL |= SPI_FIFO_CTL_TIMEOUT_INTEN_Msk;
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
00004a  4311              ORRS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]
                  |L11.78|
;;;511    }
00004e  4770              BX       lr
;;;512    
                          ENDP


                          AREA ||i.SPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_GetBusClock PROC
;;;416      */
;;;417    uint32_t SPI_GetBusClock(SPI_T *spi)
000000  b570              PUSH     {r4-r6,lr}
;;;418    {
;;;419        uint32_t u32Div;
;;;420        uint32_t u32ClkSrc;
;;;421    
;;;422        if(((SYS->PDID & 0xF0000000) == 0) || ((SYS->PDID & 0xF0000000) == 0x10000000)) /* For M05xxAN and M05xxBN, the SPI peripheral clock source is PCLK. */
000002  2505              MOVS     r5,#5
000004  4604              MOV      r4,r0                 ;418
000006  072d              LSLS     r5,r5,#28
000008  6828              LDR      r0,[r5,#0]
00000a  0f00              LSRS     r0,r0,#28
00000c  d00d              BEQ      |L12.42|
00000e  6828              LDR      r0,[r5,#0]
000010  0f00              LSRS     r0,r0,#28
000012  2801              CMP      r0,#1
000014  d009              BEQ      |L12.42|
;;;423        {
;;;424            /* Get the system clock rate */
;;;425            u32ClkSrc = CLK_GetHCLKFreq();
;;;426    
;;;427            if(((SYS->PDID & 0xF0000000) == 0x10000000) && (spi->CNTRL2 & SPI_CNTRL2_DIV_ONE_Msk))
;;;428            {
;;;429                /* SPI bus clock rate is equal to system clock rate */
;;;430                return u32ClkSrc;
;;;431            }
;;;432    
;;;433            /* Get DIVIDER setting */
;;;434            u32Div = (spi->DIVIDER & SPI_DIVIDER_DIVIDER_Msk) >> SPI_DIVIDER_DIVIDER_Pos;
;;;435            /* Return SPI bus clock rate */
;;;436            return (u32ClkSrc / ((u32Div + 1) * 2));
;;;437        }
;;;438        else /* M05xxDN or M05xxDE */
;;;439        {
;;;440            /* Get DIVIDER setting */
;;;441            u32Div = (spi->DIVIDER & SPI_DIVIDER_DIVIDER_Msk) >> SPI_DIVIDER_DIVIDER_Pos;
000016  6860              LDR      r0,[r4,#4]
;;;442    
;;;443            /* Check clock source of SPI */
;;;444            if(spi == SPI0)
000018  4916              LDR      r1,|L12.116|
00001a  b285              UXTH     r5,r0                 ;441
;;;445            {
;;;446                if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
00001c  4816              LDR      r0,|L12.120|
00001e  428c              CMP      r4,r1                 ;444
;;;447                    u32ClkSrc = CLK_GetHCLKFreq();
;;;448                else
;;;449                    u32ClkSrc = CLK_GetPLLClockFreq();
;;;450            }
;;;451            else
;;;452            {
;;;453                if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI1_S_Msk) == CLK_CLKSEL1_SPI1_S_HCLK)
000020  6940              LDR      r0,[r0,#0x14]
000022  d116              BNE      |L12.82|
000024  06c0              LSLS     r0,r0,#27             ;446
000026  d416              BMI      |L12.86|
000028  e018              B        |L12.92|
                  |L12.42|
00002a  f7fffffe          BL       CLK_GetHCLKFreq
00002e  4602              MOV      r2,r0                 ;425
000030  6828              LDR      r0,[r5,#0]            ;427
000032  0f00              LSRS     r0,r0,#28             ;427
000034  2801              CMP      r0,#1                 ;427
000036  d104              BNE      |L12.66|
000038  6be0              LDR      r0,[r4,#0x3c]         ;427
00003a  07c0              LSLS     r0,r0,#31             ;427
00003c  d001              BEQ      |L12.66|
00003e  4610              MOV      r0,r2                 ;430
;;;454                    u32ClkSrc = CLK_GetHCLKFreq();
;;;455                else
;;;456                    u32ClkSrc = CLK_GetPLLClockFreq();
;;;457            }
;;;458    
;;;459            if(spi->CNTRL2 & SPI_CNTRL2_BCn_Msk)   /* BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;460            {
;;;461                /* Return SPI bus clock rate */
;;;462                return (u32ClkSrc / (u32Div + 1));
;;;463            }
;;;464            else /* BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;465            {
;;;466                /* Return SPI bus clock rate */
;;;467                return (u32ClkSrc / ((u32Div + 1) * 2));
;;;468            }
;;;469        }
;;;470    }
000040  bd70              POP      {r4-r6,pc}
                  |L12.66|
000042  6860              LDR      r0,[r4,#4]            ;434
000044  0400              LSLS     r0,r0,#16             ;434
000046  0bc1              LSRS     r1,r0,#15             ;436
000048  4610              MOV      r0,r2                 ;436
00004a  1c89              ADDS     r1,r1,#2              ;436
00004c  f7fffffe          BL       __aeabi_uidivmod
000050  bd70              POP      {r4-r6,pc}
                  |L12.82|
000052  0680              LSLS     r0,r0,#26             ;453
000054  d502              BPL      |L12.92|
                  |L12.86|
000056  f7fffffe          BL       CLK_GetHCLKFreq
00005a  e001              B        |L12.96|
                  |L12.92|
00005c  f7fffffe          BL       CLK_GetPLLClockFreq
                  |L12.96|
000060  6be1              LDR      r1,[r4,#0x3c]         ;459
000062  2900              CMP      r1,#0                 ;459
000064  da01              BGE      |L12.106|
000066  1c69              ADDS     r1,r5,#1              ;462
000068  e001              B        |L12.110|
                  |L12.106|
00006a  0069              LSLS     r1,r5,#1              ;467
00006c  1c89              ADDS     r1,r1,#2              ;467
                  |L12.110|
00006e  f7fffffe          BL       __aeabi_uidivmod
000072  bd70              POP      {r4-r6,pc}
;;;471    
                          ENDP

                  |L12.116|
                          DCD      0x40030000
                  |L12.120|
                          DCD      0x50000200

                          AREA ||i.SPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_GetIntFlag PROC
;;;565      */
;;;566    uint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;567    {
;;;568        uint32_t u32IntFlag = 0;
000002  2000              MOVS     r0,#0
;;;569    
;;;570        /* Check unit transfer interrupt flag */
;;;571        if((u32Mask & SPI_UNIT_INT_MASK) && (spi->CNTRL & SPI_CNTRL_IF_Msk))
000004  07cb              LSLS     r3,r1,#31
000006  d003              BEQ      |L13.16|
000008  6813              LDR      r3,[r2,#0]
00000a  03db              LSLS     r3,r3,#15
00000c  d500              BPL      |L13.16|
;;;572            u32IntFlag |= SPI_UNIT_INT_MASK;
00000e  2001              MOVS     r0,#1
                  |L13.16|
;;;573    
;;;574        /* Check slave 3-wire mode start interrupt flag */
;;;575        if((u32Mask & SPI_SSTA_INT_MASK) && (spi->CNTRL2 & SPI_CNTRL2_SLV_START_INTSTS_Msk))
000010  078b              LSLS     r3,r1,#30
000012  d504              BPL      |L13.30|
000014  6bd3              LDR      r3,[r2,#0x3c]
000016  051b              LSLS     r3,r3,#20
000018  d501              BPL      |L13.30|
;;;576            u32IntFlag |= SPI_SSTA_INT_MASK;
00001a  2302              MOVS     r3,#2
00001c  4318              ORRS     r0,r0,r3
                  |L13.30|
;;;577    
;;;578        /* M05xxBN does not support the following functions */
;;;579        
;;;580        /* Check TX threshold interrupt flag */
;;;581        if((u32Mask & SPI_FIFO_TX_INT_MASK) && (spi->STATUS & SPI_STATUS_TX_INTSTS_Msk))
00001e  074b              LSLS     r3,r1,#29
000020  d504              BPL      |L13.44|
000022  6c53              LDR      r3,[r2,#0x44]
000024  06db              LSLS     r3,r3,#27
000026  d501              BPL      |L13.44|
;;;582            u32IntFlag |= SPI_FIFO_TX_INT_MASK;
000028  2304              MOVS     r3,#4
00002a  4318              ORRS     r0,r0,r3
                  |L13.44|
;;;583    
;;;584        /* Check RX threshold interrupt flag */
;;;585        if((u32Mask & SPI_FIFO_RX_INT_MASK) && (spi->STATUS & SPI_STATUS_RX_INTSTS_Msk))
00002c  070b              LSLS     r3,r1,#28
00002e  d504              BPL      |L13.58|
000030  6c53              LDR      r3,[r2,#0x44]
000032  07db              LSLS     r3,r3,#31
000034  d001              BEQ      |L13.58|
;;;586            u32IntFlag |= SPI_FIFO_RX_INT_MASK;
000036  2308              MOVS     r3,#8
000038  4318              ORRS     r0,r0,r3
                  |L13.58|
;;;587    
;;;588        /* Check RX overrun interrupt flag */
;;;589        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) && (spi->STATUS & SPI_STATUS_RX_OVERRUN_Msk))
00003a  06cb              LSLS     r3,r1,#27
00003c  d504              BPL      |L13.72|
00003e  6c53              LDR      r3,[r2,#0x44]
000040  075b              LSLS     r3,r3,#29
000042  d501              BPL      |L13.72|
;;;590            u32IntFlag |= SPI_FIFO_RXOV_INT_MASK;
000044  2310              MOVS     r3,#0x10
000046  4318              ORRS     r0,r0,r3
                  |L13.72|
;;;591    
;;;592        /* Check RX time-out interrupt flag */
;;;593        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) && (spi->STATUS & SPI_STATUS_TIMEOUT_Msk))
000048  0689              LSLS     r1,r1,#26
00004a  d504              BPL      |L13.86|
00004c  6c51              LDR      r1,[r2,#0x44]
00004e  02c9              LSLS     r1,r1,#11
000050  d501              BPL      |L13.86|
;;;594            u32IntFlag |= SPI_FIFO_TIMEOUT_INT_MASK;
000052  2120              MOVS     r1,#0x20
000054  4308              ORRS     r0,r0,r1
                  |L13.86|
;;;595    
;;;596        return u32IntFlag;
;;;597    }
000056  4770              BX       lr
;;;598    
                          ENDP


                          AREA ||i.SPI_GetStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetStatus PROC
;;;639      */
;;;640    uint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;641    {
;;;642        uint32_t u32Flag = 0;
000002  2000              MOVS     r0,#0
;;;643    
;;;644        /* Check busy status */
;;;645        if((u32Mask & SPI_BUSY_MASK) && (spi->CNTRL & SPI_CNTRL_GO_BUSY_Msk))
000004  07cb              LSLS     r3,r1,#31
000006  d003              BEQ      |L14.16|
000008  6813              LDR      r3,[r2,#0]
00000a  07db              LSLS     r3,r3,#31
00000c  d000              BEQ      |L14.16|
;;;646            u32Flag |= SPI_BUSY_MASK;
00000e  2001              MOVS     r0,#1
                  |L14.16|
;;;647    
;;;648        /* M05xxBN does not support the following functions */
;;;649        
;;;650        /* Check RX empty flag */
;;;651        if((u32Mask & SPI_RX_EMPTY_MASK) && (spi->CNTRL & SPI_CNTRL_RX_EMPTY_Msk))
000010  078b              LSLS     r3,r1,#30
000012  d504              BPL      |L14.30|
000014  6813              LDR      r3,[r2,#0]
000016  01db              LSLS     r3,r3,#7
000018  d501              BPL      |L14.30|
;;;652            u32Flag |= SPI_RX_EMPTY_MASK;
00001a  2302              MOVS     r3,#2
00001c  4318              ORRS     r0,r0,r3
                  |L14.30|
;;;653    
;;;654        /* Check RX full flag */
;;;655        if((u32Mask & SPI_RX_FULL_MASK) && (spi->CNTRL & SPI_CNTRL_RX_FULL_Msk))
00001e  074b              LSLS     r3,r1,#29
000020  d504              BPL      |L14.44|
000022  6813              LDR      r3,[r2,#0]
000024  019b              LSLS     r3,r3,#6
000026  d501              BPL      |L14.44|
;;;656            u32Flag |= SPI_RX_FULL_MASK;
000028  2304              MOVS     r3,#4
00002a  4318              ORRS     r0,r0,r3
                  |L14.44|
;;;657    
;;;658        /* Check TX empty flag */
;;;659        if((u32Mask & SPI_TX_EMPTY_MASK) && (spi->CNTRL & SPI_CNTRL_TX_EMPTY_Msk))
00002c  070b              LSLS     r3,r1,#28
00002e  d504              BPL      |L14.58|
000030  6813              LDR      r3,[r2,#0]
000032  015b              LSLS     r3,r3,#5
000034  d501              BPL      |L14.58|
;;;660            u32Flag |= SPI_TX_EMPTY_MASK;
000036  2308              MOVS     r3,#8
000038  4318              ORRS     r0,r0,r3
                  |L14.58|
;;;661    
;;;662        /* Check TX full flag */
;;;663        if((u32Mask & SPI_TX_FULL_MASK) && (spi->CNTRL & SPI_CNTRL_TX_FULL_Msk))
00003a  06c9              LSLS     r1,r1,#27
00003c  d504              BPL      |L14.72|
00003e  6811              LDR      r1,[r2,#0]
000040  0109              LSLS     r1,r1,#4
000042  d501              BPL      |L14.72|
;;;664            u32Flag |= SPI_TX_FULL_MASK;
000044  2110              MOVS     r1,#0x10
000046  4308              ORRS     r0,r0,r1
                  |L14.72|
;;;665    
;;;666        return u32Flag;
;;;667    }
000048  4770              BX       lr
;;;668    
                          ENDP


                          AREA ||i.SPI_Open||, CODE, READONLY, ALIGN=2

                  SPI_Open PROC
;;;46       */
;;;47     uint32_t SPI_Open(SPI_T *spi,
000000  b5f8              PUSH     {r3-r7,lr}
;;;48                       uint32_t u32MasterSlave,
;;;49                       uint32_t u32SPIMode,
;;;50                       uint32_t u32DataWidth,
;;;51                       uint32_t u32BusClock)
;;;52     {
;;;53         uint32_t u32ClkSrc = 0, u32Div;
;;;54     
;;;55         if(u32DataWidth == 32)
000002  9d06              LDR      r5,[sp,#0x18]
000004  460f              MOV      r7,r1                 ;52
000006  4604              MOV      r4,r0                 ;52
000008  2b20              CMP      r3,#0x20
00000a  d100              BNE      |L15.14|
;;;56             u32DataWidth = 0;
00000c  2300              MOVS     r3,#0
                  |L15.14|
;;;57     
;;;58         /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;59         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000e  00d8              LSLS     r0,r3,#3
000010  4338              ORRS     r0,r0,r7
000012  4310              ORRS     r0,r0,r2
000014  6020              STR      r0,[r4,#0]
;;;60     
;;;61         if(((SYS->PDID & 0xF0000000) == 0) || ((SYS->PDID & 0xF0000000) == 0x10000000)) /* For M05xxAN and M05xxBN, the SPI peripheral clock source is PCLK. */
000016  2005              MOVS     r0,#5
000018  0700              LSLS     r0,r0,#28
00001a  6800              LDR      r0,[r0,#0]
00001c  0f01              LSRS     r1,r0,#28
;;;62         {
;;;63             /* Get the system clock rate */
;;;64             u32ClkSrc = CLK_GetHCLKFreq();
;;;65     
;;;66             if(u32MasterSlave == SPI_MASTER)
;;;67             {
;;;68                 /* Default setting: slave select signal is active low; disable automatic slave select function. */
;;;69                 spi->SSR = SPI_SS_ACTIVE_LOW;
;;;70     
;;;71                 if((u32BusClock == u32ClkSrc) && ((SYS->PDID & 0xF0000000) == 0x10000000)) /* M05xxBN support DIV_ONE feature */
;;;72                 {
;;;73                     /* Enable DIV_ONE feature */
;;;74                     /* Note: When DIV_ONE feature is enabled, byte reorder function, byte suspend function and variable clock function must be disabled. */
;;;75                     spi->CNTRL2 |= SPI_CNTRL2_DIV_ONE_Msk;
;;;76                     /* Return master peripheral clock rate */
;;;77                     return u32ClkSrc;
;;;78                 }
;;;79                 else if(u32BusClock >= u32ClkSrc)
;;;80                 {
;;;81                     /* Set DIVIDER = 0 */
;;;82                     spi->DIVIDER &= (~SPI_DIVIDER_DIVIDER_Msk);
;;;83                     /* Return master peripheral clock rate */
;;;84                     return (u32ClkSrc / 2);
;;;85                 }
;;;86                 else if(u32BusClock == 0)
;;;87                 {
;;;88                     /* Set DIVIDER to the maximum value 0xFFFF */
;;;89                     spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (0xFFFF << SPI_DIVIDER_DIVIDER_Pos);
;;;90                     /* Return master peripheral clock rate */
;;;91                     return (u32ClkSrc / ((0xFFFF + 1) * 2));
;;;92                 }
;;;93                 else
;;;94                 {
;;;95                     u32Div = (((u32ClkSrc * 10) / (u32BusClock * 2) + 5) / 10) - 1; /* Round to the nearest integer */
00001e  0068              LSLS     r0,r5,#1
000020  9000              STR      r0,[sp,#0]            ;61
000022  2900              CMP      r1,#0                 ;61
000024  d016              BEQ      |L15.84|
000026  2005              MOVS     r0,#5                 ;61
000028  0700              LSLS     r0,r0,#28             ;61
00002a  6800              LDR      r0,[r0,#0]            ;61
00002c  0f00              LSRS     r0,r0,#28             ;61
00002e  2801              CMP      r0,#1                 ;61
000030  d010              BEQ      |L15.84|
;;;96                     if(u32Div > 0xFFFF)
;;;97                         u32Div = 0xFFFF;
;;;98                     spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;99                     /* Return master peripheral clock rate */
;;;100                    return (u32ClkSrc / ((u32Div + 1) * 2));
;;;101                }
;;;102            }
;;;103            else /* For slave mode, SPI peripheral clock rate is equal to system clock rate. */
;;;104            {
;;;105                /* Default setting: slave select signal is low level active. */
;;;106                spi->SSR = SPI_SSR_SS_LTRIG_Msk;
;;;107                /* Return slave peripheral clock rate */
;;;108                return u32ClkSrc;
;;;109            }
;;;110        }
;;;111        else /* M05xxDN or M05xxDE */
;;;112        {
;;;113            /* Set BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;114            spi->CNTRL2 |= SPI_CNTRL2_BCn_Msk;
000032  6be0              LDR      r0,[r4,#0x3c]
000034  2101              MOVS     r1,#1
000036  07c9              LSLS     r1,r1,#31
000038  4308              ORRS     r0,r0,r1
00003a  63e0              STR      r0,[r4,#0x3c]
;;;115    
;;;116            if(u32MasterSlave == SPI_MASTER)
;;;117            {
;;;118                /* Default setting: slave select signal is active low; disable automatic slave select function. */
;;;119                spi->SSR = SPI_SS_ACTIVE_LOW;
;;;120    
;;;121                /* Check clock source of SPI */
;;;122                if(spi == SPI0)
00003c  4a55              LDR      r2,|L15.404|
;;;123                {
;;;124                    if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
00003e  4856              LDR      r0,|L15.408|
000040  2f00              CMP      r7,#0                 ;116
000042  d048              BEQ      |L15.214|
;;;125                        u32ClkSrc = CLK_GetHCLKFreq();
;;;126                    else
;;;127                        u32ClkSrc = CLK_GetPLLClockFreq();
;;;128                }
;;;129                else
;;;130                {
;;;131                    if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI1_S_Msk) == CLK_CLKSEL1_SPI1_S_HCLK)
;;;132                        u32ClkSrc = CLK_GetHCLKFreq();
;;;133                    else
;;;134                        u32ClkSrc = CLK_GetPLLClockFreq();
;;;135                }
;;;136    
;;;137                if(u32BusClock >= u32ClkSrc)
;;;138                {
;;;139                    /* Set DIVIDER = 0 */
;;;140                    spi->DIVIDER = 0;
;;;141                    /* Return master peripheral clock rate */
;;;142                    return u32ClkSrc;
;;;143                }
;;;144                else if(u32BusClock == 0)
;;;145                {
;;;146                    /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;147                    spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;148                    /* Set DIVIDER to the maximum value 0xFF */
;;;149                    spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (0xFF << SPI_DIVIDER_DIVIDER_Pos);
;;;150                    /* Return master peripheral clock rate */
;;;151                    return (u32ClkSrc / ((0xFF + 1) * 2));
;;;152                }
;;;153                else
;;;154                {
;;;155                    u32Div = (((u32ClkSrc * 10) / u32BusClock + 5) / 10) - 1; /* Round to the nearest integer */
;;;156                    if(u32Div > 0xFF)
;;;157                    {
;;;158                        /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;159                        spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;160                        u32Div = (((u32ClkSrc * 10) / (u32BusClock * 2) + 5) / 10) - 1; /* Round to the nearest integer */
;;;161                        if(u32Div > 0xFF)
;;;162                            u32Div = 0xFF;
;;;163                        spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;164                        /* Return master peripheral clock rate */
;;;165                        return (u32ClkSrc / ((u32Div + 1) * 2));
;;;166                    }
;;;167                    else
;;;168                    {
;;;169                        spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;170                        /* Return master peripheral clock rate */
;;;171                        return (u32ClkSrc / (u32Div + 1));
;;;172                    }
;;;173                }
;;;174    
;;;175            }
;;;176            else /* For slave mode, force the SPI peripheral clock rate to system clock rate. */
;;;177            {
;;;178                /* Default setting: slave select signal is low level active. */
;;;179                spi->SSR = SPI_SSR_SS_LTRIG_Msk;
000044  2110              MOVS     r1,#0x10
000046  60a1              STR      r1,[r4,#8]
;;;180    
;;;181                /* Select HCLK as the clock source of SPI */
;;;182                if(spi == SPI0)
000048  4294              CMP      r4,r2
00004a  d17d              BNE      |L15.328|
;;;183                    CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI0_S_Msk)) | CLK_CLKSEL1_SPI0_S_HCLK;
00004c  6942              LDR      r2,[r0,#0x14]
00004e  430a              ORRS     r2,r2,r1
000050  6142              STR      r2,[r0,#0x14]
000052  e099              B        |L15.392|
                  |L15.84|
000054  f7fffffe          BL       CLK_GetHCLKFreq
000058  4606              MOV      r6,r0                 ;64
00005a  2f00              CMP      r7,#0                 ;66
00005c  d002              BEQ      |L15.100|
00005e  2010              MOVS     r0,#0x10              ;106
000060  60a0              STR      r0,[r4,#8]            ;106
000062  e015              B        |L15.144|
                  |L15.100|
000064  2000              MOVS     r0,#0                 ;69
000066  60a0              STR      r0,[r4,#8]            ;69
000068  42b5              CMP      r5,r6                 ;71
00006a  d105              BNE      |L15.120|
00006c  2005              MOVS     r0,#5                 ;71
00006e  0700              LSLS     r0,r0,#28             ;71
000070  6800              LDR      r0,[r0,#0]            ;71
000072  0f00              LSRS     r0,r0,#28             ;71
000074  2801              CMP      r0,#1                 ;71
000076  d007              BEQ      |L15.136|
                  |L15.120|
000078  42b5              CMP      r5,r6                 ;79
00007a  d30b              BCC      |L15.148|
00007c  6860              LDR      r0,[r4,#4]            ;82
00007e  0c00              LSRS     r0,r0,#16             ;82
000080  0400              LSLS     r0,r0,#16             ;82
000082  6060              STR      r0,[r4,#4]            ;82
000084  0870              LSRS     r0,r6,#1              ;84
;;;184                else
;;;185                    CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI1_S_Msk)) | CLK_CLKSEL1_SPI1_S_HCLK;
;;;186    
;;;187                u32ClkSrc = CLK_GetHCLKFreq();
;;;188                /* Set DIVIDER = 0 */
;;;189                spi->DIVIDER = 0;
;;;190                /* Return slave peripheral clock rate */
;;;191                return u32ClkSrc;
;;;192            }
;;;193        }
;;;194    
;;;195    }
000086  bdf8              POP      {r3-r7,pc}
                  |L15.136|
000088  6be0              LDR      r0,[r4,#0x3c]         ;75
00008a  2101              MOVS     r1,#1                 ;75
00008c  4308              ORRS     r0,r0,r1              ;75
00008e  63e0              STR      r0,[r4,#0x3c]         ;75
                  |L15.144|
000090  4630              MOV      r0,r6                 ;108
000092  bdf8              POP      {r3-r7,pc}
                  |L15.148|
000094  4f41              LDR      r7,|L15.412|
000096  2d00              CMP      r5,#0                 ;86
000098  d018              BEQ      |L15.204|
00009a  4630              MOV      r0,r6                 ;95
00009c  220a              MOVS     r2,#0xa               ;95
00009e  4350              MULS     r0,r2,r0              ;95
0000a0  9900              LDR      r1,[sp,#0]            ;95
0000a2  f7fffffe          BL       __aeabi_uidivmod
0000a6  210a              MOVS     r1,#0xa               ;95
0000a8  1d40              ADDS     r0,r0,#5              ;95
0000aa  f7fffffe          BL       __aeabi_uidivmod
0000ae  1e40              SUBS     r0,r0,#1              ;95
0000b0  42b8              CMP      r0,r7                 ;96
0000b2  d900              BLS      |L15.182|
0000b4  4638              MOV      r0,r7                 ;97
                  |L15.182|
0000b6  6861              LDR      r1,[r4,#4]            ;98
0000b8  0c09              LSRS     r1,r1,#16             ;98
0000ba  0409              LSLS     r1,r1,#16             ;98
0000bc  4301              ORRS     r1,r1,r0              ;98
0000be  6061              STR      r1,[r4,#4]            ;98
0000c0  0041              LSLS     r1,r0,#1              ;100
0000c2  4630              MOV      r0,r6                 ;100
0000c4  1c89              ADDS     r1,r1,#2              ;100
0000c6  f7fffffe          BL       __aeabi_uidivmod
0000ca  bdf8              POP      {r3-r7,pc}
                  |L15.204|
0000cc  6860              LDR      r0,[r4,#4]            ;89
0000ce  4338              ORRS     r0,r0,r7              ;89
0000d0  6060              STR      r0,[r4,#4]            ;89
0000d2  0c70              LSRS     r0,r6,#17             ;91
0000d4  bdf8              POP      {r3-r7,pc}
                  |L15.214|
0000d6  2700              MOVS     r7,#0                 ;119
0000d8  60a7              STR      r7,[r4,#8]            ;119
0000da  6940              LDR      r0,[r0,#0x14]         ;131
0000dc  4294              CMP      r4,r2                 ;122
0000de  d107              BNE      |L15.240|
0000e0  06c0              LSLS     r0,r0,#27             ;124
0000e2  d407              BMI      |L15.244|
0000e4  e009              B        |L15.250|
                  |L15.230|
0000e6  4606              MOV      r6,r0                 ;125
0000e8  42b5              CMP      r5,r6                 ;137
0000ea  d309              BCC      |L15.256|
0000ec  6067              STR      r7,[r4,#4]            ;140
0000ee  bdf8              POP      {r3-r7,pc}
                  |L15.240|
0000f0  0680              LSLS     r0,r0,#26             ;131
0000f2  d502              BPL      |L15.250|
                  |L15.244|
0000f4  f7fffffe          BL       CLK_GetHCLKFreq
0000f8  e7f5              B        |L15.230|
                  |L15.250|
0000fa  f7fffffe          BL       CLK_GetPLLClockFreq
0000fe  e7f2              B        |L15.230|
                  |L15.256|
000100  2d00              CMP      r5,#0                 ;144
000102  d02a              BEQ      |L15.346|
000104  200a              MOVS     r0,#0xa               ;155
000106  4637              MOV      r7,r6                 ;155
000108  4347              MULS     r7,r0,r7              ;155
00010a  4629              MOV      r1,r5                 ;155
00010c  4638              MOV      r0,r7                 ;155
00010e  f7fffffe          BL       __aeabi_uidivmod
000112  210a              MOVS     r1,#0xa               ;155
000114  1d40              ADDS     r0,r0,#5              ;155
000116  f7fffffe          BL       __aeabi_uidivmod
00011a  1e40              SUBS     r0,r0,#1              ;155
00011c  28ff              CMP      r0,#0xff              ;156
00011e  d927              BLS      |L15.368|
000120  6be0              LDR      r0,[r4,#0x3c]         ;159
000122  0040              LSLS     r0,r0,#1              ;159
000124  0840              LSRS     r0,r0,#1              ;159
000126  63e0              STR      r0,[r4,#0x3c]         ;159
000128  4638              MOV      r0,r7                 ;160
00012a  9900              LDR      r1,[sp,#0]            ;160
00012c  f7fffffe          BL       __aeabi_uidivmod
000130  210a              MOVS     r1,#0xa               ;160
000132  1d40              ADDS     r0,r0,#5              ;160
000134  f7fffffe          BL       __aeabi_uidivmod
000138  1e40              SUBS     r0,r0,#1              ;160
00013a  28ff              CMP      r0,#0xff              ;161
00013c  d900              BLS      |L15.320|
00013e  20ff              MOVS     r0,#0xff              ;162
                  |L15.320|
000140  6861              LDR      r1,[r4,#4]            ;163
000142  0c09              LSRS     r1,r1,#16             ;163
000144  0409              LSLS     r1,r1,#16             ;163
000146  e000              B        |L15.330|
                  |L15.328|
000148  e01a              B        |L15.384|
                  |L15.330|
00014a  4301              ORRS     r1,r1,r0              ;163
00014c  6061              STR      r1,[r4,#4]            ;163
00014e  0041              LSLS     r1,r0,#1              ;165
000150  4630              MOV      r0,r6                 ;165
000152  1c89              ADDS     r1,r1,#2              ;165
                  |L15.340|
000154  f7fffffe          BL       __aeabi_uidivmod
000158  bdf8              POP      {r3-r7,pc}
                  |L15.346|
00015a  6be0              LDR      r0,[r4,#0x3c]         ;147
00015c  0040              LSLS     r0,r0,#1              ;147
00015e  0840              LSRS     r0,r0,#1              ;147
000160  63e0              STR      r0,[r4,#0x3c]         ;147
000162  6860              LDR      r0,[r4,#4]            ;149
000164  0c00              LSRS     r0,r0,#16             ;149
000166  0400              LSLS     r0,r0,#16             ;149
000168  30ff              ADDS     r0,r0,#0xff           ;149
00016a  6060              STR      r0,[r4,#4]            ;149
00016c  0a70              LSRS     r0,r6,#9              ;151
00016e  bdf8              POP      {r3-r7,pc}
                  |L15.368|
000170  6861              LDR      r1,[r4,#4]            ;169
000172  0c09              LSRS     r1,r1,#16             ;169
000174  0409              LSLS     r1,r1,#16             ;169
000176  4301              ORRS     r1,r1,r0              ;169
000178  6061              STR      r1,[r4,#4]            ;169
00017a  1c41              ADDS     r1,r0,#1              ;171
00017c  4630              MOV      r0,r6                 ;171
00017e  e7e9              B        |L15.340|
                  |L15.384|
000180  6941              LDR      r1,[r0,#0x14]         ;185
000182  2220              MOVS     r2,#0x20              ;185
000184  4311              ORRS     r1,r1,r2              ;185
000186  6141              STR      r1,[r0,#0x14]         ;185
                  |L15.392|
000188  f7fffffe          BL       CLK_GetHCLKFreq
00018c  2100              MOVS     r1,#0                 ;189
00018e  6061              STR      r1,[r4,#4]            ;189
000190  bdf8              POP      {r3-r7,pc}
;;;196    
                          ENDP

000192  0000              DCW      0x0000
                  |L15.404|
                          DCD      0x40030000
                  |L15.408|
                          DCD      0x50000200
                  |L15.412|
                          DCD      0x0000ffff

                          AREA ||i.SPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_SetBusClock PROC
;;;279      */
;;;280    uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;281    {
000002  4604              MOV      r4,r0
;;;282        uint32_t u32ClkSrc;
;;;283        uint32_t u32Div;
;;;284    
;;;285        if(((SYS->PDID & 0xF0000000) == 0) || ((SYS->PDID & 0xF0000000) == 0x10000000)) /* For M05xxAN and M05xxBN, the SPI peripheral clock source is PCLK. */
000004  2005              MOVS     r0,#5
000006  0700              LSLS     r0,r0,#28
000008  6800              LDR      r0,[r0,#0]
00000a  460d              MOV      r5,r1                 ;281
00000c  0f00              LSRS     r0,r0,#28
;;;286        {
;;;287            /* Get the system clock rate */
;;;288            u32ClkSrc = CLK_GetHCLKFreq();
;;;289    
;;;290            if((u32BusClock == u32ClkSrc) && ((SYS->PDID & 0xF0000000) == 0x10000000)) /* M05xxBN support DIV_ONE feature */
;;;291            {
;;;292                /* Enable DIV_ONE feature */
;;;293                /* Note: When DIV_ONE feature is enabled, byte reorder function, byte suspend function and variable clock function must be disabled. */
;;;294                spi->CNTRL2 |= SPI_CNTRL2_DIV_ONE_Msk;
;;;295                /* Return master peripheral clock rate */
;;;296                return u32ClkSrc;
;;;297            }
;;;298            else if(u32BusClock >= u32ClkSrc)
;;;299            {
;;;300                /* Set DIVIDER = 0 */
;;;301                spi->DIVIDER &= (~SPI_DIVIDER_DIVIDER_Msk);
;;;302                /* Return master peripheral clock rate */
;;;303                return (u32ClkSrc / 2);
;;;304            }
;;;305            else if(u32BusClock == 0)
;;;306            {
;;;307                /* Set DIVIDER to the maximum value 0xFFFF */
;;;308                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (0xFFFF << SPI_DIVIDER_DIVIDER_Pos);
;;;309                /* Return master peripheral clock rate */
;;;310                return (u32ClkSrc / ((0xFFFF + 1) * 2));
;;;311            }
;;;312            else
;;;313            {
;;;314                u32Div = (((u32ClkSrc * 10) / (u32BusClock * 2) + 5) / 10) - 1; /* Round to the nearest integer */
00000e  004f              LSLS     r7,r1,#1
000010  2800              CMP      r0,#0                 ;285
000012  d012              BEQ      |L16.58|
000014  2005              MOVS     r0,#5                 ;285
000016  0700              LSLS     r0,r0,#28             ;285
000018  6800              LDR      r0,[r0,#0]            ;285
00001a  0f00              LSRS     r0,r0,#28             ;285
00001c  2801              CMP      r0,#1                 ;285
00001e  d00c              BEQ      |L16.58|
;;;315                if(u32Div > 0xFFFF)
;;;316                    u32Div = 0xFFFF;
;;;317                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;318                /* Return master peripheral clock rate */
;;;319                return (u32ClkSrc / ((u32Div + 1) * 2));
;;;320            }
;;;321        }
;;;322        else /* M05xxDN or M05xxDE */
;;;323        {
;;;324            /* Set BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;325            spi->CNTRL2 |= SPI_CNTRL2_BCn_Msk;
000020  6be0              LDR      r0,[r4,#0x3c]
000022  2101              MOVS     r1,#1
000024  07c9              LSLS     r1,r1,#31
000026  4308              ORRS     r0,r0,r1
000028  63e0              STR      r0,[r4,#0x3c]
;;;326    
;;;327            /* Check clock source of SPI */
;;;328            if(spi == SPI0)
;;;329            {
;;;330                if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
00002a  4847              LDR      r0,|L16.328|
00002c  4945              LDR      r1,|L16.324|
;;;331                    u32ClkSrc = CLK_GetHCLKFreq();
;;;332                else
;;;333                    u32ClkSrc = CLK_GetPLLClockFreq();
;;;334            }
;;;335            else
;;;336            {
;;;337                if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI1_S_Msk) == CLK_CLKSEL1_SPI1_S_HCLK)
00002e  6940              LDR      r0,[r0,#0x14]
000030  428c              CMP      r4,r1                 ;328
000032  d142              BNE      |L16.186|
000034  06c0              LSLS     r0,r0,#27             ;330
000036  d442              BMI      |L16.190|
000038  e044              B        |L16.196|
                  |L16.58|
00003a  f7fffffe          BL       CLK_GetHCLKFreq
00003e  4606              MOV      r6,r0                 ;288
000040  42b5              CMP      r5,r6                 ;290
000042  d105              BNE      |L16.80|
000044  2005              MOVS     r0,#5                 ;290
000046  0700              LSLS     r0,r0,#28             ;290
000048  6800              LDR      r0,[r0,#0]            ;290
00004a  0f00              LSRS     r0,r0,#28             ;290
00004c  2801              CMP      r0,#1                 ;290
00004e  d007              BEQ      |L16.96|
                  |L16.80|
000050  42b5              CMP      r5,r6                 ;298
000052  d30a              BCC      |L16.106|
000054  6860              LDR      r0,[r4,#4]            ;301
000056  0c00              LSRS     r0,r0,#16             ;301
000058  0400              LSLS     r0,r0,#16             ;301
00005a  6060              STR      r0,[r4,#4]            ;301
00005c  0870              LSRS     r0,r6,#1              ;303
;;;338                    u32ClkSrc = CLK_GetHCLKFreq();
;;;339                else
;;;340                    u32ClkSrc = CLK_GetPLLClockFreq();
;;;341            }
;;;342    
;;;343            if(u32BusClock >= u32ClkSrc)
;;;344            {
;;;345                /* Set DIVIDER = 0 */
;;;346                spi->DIVIDER = 0;
;;;347                /* Return master peripheral clock rate */
;;;348                return u32ClkSrc;
;;;349            }
;;;350            else if(u32BusClock == 0)
;;;351            {
;;;352                /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;353                spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;354                /* Set DIVIDER to the maximum value 0xFF */
;;;355                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (0xFF << SPI_DIVIDER_DIVIDER_Pos);
;;;356                /* Return master peripheral clock rate */
;;;357                return (u32ClkSrc / ((0xFF + 1) * 2));
;;;358            }
;;;359            else
;;;360            {
;;;361                u32Div = (((u32ClkSrc * 10) / u32BusClock + 5) / 10) - 1; /* Round to the nearest integer */
;;;362                if(u32Div > 0xFF)
;;;363                {
;;;364                    /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;365                    spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;366                    u32Div = (((u32ClkSrc * 10) / (u32BusClock * 2) + 5) / 10) - 1; /* Round to the nearest integer */
;;;367                    if(u32Div > 0xFF)
;;;368                        u32Div = 0xFF;
;;;369                    spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;370                    /* Return master peripheral clock rate */
;;;371                    return (u32ClkSrc / ((u32Div + 1) * 2));
;;;372                }
;;;373                else
;;;374                {
;;;375                    spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;376                    /* Return master peripheral clock rate */
;;;377                    return (u32ClkSrc / (u32Div + 1));
;;;378                }
;;;379            }
;;;380        }
;;;381    }
00005e  bdf8              POP      {r3-r7,pc}
                  |L16.96|
000060  6be0              LDR      r0,[r4,#0x3c]         ;294
000062  2101              MOVS     r1,#1                 ;294
000064  4308              ORRS     r0,r0,r1              ;294
000066  63e0              STR      r0,[r4,#0x3c]         ;294
000068  e025              B        |L16.182|
                  |L16.106|
00006a  0028              MOVS     r0,r5                 ;305
00006c  4d37              LDR      r5,|L16.332|
00006e  d018              BEQ      |L16.162|
000070  4630              MOV      r0,r6                 ;314
000072  220a              MOVS     r2,#0xa               ;314
000074  4350              MULS     r0,r2,r0              ;314
000076  4639              MOV      r1,r7                 ;314
000078  f7fffffe          BL       __aeabi_uidivmod
00007c  210a              MOVS     r1,#0xa               ;314
00007e  1d40              ADDS     r0,r0,#5              ;314
000080  f7fffffe          BL       __aeabi_uidivmod
000084  1e40              SUBS     r0,r0,#1              ;314
000086  42a8              CMP      r0,r5                 ;315
000088  d900              BLS      |L16.140|
00008a  4628              MOV      r0,r5                 ;316
                  |L16.140|
00008c  6861              LDR      r1,[r4,#4]            ;317
00008e  0c09              LSRS     r1,r1,#16             ;317
000090  0409              LSLS     r1,r1,#16             ;317
000092  4301              ORRS     r1,r1,r0              ;317
000094  6061              STR      r1,[r4,#4]            ;317
000096  0041              LSLS     r1,r0,#1              ;319
000098  4630              MOV      r0,r6                 ;319
00009a  1c89              ADDS     r1,r1,#2              ;319
00009c  f7fffffe          BL       __aeabi_uidivmod
0000a0  bdf8              POP      {r3-r7,pc}
                  |L16.162|
0000a2  6860              LDR      r0,[r4,#4]            ;308
0000a4  4328              ORRS     r0,r0,r5              ;308
0000a6  6060              STR      r0,[r4,#4]            ;308
0000a8  0c70              LSRS     r0,r6,#17             ;310
0000aa  bdf8              POP      {r3-r7,pc}
                  |L16.172|
0000ac  4606              MOV      r6,r0                 ;331
0000ae  42b5              CMP      r5,r6                 ;343
0000b0  d30b              BCC      |L16.202|
0000b2  2000              MOVS     r0,#0                 ;346
0000b4  6060              STR      r0,[r4,#4]            ;346
                  |L16.182|
0000b6  4630              MOV      r0,r6                 ;348
0000b8  bdf8              POP      {r3-r7,pc}
                  |L16.186|
0000ba  0680              LSLS     r0,r0,#26             ;337
0000bc  d502              BPL      |L16.196|
                  |L16.190|
0000be  f7fffffe          BL       CLK_GetHCLKFreq
0000c2  e7f3              B        |L16.172|
                  |L16.196|
0000c4  f7fffffe          BL       CLK_GetPLLClockFreq
0000c8  e7f0              B        |L16.172|
                  |L16.202|
0000ca  2d00              CMP      r5,#0                 ;350
0000cc  d027              BEQ      |L16.286|
0000ce  210a              MOVS     r1,#0xa               ;361
0000d0  4348              MULS     r0,r1,r0              ;361
0000d2  4629              MOV      r1,r5                 ;361
0000d4  9000              STR      r0,[sp,#0]            ;361
0000d6  f7fffffe          BL       __aeabi_uidivmod
0000da  210a              MOVS     r1,#0xa               ;361
0000dc  1d40              ADDS     r0,r0,#5              ;361
0000de  f7fffffe          BL       __aeabi_uidivmod
0000e2  1e40              SUBS     r0,r0,#1              ;361
0000e4  28ff              CMP      r0,#0xff              ;362
0000e6  d925              BLS      |L16.308|
0000e8  6be0              LDR      r0,[r4,#0x3c]         ;365
0000ea  0040              LSLS     r0,r0,#1              ;365
0000ec  0840              LSRS     r0,r0,#1              ;365
0000ee  63e0              STR      r0,[r4,#0x3c]         ;365
0000f0  4639              MOV      r1,r7                 ;366
0000f2  9800              LDR      r0,[sp,#0]            ;366
0000f4  f7fffffe          BL       __aeabi_uidivmod
0000f8  210a              MOVS     r1,#0xa               ;366
0000fa  1d40              ADDS     r0,r0,#5              ;366
0000fc  f7fffffe          BL       __aeabi_uidivmod
000100  1e40              SUBS     r0,r0,#1              ;366
000102  28ff              CMP      r0,#0xff              ;367
000104  d900              BLS      |L16.264|
000106  20ff              MOVS     r0,#0xff              ;368
                  |L16.264|
000108  6861              LDR      r1,[r4,#4]            ;369
00010a  0c09              LSRS     r1,r1,#16             ;369
00010c  0409              LSLS     r1,r1,#16             ;369
00010e  4301              ORRS     r1,r1,r0              ;369
000110  6061              STR      r1,[r4,#4]            ;369
000112  0041              LSLS     r1,r0,#1              ;371
000114  4630              MOV      r0,r6                 ;371
000116  1c89              ADDS     r1,r1,#2              ;371
                  |L16.280|
000118  f7fffffe          BL       __aeabi_uidivmod
00011c  bdf8              POP      {r3-r7,pc}
                  |L16.286|
00011e  6be0              LDR      r0,[r4,#0x3c]         ;353
000120  0040              LSLS     r0,r0,#1              ;353
000122  0840              LSRS     r0,r0,#1              ;353
000124  63e0              STR      r0,[r4,#0x3c]         ;353
000126  6860              LDR      r0,[r4,#4]            ;355
000128  0c00              LSRS     r0,r0,#16             ;355
00012a  0400              LSLS     r0,r0,#16             ;355
00012c  30ff              ADDS     r0,r0,#0xff           ;355
00012e  6060              STR      r0,[r4,#4]            ;355
000130  0a70              LSRS     r0,r6,#9              ;357
000132  bdf8              POP      {r3-r7,pc}
                  |L16.308|
000134  6861              LDR      r1,[r4,#4]            ;375
000136  0c09              LSRS     r1,r1,#16             ;375
000138  0409              LSLS     r1,r1,#16             ;375
00013a  4301              ORRS     r1,r1,r0              ;375
00013c  6061              STR      r1,[r4,#4]            ;375
00013e  1c41              ADDS     r1,r0,#1              ;377
000140  4630              MOV      r0,r6                 ;377
000142  e7e9              B        |L16.280|
;;;382    
                          ENDP

                  |L16.324|
                          DCD      0x40030000
                  |L16.328|
                          DCD      0x50000200
                  |L16.332|
                          DCD      0x0000ffff

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_spi_c_SPI_Open____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REVSH|
#line 132
|__asm___5_spi_c_SPI_Open____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
