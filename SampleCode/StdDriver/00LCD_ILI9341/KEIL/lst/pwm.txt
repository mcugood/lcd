; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\pwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pwm.d --cpu=Cortex-M0 --apcs=interwork -Otime --diag_suppress=9931 -I.\ -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\M051Series\Include -I..\..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\INC\?ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\pwm.crf ..\..\..\..\Library\StdDriver\src\pwm.c]
                          THUMB

                          AREA ||i.PWM_ClearADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearADCTriggerFlag PROC
;;;299     */
;;;300    void PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  2201              MOVS     r2,#1
;;;301    {
;;;302        (pwm)->TSTATUS = (PWM_TSTATUS_PWM0TF_Msk << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  3080              ADDS     r0,r0,#0x80
000006  6042              STR      r2,[r0,#4]
;;;303    }
000008  4770              BX       lr
;;;304    
                          ENDP


                          AREA ||i.PWM_ClearCaptureIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearCaptureIntFlag PROC
;;;498     */
;;;499    void PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  b430              PUSH     {r4,r5}
;;;500    {
;;;501        //clear capture interrupt flag, and clear CRLR or CFLR latched indicator
;;;502        if(u32ChannelNum < 2)
;;;503            (pwm)->CCR0 = ((pwm)->CCR0 & PWM_CCR_MASK) | (PWM_CCR0_CAPIF0_Msk << (u32ChannelNum * 16)) | (u32Edge << (u32ChannelNum * 16 + 5));
000002  4d0d              LDR      r5,|L2.56|
000004  2410              MOVS     r4,#0x10
000006  010b              LSLS     r3,r1,#4
000008  2902              CMP      r1,#2                 ;502
00000a  d209              BCS      |L2.32|
00000c  6d01              LDR      r1,[r0,#0x50]
00000e  409c              LSLS     r4,r4,r3
000010  4029              ANDS     r1,r1,r5
000012  1d5b              ADDS     r3,r3,#5
000014  4321              ORRS     r1,r1,r4
000016  409a              LSLS     r2,r2,r3
000018  4311              ORRS     r1,r1,r2
00001a  6501              STR      r1,[r0,#0x50]
;;;504        else
;;;505            (pwm)->CCR2 = ((pwm)->CCR2 & PWM_CCR_MASK) | (PWM_CCR2_CAPIF2_Msk << ((u32ChannelNum - 2) * 16)) | (u32Edge << ((u32ChannelNum - 2) * 16 + 5));
;;;506    }
00001c  bc30              POP      {r4,r5}
00001e  4770              BX       lr
                  |L2.32|
000020  4619              MOV      r1,r3                 ;505
000022  3920              SUBS     r1,r1,#0x20           ;505
000024  408c              LSLS     r4,r4,r1              ;505
000026  6d41              LDR      r1,[r0,#0x54]         ;505
000028  3b1b              SUBS     r3,r3,#0x1b           ;505
00002a  4029              ANDS     r1,r1,r5              ;505
00002c  430c              ORRS     r4,r4,r1              ;505
00002e  409a              LSLS     r2,r2,r3              ;505
000030  4314              ORRS     r4,r4,r2              ;505
000032  6544              STR      r4,[r0,#0x54]         ;505
000034  bc30              POP      {r4,r5}
000036  4770              BX       lr
;;;507    
                          ENDP

                  |L2.56|
                          DCD      0x000f000f

                          AREA ||i.PWM_ClearDutyIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearDutyIntFlag PROC
;;;571     */
;;;572    void PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  22ff              MOVS     r2,#0xff
;;;573    {
;;;574        (pwm)->PIIR = PWM_PIIR_PWMDIF0_Msk << u32ChannelNum;
000002  3201              ADDS     r2,#1
000004  408a              LSLS     r2,r2,r1
000006  6442              STR      r2,[r0,#0x44]
;;;575    }
000008  4770              BX       lr
;;;576    
                          ENDP


                          AREA ||i.PWM_ClearPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearPeriodIntFlag PROC
;;;626     */
;;;627    void PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  2201              MOVS     r2,#1
;;;628    {
;;;629        (pwm)->PIIR = (PWM_PIIR_PWMIF0_Msk << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  6442              STR      r2,[r0,#0x44]
;;;630    }
000006  4770              BX       lr
;;;631    
                          ENDP


                          AREA ||i.PWM_ConfigCaptureChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigCaptureChannel PROC
;;;36      */
;;;37     uint32_t PWM_ConfigCaptureChannel(PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;38                                       uint32_t u32ChannelNum,
;;;39                                       uint32_t u32UnitTimeNsec,
;;;40                                       uint32_t u32CaptureEdge)
;;;41     {
000002  4605              MOV      r5,r0
;;;42         uint32_t u32Src;
;;;43         uint32_t u32PWMClockSrc;
;;;44         uint32_t u32PWMClkTbl[4] = {__HXT, __LIRC, 0, __HIRC};
000004  483f              LDR      r0,|L5.260|
000006  460f              MOV      r7,r1                 ;41
000008  c80f              LDM      r0,{r0-r3}
00000a  b099              SUB      sp,sp,#0x64           ;41
;;;45         uint32_t u32NearestUnitTimeNsec;
;;;46         uint8_t  u8Divider = 1;
00000c  ac12              ADD      r4,sp,#0x48
00000e  c40f              STM      r4!,{r0-r3}
000010  2601              MOVS     r6,#1
;;;47         /* this table is mapping divider value to register configuration */
;;;48         uint32_t u32PWMDividerToRegTbl[17] = {NULL, 4, 0, NULL, 1, NULL, NULL, NULL, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 3};
000012  2244              MOVS     r2,#0x44
000014  493c              LDR      r1,|L5.264|
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       __aeabi_memcpy4
;;;49         uint16_t u16Prescale = 2;
;;;50         uint16_t u16CNR = 0xFFFF;
00001c  483b              LDR      r0,|L5.268|
00001e  2402              MOVS     r4,#2                 ;49
000020  9017              STR      r0,[sp,#0x5c]         ;49
;;;51     
;;;52         if(pwm == PWMA)
000022  493b              LDR      r1,|L5.272|
000024  4620              MOV      r0,r4                 ;49
;;;53             u32Src = (CLK->CLKSEL1 & (CLK_CLKSEL1_PWM01_S_Msk << (u32ChannelNum & 2))) >> (CLK_CLKSEL1_PWM01_S_Pos + (u32ChannelNum & 2));
000026  4a3b              LDR      r2,|L5.276|
000028  4038              ANDS     r0,r0,r7
00002a  428d              CMP      r5,r1                 ;52
00002c  d106              BNE      |L5.60|
00002e  6951              LDR      r1,[r2,#0x14]
000030  2203              MOVS     r2,#3
000032  0712              LSLS     r2,r2,#28
000034  4082              LSLS     r2,r2,r0
000036  4011              ANDS     r1,r1,r2
000038  301c              ADDS     r0,r0,#0x1c
00003a  e004              B        |L5.70|
                  |L5.60|
;;;54         else /*pwm == PWMB*/
;;;55             u32Src = (CLK->CLKSEL2 & (CLK_CLKSEL2_PWM45_S_Msk << (u32ChannelNum & 2))) >> (CLK_CLKSEL2_PWM45_S_Pos + (u32ChannelNum & 2));
00003c  69d1              LDR      r1,[r2,#0x1c]
00003e  2230              MOVS     r2,#0x30
000040  4082              LSLS     r2,r2,r0
000042  4011              ANDS     r1,r1,r2
000044  1d00              ADDS     r0,r0,#4
                  |L5.70|
000046  40c1              LSRS     r1,r1,r0
;;;56     
;;;57         if(u32Src == 2)
000048  2902              CMP      r1,#2
00004a  d01e              BEQ      |L5.138|
;;;58         {
;;;59             SystemCoreClockUpdate();
;;;60             u32PWMClockSrc = SystemCoreClock;
;;;61         }
;;;62         else
;;;63         {
;;;64             u32PWMClockSrc = u32PWMClkTbl[u32Src];
00004c  0088              LSLS     r0,r1,#2
00004e  a912              ADD      r1,sp,#0x48
000050  5808              LDR      r0,[r1,r0]
                  |L5.82|
;;;65         }
;;;66     
;;;67         u32PWMClockSrc /= 1000;
000052  217d              MOVS     r1,#0x7d
000054  00c9              LSLS     r1,r1,#3
000056  f7fffffe          BL       __aeabi_uidivmod
00005a  9011              STR      r0,[sp,#0x44]
                  |L5.92|
;;;68         for(; u16Prescale <= 0x100; u16Prescale++)
;;;69         {
;;;70             u32NearestUnitTimeNsec = (1000000 * u16Prescale * u8Divider) / u32PWMClockSrc;
00005c  4620              MOV      r0,r4
00005e  4370              MULS     r0,r6,r0
000060  492d              LDR      r1,|L5.280|
000062  9016              STR      r0,[sp,#0x58]
000064  4348              MULS     r0,r1,r0
000066  9911              LDR      r1,[sp,#0x44]
000068  f7fffffe          BL       __aeabi_uidivmod
;;;71             if(u32NearestUnitTimeNsec < u32UnitTimeNsec)
00006c  991b              LDR      r1,[sp,#0x6c]
00006e  4288              CMP      r0,r1
000070  d21c              BCS      |L5.172|
;;;72             {
;;;73                 if((u16Prescale == 0x100) && (u8Divider == 16))  //limit to the maximum unit time(nano second)
000072  21ff              MOVS     r1,#0xff
000074  3101              ADDS     r1,#1
000076  428c              CMP      r4,r1
000078  d101              BNE      |L5.126|
00007a  2e10              CMP      r6,#0x10
00007c  d016              BEQ      |L5.172|
                  |L5.126|
;;;74                     break;
;;;75                 if(u16Prescale == 0x100)
00007e  428c              CMP      r4,r1
000080  d108              BNE      |L5.148|
;;;76                 {
;;;77                     u16Prescale = 2;
000082  2402              MOVS     r4,#2
;;;78                     u8Divider <<= 1; // clk divider could only be 1, 2, 4, 8, 16
000084  0672              LSLS     r2,r6,#25
000086  0e16              LSRS     r6,r2,#24
;;;79                     continue;
000088  e00c              B        |L5.164|
                  |L5.138|
00008a  f7fffffe          BL       SystemCoreClockUpdate
00008e  4823              LDR      r0,|L5.284|
000090  6800              LDR      r0,[r0,#0]            ;60  ; SystemCoreClock
000092  e7de              B        |L5.82|
                  |L5.148|
;;;80                 }
;;;81                 if(!((1000000  * ((u16Prescale * u8Divider) + 1)) > (u32NearestUnitTimeNsec * u32PWMClockSrc)))
000094  9a16              LDR      r2,[sp,#0x58]
000096  4b20              LDR      r3,|L5.280|
000098  1c52              ADDS     r2,r2,#1
00009a  435a              MULS     r2,r3,r2
00009c  9b11              LDR      r3,[sp,#0x44]
00009e  4343              MULS     r3,r0,r3
0000a0  429a              CMP      r2,r3
0000a2  d903              BLS      |L5.172|
                  |L5.164|
0000a4  1c64              ADDS     r4,r4,#1
0000a6  b2a4              UXTH     r4,r4                 ;68
0000a8  428c              CMP      r4,r1                 ;68
0000aa  d9d7              BLS      |L5.92|
                  |L5.172|
0000ac  1e64              SUBS     r4,r4,#1              ;68
;;;82                     break;
;;;83                 continue;
;;;84             }
;;;85             break;
;;;86         }
;;;87     
;;;88         // Store return value here 'cos we're gonna change u8Divider & u16Prescale & u16CNR to the real value to fill into register
;;;89         u16Prescale -= 1;
0000ae  b2a2              UXTH     r2,r4
;;;90     
;;;91         // convert to real register value
;;;92         u8Divider = u32PWMDividerToRegTbl[u8Divider];
0000b0  00b1              LSLS     r1,r6,#2
0000b2  466b              MOV      r3,sp
0000b4  5c5b              LDRB     r3,[r3,r1]
;;;93     
;;;94         // every two channels share a prescaler
;;;95         (pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u16Prescale << ((u32ChannelNum >> 1) * 8));
0000b6  682c              LDR      r4,[r5,#0]
0000b8  0879              LSRS     r1,r7,#1
0000ba  468c              MOV      r12,r1
0000bc  00c9              LSLS     r1,r1,#3
0000be  26ff              MOVS     r6,#0xff
0000c0  408e              LSLS     r6,r6,r1
0000c2  43b4              BICS     r4,r4,r6
0000c4  408a              LSLS     r2,r2,r1
0000c6  4314              ORRS     r4,r4,r2
0000c8  602c              STR      r4,[r5,#0]
;;;96         (pwm)->CSR = ((pwm)->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
0000ca  686a              LDR      r2,[r5,#4]
0000cc  00b9              LSLS     r1,r7,#2
0000ce  2407              MOVS     r4,#7
0000d0  408c              LSLS     r4,r4,r1
0000d2  43a2              BICS     r2,r2,r4
0000d4  408b              LSLS     r3,r3,r1
0000d6  431a              ORRS     r2,r2,r3
0000d8  606a              STR      r2,[r5,#4]
;;;97         // set PWM to edge aligned type
;;;98         (pwm)->PCR &= ~(PWM_PCR_PWM01TYPE_Msk << (u32ChannelNum >> 1));
0000da  68aa              LDR      r2,[r5,#8]
0000dc  2301              MOVS     r3,#1
0000de  4661              MOV      r1,r12
0000e0  079b              LSLS     r3,r3,#30
0000e2  408b              LSLS     r3,r3,r1
0000e4  439a              BICS     r2,r2,r3
0000e6  60aa              STR      r2,[r5,#8]
;;;99         (pwm)->PCR |= PWM_PCR_CH0MOD_Msk << (8 * u32ChannelNum);
0000e8  68a9              LDR      r1,[r5,#8]
0000ea  00fb              LSLS     r3,r7,#3
0000ec  2208              MOVS     r2,#8
0000ee  409a              LSLS     r2,r2,r3
0000f0  4311              ORRS     r1,r1,r2
0000f2  60a9              STR      r1,[r5,#8]
;;;100        *((__IO uint32_t *)((((uint32_t) & ((pwm)->CNR0)) + (u32ChannelNum) * 12))) = u16CNR;
0000f4  220c              MOVS     r2,#0xc
0000f6  4357              MULS     r7,r2,r7
0000f8  197a              ADDS     r2,r7,r5
0000fa  9917              LDR      r1,[sp,#0x5c]
0000fc  60d1              STR      r1,[r2,#0xc]
;;;101    
;;;102        return (u32NearestUnitTimeNsec);
;;;103    }
0000fe  b01d              ADD      sp,sp,#0x74
000100  bdf0              POP      {r4-r7,pc}
;;;104    
                          ENDP

000102  0000              DCW      0x0000
                  |L5.260|
                          DCD      ||.constdata||
                  |L5.264|
                          DCD      ||.constdata||+0x10
                  |L5.268|
                          DCD      0x0000ffff
                  |L5.272|
                          DCD      0x40040000
                  |L5.276|
                          DCD      0x50000200
                  |L5.280|
                          DCD      0x000f4240
                  |L5.284|
                          DCD      SystemCoreClock

                          AREA ||i.PWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;114     */
;;;115    uint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;116                                     uint32_t u32ChannelNum,
;;;117                                     uint32_t u32Frequency,
;;;118                                     uint32_t u32DutyCycle)
;;;119    {
000002  4604              MOV      r4,r0
;;;120        uint32_t u32Src;
;;;121        uint32_t u32PWMClockSrc;
;;;122        uint32_t u32PWMClkTbl[4] = {__HXT, __LIRC, 0, __HIRC};
000004  4849              LDR      r0,|L6.300|
000006  460e              MOV      r6,r1                 ;119
000008  c80f              LDM      r0,{r0-r3}
00000a  b099              SUB      sp,sp,#0x64           ;119
;;;123        uint32_t i;
;;;124        uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;125        /* this table is mapping divider value to register configuration */
;;;126        uint32_t u32PWMDividerToRegTbl[17] = {NULL, 4, 0, NULL, 1, NULL, NULL, NULL, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 3};
00000c  9214              STR      r2,[sp,#0x50]
00000e  9113              STR      r1,[sp,#0x4c]
000010  9012              STR      r0,[sp,#0x48]
000012  2501              MOVS     r5,#1                 ;124
000014  27ff              MOVS     r7,#0xff              ;124
000016  9315              STR      r3,[sp,#0x54]
000018  2244              MOVS     r2,#0x44
00001a  4945              LDR      r1,|L6.304|
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       __aeabi_memcpy4
;;;127        uint16_t u16CNR = 0xFFFF;
000022  4844              LDR      r0,|L6.308|
;;;128    
;;;129        if(pwm == PWMA)
;;;130            u32Src = (CLK->CLKSEL1 & (CLK_CLKSEL1_PWM01_S_Msk << (u32ChannelNum & 2))) >> (CLK_CLKSEL1_PWM01_S_Pos + (u32ChannelNum & 2));
000024  9011              STR      r0,[sp,#0x44]
000026  4944              LDR      r1,|L6.312|
000028  2002              MOVS     r0,#2
00002a  4a44              LDR      r2,|L6.316|
00002c  4030              ANDS     r0,r0,r6
00002e  428c              CMP      r4,r1                 ;129
000030  d106              BNE      |L6.64|
000032  6951              LDR      r1,[r2,#0x14]
000034  2203              MOVS     r2,#3
000036  0712              LSLS     r2,r2,#28
000038  4082              LSLS     r2,r2,r0
00003a  4011              ANDS     r1,r1,r2
00003c  301c              ADDS     r0,r0,#0x1c
00003e  e004              B        |L6.74|
                  |L6.64|
;;;131        else /*pwm == PWMB*/
;;;132            u32Src = (CLK->CLKSEL2 & (CLK_CLKSEL2_PWM45_S_Msk << (u32ChannelNum & 2))) >> (CLK_CLKSEL2_PWM45_S_Pos + (u32ChannelNum & 2));
000040  69d1              LDR      r1,[r2,#0x1c]
000042  2230              MOVS     r2,#0x30
000044  4082              LSLS     r2,r2,r0
000046  4011              ANDS     r1,r1,r2
000048  1d00              ADDS     r0,r0,#4
                  |L6.74|
00004a  40c1              LSRS     r1,r1,r0
;;;133    
;;;134        if(u32Src == 2)
00004c  2902              CMP      r1,#2
00004e  d021              BEQ      |L6.148|
;;;135        {
;;;136            SystemCoreClockUpdate();
;;;137            u32PWMClockSrc = SystemCoreClock;
;;;138        }
;;;139        else
;;;140        {
;;;141            u32PWMClockSrc = u32PWMClkTbl[u32Src];
000050  0088              LSLS     r0,r1,#2
000052  a912              ADD      r1,sp,#0x48
000054  5808              LDR      r0,[r1,r0]
                  |L6.86|
000056  9016              STR      r0,[sp,#0x58]         ;119
;;;142        }
;;;143    
;;;144        for(; u8Divider < 17; u8Divider <<= 1)    // clk divider could only be 1, 2, 4, 8, 16
;;;145        {
;;;146            i = (u32PWMClockSrc / u32Frequency) / u8Divider;
000058  991b              LDR      r1,[sp,#0x6c]
00005a  f7fffffe          BL       __aeabi_uidivmod
00005e  9017              STR      r0,[sp,#0x5c]
                  |L6.96|
000060  4629              MOV      r1,r5
000062  f7fffffe          BL       __aeabi_uidivmod
;;;147            // If target value is larger than CNR * prescale, need to use a larger divider
;;;148            if(i > (0x10000 * 0x100))
000066  2101              MOVS     r1,#1
000068  0609              LSLS     r1,r1,#24
00006a  4288              CMP      r0,r1
00006c  d817              BHI      |L6.158|
;;;149                continue;
;;;150    
;;;151            // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;152            u8Prescale = (i + 0xFFFF) / 0x10000;
00006e  4931              LDR      r1,|L6.308|
000070  1841              ADDS     r1,r0,r1
000072  0209              LSLS     r1,r1,#8
000074  0e0f              LSRS     r7,r1,#24
;;;153    
;;;154            // u8Prescale must at least be 2, otherwise the output stop
;;;155            if(u8Prescale < 3)
000076  2f03              CMP      r7,#3
000078  d200              BCS      |L6.124|
;;;156                u8Prescale = 2;
00007a  2702              MOVS     r7,#2
                  |L6.124|
;;;157    
;;;158            i /= u8Prescale;
00007c  4639              MOV      r1,r7
00007e  f7fffffe          BL       __aeabi_uidivmod
;;;159    
;;;160            if(i <= 0x10000)
000082  2101              MOVS     r1,#1
000084  0409              LSLS     r1,r1,#16
000086  4288              CMP      r0,r1
000088  d809              BHI      |L6.158|
;;;161            {
;;;162                if(i == 1)
00008a  2801              CMP      r0,#1
00008c  d000              BEQ      |L6.144|
;;;163                    u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;164                else
;;;165                    u16CNR = i;
00008e  b280              UXTH     r0,r0
                  |L6.144|
000090  9011              STR      r0,[sp,#0x44]         ;163
000092  e00a              B        |L6.170|
                  |L6.148|
000094  f7fffffe          BL       SystemCoreClockUpdate
000098  4829              LDR      r0,|L6.320|
00009a  6800              LDR      r0,[r0,#0]            ;137  ; SystemCoreClock
00009c  e7db              B        |L6.86|
                  |L6.158|
00009e  0668              LSLS     r0,r5,#25             ;144
0000a0  0e05              LSRS     r5,r0,#24             ;144
0000a2  2d11              CMP      r5,#0x11              ;144
0000a4  d201              BCS      |L6.170|
0000a6  9817              LDR      r0,[sp,#0x5c]         ;144
0000a8  e7da              B        |L6.96|
                  |L6.170|
;;;166                break;
;;;167            }
;;;168        }
;;;169        // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;170        i = u32PWMClockSrc / (u8Prescale * u8Divider * u16CNR);
0000aa  4639              MOV      r1,r7
0000ac  9811              LDR      r0,[sp,#0x44]
0000ae  4369              MULS     r1,r5,r1
0000b0  4341              MULS     r1,r0,r1
0000b2  9816              LDR      r0,[sp,#0x58]
0000b4  f7fffffe          BL       __aeabi_uidivmod
;;;171    
;;;172        u8Prescale -= 1;
;;;173        u16CNR -= 1;
0000b8  9016              STR      r0,[sp,#0x58]
0000ba  1e7f              SUBS     r7,r7,#1              ;170
0000bc  9811              LDR      r0,[sp,#0x44]
0000be  b2f9              UXTB     r1,r7                 ;172
0000c0  1e40              SUBS     r0,r0,#1
0000c2  b287              UXTH     r7,r0
;;;174        // convert to real register value
;;;175        u8Divider = u32PWMDividerToRegTbl[u8Divider];
0000c4  00a8              LSLS     r0,r5,#2
0000c6  466a              MOV      r2,sp
0000c8  5c15              LDRB     r5,[r2,r0]
;;;176    
;;;177        // every two channels share a prescaler
;;;178        (pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
0000ca  6822              LDR      r2,[r4,#0]
0000cc  0870              LSRS     r0,r6,#1
0000ce  4684              MOV      r12,r0
0000d0  00c0              LSLS     r0,r0,#3
0000d2  23ff              MOVS     r3,#0xff
0000d4  4083              LSLS     r3,r3,r0
0000d6  439a              BICS     r2,r2,r3
0000d8  4081              LSLS     r1,r1,r0
0000da  430a              ORRS     r2,r2,r1
0000dc  6022              STR      r2,[r4,#0]
;;;179        (pwm)->CSR = ((pwm)->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
0000de  6861              LDR      r1,[r4,#4]
0000e0  00b0              LSLS     r0,r6,#2
0000e2  2207              MOVS     r2,#7
0000e4  4082              LSLS     r2,r2,r0
0000e6  4391              BICS     r1,r1,r2
0000e8  4085              LSLS     r5,r5,r0
0000ea  4329              ORRS     r1,r1,r5
0000ec  6061              STR      r1,[r4,#4]
;;;180        // set PWM to edge aligned type
;;;181        (pwm)->PCR &= ~(PWM_PCR_PWM01TYPE_Msk << (u32ChannelNum >> 1));
0000ee  68a1              LDR      r1,[r4,#8]
0000f0  2201              MOVS     r2,#1
0000f2  4660              MOV      r0,r12
0000f4  0792              LSLS     r2,r2,#30
0000f6  4082              LSLS     r2,r2,r0
0000f8  4391              BICS     r1,r1,r2
0000fa  60a1              STR      r1,[r4,#8]
;;;182        (pwm)->PCR |= PWM_PCR_CH0MOD_Msk << (8 * u32ChannelNum);
0000fc  68a0              LDR      r0,[r4,#8]
0000fe  00f2              LSLS     r2,r6,#3
000100  2108              MOVS     r1,#8
000102  4091              LSLS     r1,r1,r2
000104  4308              ORRS     r0,r0,r1
000106  60a0              STR      r0,[r4,#8]
;;;183        if (u32DutyCycle)
;;;184            *((__IO uint32_t *)((((uint32_t) & ((pwm)->CMR0)) + u32ChannelNum * 12))) = u32DutyCycle * (u16CNR + 1) / 100 - 1;
000108  210c              MOVS     r1,#0xc
00010a  434e              MULS     r6,r1,r6
00010c  981c              LDR      r0,[sp,#0x70]         ;183
00010e  1934              ADDS     r4,r6,r4
000110  2800              CMP      r0,#0                 ;183
000112  d005              BEQ      |L6.288|
000114  1c79              ADDS     r1,r7,#1
000116  4348              MULS     r0,r1,r0
000118  2164              MOVS     r1,#0x64
00011a  f7fffffe          BL       __aeabi_uidivmod
00011e  1e40              SUBS     r0,r0,#1
                  |L6.288|
;;;185        else
;;;186            *((__IO uint32_t *)((((uint32_t) & ((pwm)->CMR0)) + u32ChannelNum * 12))) = 0;
000120  6120              STR      r0,[r4,#0x10]
;;;187    
;;;188        *((__IO uint32_t *)((((uint32_t) & ((pwm)->CNR0)) + (u32ChannelNum) * 12))) = u16CNR;
000122  60e7              STR      r7,[r4,#0xc]
;;;189    
;;;190        return(i);
000124  9816              LDR      r0,[sp,#0x58]
;;;191    }
000126  b01d              ADD      sp,sp,#0x74
000128  bdf0              POP      {r4-r7,pc}
;;;192    
                          ENDP

00012a  0000              DCW      0x0000
                  |L6.300|
                          DCD      ||.constdata||+0x54
                  |L6.304|
                          DCD      ||.constdata||+0x64
                  |L6.308|
                          DCD      0x0000ffff
                  |L6.312|
                          DCD      0x40040000
                  |L6.316|
                          DCD      0x50000200
                  |L6.320|
                          DCD      SystemCoreClock

                          AREA ||i.PWM_DisableADCTrigger||, CODE, READONLY, ALIGN=1

                  PWM_DisableADCTrigger PROC
;;;286     */
;;;287    void PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;288    {
;;;289        (pwm)->TCON = ((pwm)->TCON & ~((PWM_DUTY_TRIGGER_ADC | PWM_PERIOD_TRIGGER_ADC) << u32ChannelNum));
000002  6802              LDR      r2,[r0,#0]
000004  23ff              MOVS     r3,#0xff
000006  3302              ADDS     r3,#2
000008  408b              LSLS     r3,r3,r1
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
;;;290    }
00000e  4770              BX       lr
;;;291    
                          ENDP


                          AREA ||i.PWM_DisableCapture||, CODE, READONLY, ALIGN=1

                  PWM_DisableCapture PROC
;;;357     */
;;;358    void PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b4f0              PUSH     {r4-r7}
;;;359    {
;;;360        uint32_t i;
;;;361        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;362        {
;;;363            if(u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
;;;364            {
;;;365                if(i < 2)
;;;366                {
;;;367                    (pwm)->CCR0 &= ~(PWM_CCR0_CAPCH0EN_Msk << (i * 16));
000006  2308              MOVS     r3,#8
                  |L8.8|
000008  462c              MOV      r4,r5                 ;363
00000a  4094              LSLS     r4,r4,r2              ;363
00000c  420c              TST      r4,r1                 ;363
00000e  d00f              BEQ      |L8.48|
000010  2a02              CMP      r2,#2                 ;365
000012  d206              BCS      |L8.34|
000014  6d04              LDR      r4,[r0,#0x50]
000016  0116              LSLS     r6,r2,#4
000018  461f              MOV      r7,r3
00001a  40b7              LSLS     r7,r7,r6
00001c  43bc              BICS     r4,r4,r7
00001e  6504              STR      r4,[r0,#0x50]
000020  e006              B        |L8.48|
                  |L8.34|
;;;368                }
;;;369                else
;;;370                {
;;;371                    (pwm)->CCR2 &= ~(PWM_CCR2_CAPCH2EN_Msk << ((i - 2) * 16));
000022  0114              LSLS     r4,r2,#4
000024  461e              MOV      r6,r3
000026  3c20              SUBS     r4,r4,#0x20
000028  40a6              LSLS     r6,r6,r4
00002a  6d44              LDR      r4,[r0,#0x54]
00002c  43b4              BICS     r4,r4,r6
00002e  6544              STR      r4,[r0,#0x54]
                  |L8.48|
000030  1c52              ADDS     r2,r2,#1
000032  2a04              CMP      r2,#4                 ;361
000034  d3e8              BCC      |L8.8|
;;;372                }
;;;373            }
;;;374        }
;;;375        (pwm)->CAPENR &= ~u32ChannelMask;
000036  6f82              LDR      r2,[r0,#0x78]
000038  438a              BICS     r2,r2,r1
00003a  6782              STR      r2,[r0,#0x78]
;;;376    }
00003c  bcf0              POP      {r4-r7}
00003e  4770              BX       lr
;;;377    
                          ENDP


                          AREA ||i.PWM_DisableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableCaptureInt PROC
;;;478     */
;;;479    void PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  010b              LSLS     r3,r1,#4
;;;480    {
;;;481        if(u32ChannelNum < 2)
000002  2902              CMP      r1,#2
000004  d204              BCS      |L9.16|
;;;482            (pwm)->CCR0 &= ~(u32Edge << (u32ChannelNum * 16));
000006  6d01              LDR      r1,[r0,#0x50]
000008  409a              LSLS     r2,r2,r3
00000a  4391              BICS     r1,r1,r2
00000c  6501              STR      r1,[r0,#0x50]
;;;483        else
;;;484            (pwm)->CCR2 &= ~(u32Edge << ((u32ChannelNum - 2) * 16));
;;;485    }
00000e  4770              BX       lr
                  |L9.16|
000010  3b20              SUBS     r3,r3,#0x20
000012  6d41              LDR      r1,[r0,#0x54]         ;484
000014  409a              LSLS     r2,r2,r3              ;484
000016  4391              BICS     r1,r1,r2              ;484
000018  6541              STR      r1,[r0,#0x54]         ;484
00001a  4770              BX       lr
;;;486    
                          ENDP


                          AREA ||i.PWM_DisableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_DisableDeadZone PROC
;;;437     */
;;;438    void PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6883              LDR      r3,[r0,#8]
;;;439    {
;;;440        // every two channels shares the same setting
;;;441        u32ChannelNum >>= 1;
000002  0849              LSRS     r1,r1,#1
;;;442        // enable dead zone
;;;443        (pwm)->PCR &= ~(PWM_PCR_DZEN01_Msk << u32ChannelNum);
000004  2210              MOVS     r2,#0x10
000006  408a              LSLS     r2,r2,r1
000008  4393              BICS     r3,r3,r2
00000a  6083              STR      r3,[r0,#8]
;;;444    }
00000c  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.PWM_DisableDutyInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableDutyInt PROC
;;;559     */
;;;560    void PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6c02              LDR      r2,[r0,#0x40]
;;;561    {
;;;562        (pwm)->PIER &= ~(PWM_PIER_PWMDIE0_Msk << u32ChannelNum);
000002  23ff              MOVS     r3,#0xff
000004  3301              ADDS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6402              STR      r2,[r0,#0x40]
;;;563    }
00000c  4770              BX       lr
;;;564    
                          ENDP


                          AREA ||i.PWM_DisableOutput||, CODE, READONLY, ALIGN=1

                  PWM_DisableOutput PROC
;;;402     */
;;;403    void PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  6fc2              LDR      r2,[r0,#0x7c]
;;;404    {
;;;405        (pwm)->POE &= ~u32ChannelMask;
000002  438a              BICS     r2,r2,r1
000004  67c2              STR      r2,[r0,#0x7c]
;;;406    }
000006  4770              BX       lr
;;;407    
                          ENDP


                          AREA ||i.PWM_DisablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_DisablePeriodInt PROC
;;;614     */
;;;615    void PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6c02              LDR      r2,[r0,#0x40]
;;;616    {
;;;617        (pwm)->PIER &= ~(PWM_PIER_PWMIE0_Msk << u32ChannelNum);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  439a              BICS     r2,r2,r3
000008  6402              STR      r2,[r0,#0x40]
;;;618    }
00000a  4770              BX       lr
;;;619    
                          ENDP


                          AREA ||i.PWM_EnableADCTrigger||, CODE, READONLY, ALIGN=1

                  PWM_EnableADCTrigger PROC
;;;273     */
;;;274    void PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  b410              PUSH     {r4}
;;;275    {
000002  3080              ADDS     r0,r0,#0x80
;;;276        (pwm)->TCON = ((pwm)->TCON & ~((PWM_DUTY_TRIGGER_ADC |
000004  6803              LDR      r3,[r0,#0]
000006  24ff              MOVS     r4,#0xff
000008  3402              ADDS     r4,#2
00000a  408c              LSLS     r4,r4,r1
00000c  43a3              BICS     r3,r3,r4
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6003              STR      r3,[r0,#0]
;;;277                                        PWM_PERIOD_TRIGGER_ADC) << u32ChannelNum)) | (u32Condition << u32ChannelNum);
;;;278    }
000014  bc10              POP      {r4}
000016  4770              BX       lr
;;;279    
                          ENDP


                          AREA ||i.PWM_EnableCapture||, CODE, READONLY, ALIGN=1

                  PWM_EnableCapture PROC
;;;327     */
;;;328    void PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b4f0              PUSH     {r4-r7}
;;;329    {
;;;330        uint32_t i;
;;;331        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;332        {
;;;333            if(u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
;;;334            {
;;;335                if(i < 2)
;;;336                {
;;;337                    (pwm)->CCR0 |= PWM_CCR0_CAPCH0EN_Msk << (i * 16);
000006  2608              MOVS     r6,#8
                  |L15.8|
000008  462c              MOV      r4,r5                 ;333
00000a  4094              LSLS     r4,r4,r2              ;333
00000c  420c              TST      r4,r1                 ;333
00000e  d00f              BEQ      |L15.48|
000010  2a02              CMP      r2,#2                 ;335
000012  d206              BCS      |L15.34|
000014  6d04              LDR      r4,[r0,#0x50]
000016  0117              LSLS     r7,r2,#4
000018  4633              MOV      r3,r6
00001a  40bb              LSLS     r3,r3,r7
00001c  431c              ORRS     r4,r4,r3
00001e  6504              STR      r4,[r0,#0x50]
000020  e006              B        |L15.48|
                  |L15.34|
;;;338                }
;;;339                else
;;;340                {
;;;341                    (pwm)->CCR2 |= PWM_CCR2_CAPCH2EN_Msk << ((i - 2) * 16);
000022  0114              LSLS     r4,r2,#4
000024  4633              MOV      r3,r6
000026  3c20              SUBS     r4,r4,#0x20
000028  40a3              LSLS     r3,r3,r4
00002a  6d44              LDR      r4,[r0,#0x54]
00002c  4323              ORRS     r3,r3,r4
00002e  6543              STR      r3,[r0,#0x54]
                  |L15.48|
000030  1c52              ADDS     r2,r2,#1
000032  2a04              CMP      r2,#4                 ;331
000034  d3e8              BCC      |L15.8|
;;;342                }
;;;343            }
;;;344        }
;;;345        (pwm)->CAPENR |= u32ChannelMask;
000036  6f82              LDR      r2,[r0,#0x78]
000038  430a              ORRS     r2,r2,r1
00003a  6782              STR      r2,[r0,#0x78]
;;;346    }
00003c  bcf0              POP      {r4-r7}
00003e  4770              BX       lr
;;;347    
                          ENDP


                          AREA ||i.PWM_EnableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableCaptureInt PROC
;;;457     */
;;;458    void PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  010b              LSLS     r3,r1,#4
;;;459    {
;;;460        if(u32ChannelNum < 2)
000002  2902              CMP      r1,#2
000004  d204              BCS      |L16.16|
;;;461            (pwm)->CCR0 |= u32Edge << (u32ChannelNum * 16);
000006  6d01              LDR      r1,[r0,#0x50]
000008  409a              LSLS     r2,r2,r3
00000a  4311              ORRS     r1,r1,r2
00000c  6501              STR      r1,[r0,#0x50]
;;;462        else
;;;463            (pwm)->CCR2 |= u32Edge << ((u32ChannelNum - 2) * 16);
;;;464    
;;;465    }
00000e  4770              BX       lr
                  |L16.16|
000010  3b20              SUBS     r3,r3,#0x20
000012  6d41              LDR      r1,[r0,#0x54]         ;463
000014  409a              LSLS     r2,r2,r3              ;463
000016  430a              ORRS     r2,r2,r1              ;463
000018  6542              STR      r2,[r0,#0x54]         ;463
00001a  4770              BX       lr
;;;466    
                          ENDP


                          AREA ||i.PWM_EnableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_EnableDeadZone PROC
;;;418     */
;;;419    void PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
000000  b430              PUSH     {r4,r5}
;;;420    {
;;;421        // every two channels shares the same setting
;;;422        u32ChannelNum >>= 1;
;;;423        // set duration
;;;424        (pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_DZI01_Msk << (8 * u32ChannelNum))) | (u32Duration << (PWM_PPR_DZI01_Pos + 8 * u32ChannelNum));
000002  6804              LDR      r4,[r0,#0]
000004  0849              LSRS     r1,r1,#1              ;422
000006  00cb              LSLS     r3,r1,#3
000008  25ff              MOVS     r5,#0xff
00000a  042d              LSLS     r5,r5,#16
00000c  409d              LSLS     r5,r5,r3
00000e  3310              ADDS     r3,r3,#0x10
000010  43ac              BICS     r4,r4,r5
000012  409a              LSLS     r2,r2,r3
000014  4314              ORRS     r4,r4,r2
000016  6004              STR      r4,[r0,#0]
;;;425        // enable dead zone
;;;426        (pwm)->PCR |= (PWM_PCR_DZEN01_Msk << u32ChannelNum);
000018  6882              LDR      r2,[r0,#8]
00001a  2310              MOVS     r3,#0x10
00001c  408b              LSLS     r3,r3,r1
00001e  431a              ORRS     r2,r2,r3
000020  6082              STR      r2,[r0,#8]
;;;427    }
000022  bc30              POP      {r4,r5}
000024  4770              BX       lr
;;;428    
                          ENDP


                          AREA ||i.PWM_EnableDutyInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableDutyInt PROC
;;;544     */
;;;545    void PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000000  b430              PUSH     {r4,r5}
;;;546    {
;;;547        (pwm)->PIER = ((pwm)->PIER & ~(PWM_PIER_INT01DTYPE_Msk << (u32ChannelNum >> 1))) | \
000002  6c04              LDR      r4,[r0,#0x40]
000004  084b              LSRS     r3,r1,#1
000006  2501              MOVS     r5,#1
000008  062d              LSLS     r5,r5,#24
00000a  409d              LSLS     r5,r5,r3
00000c  43ac              BICS     r4,r4,r5
00000e  25ff              MOVS     r5,#0xff
000010  3501              ADDS     r5,#1
000012  408d              LSLS     r5,r5,r1
000014  432c              ORRS     r4,r4,r5
000016  409a              LSLS     r2,r2,r3
000018  4314              ORRS     r4,r4,r2
00001a  6404              STR      r4,[r0,#0x40]
;;;548                      (PWM_PIER_PWMDIE0_Msk << u32ChannelNum) | (u32IntDutyType << (u32ChannelNum >> 1));
;;;549    }
00001c  bc30              POP      {r4,r5}
00001e  4770              BX       lr
;;;550    
                          ENDP


                          AREA ||i.PWM_EnableOutput||, CODE, READONLY, ALIGN=1

                  PWM_EnableOutput PROC
;;;387     */
;;;388    void PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  6fc2              LDR      r2,[r0,#0x7c]
;;;389    {
;;;390        (pwm)->POE |= u32ChannelMask;
000002  430a              ORRS     r2,r2,r1
000004  67c2              STR      r2,[r0,#0x7c]
;;;391    }
000006  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.PWM_EnablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_EnablePeriodInt PROC
;;;601     */
;;;602    void PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
000000  b430              PUSH     {r4,r5}
;;;603    {
;;;604        (pwm)->PIER = ((pwm)->PIER & ~(PWM_PIER_INT01TYPE_Msk << (u32ChannelNum >> 1))) | \
000002  6c04              LDR      r4,[r0,#0x40]
000004  084b              LSRS     r3,r1,#1
000006  2501              MOVS     r5,#1
000008  042d              LSLS     r5,r5,#16
00000a  409d              LSLS     r5,r5,r3
00000c  43ac              BICS     r4,r4,r5
00000e  2501              MOVS     r5,#1
000010  408d              LSLS     r5,r5,r1
000012  432c              ORRS     r4,r4,r5
000014  409a              LSLS     r2,r2,r3
000016  4314              ORRS     r4,r4,r2
000018  6404              STR      r4,[r0,#0x40]
;;;605                      (PWM_PIER_PWMIE0_Msk << u32ChannelNum) | (u32IntPeriodType << (u32ChannelNum >> 1));
;;;606    }
00001a  bc30              POP      {r4,r5}
00001c  4770              BX       lr
;;;607    
                          ENDP


                          AREA ||i.PWM_ForceStop||, CODE, READONLY, ALIGN=1

                  PWM_ForceStop PROC
;;;249     */
;;;250    void PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b470              PUSH     {r4-r6}
;;;251    {
;;;252        uint32_t u32Mask = 0, i;
000002  2300              MOVS     r3,#0
;;;253        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000004  461a              MOV      r2,r3
;;;254        {
;;;255            if(u32ChannelMask & (1 << i))
000006  2601              MOVS     r6,#1
                  |L21.8|
000008  4635              MOV      r5,r6
00000a  4095              LSLS     r5,r5,r2
00000c  4634              MOV      r4,r6
00000e  420d              TST      r5,r1
000010  d002              BEQ      |L21.24|
;;;256            {
;;;257                u32Mask |= (PWM_PCR_CH0EN_Msk << (i * 8));
000012  00d5              LSLS     r5,r2,#3
000014  40ac              LSLS     r4,r4,r5
000016  4323              ORRS     r3,r3,r4
                  |L21.24|
000018  1c52              ADDS     r2,r2,#1
00001a  2a04              CMP      r2,#4                 ;253
00001c  d3f4              BCC      |L21.8|
;;;258            }
;;;259        }
;;;260    
;;;261        (pwm)->PCR &= ~u32Mask;
00001e  6881              LDR      r1,[r0,#8]
000020  4399              BICS     r1,r1,r3
000022  6081              STR      r1,[r0,#8]
;;;262    }
000024  bc70              POP      {r4-r6}
000026  4770              BX       lr
;;;263    
                          ENDP


                          AREA ||i.PWM_GetADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetADCTriggerFlag PROC
;;;312     */
;;;313    uint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;314    {
;;;315        return (((pwm)->TSTATUS & (PWM_TSTATUS_PWM0TF_Msk << (u32ChannelNum))) ? 1 : 0);
000002  6840              LDR      r0,[r0,#4]
000004  2201              MOVS     r2,#1
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L22.14|
00000c  2001              MOVS     r0,#1
                  |L22.14|
;;;316    }
00000e  4770              BX       lr
;;;317    
                          ENDP


                          AREA ||i.PWM_GetCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetCaptureIntFlag PROC
;;;519     */
;;;520    uint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  23c0              MOVS     r3,#0xc0
;;;521    {
;;;522        if(u32ChannelNum < 2)
;;;523        {
;;;524            return (((pwm)->CCR0 & ((PWM_CCR0_CRLRI0_Msk | PWM_CCR0_CFLRI0_Msk) << (u32ChannelNum * 16))) >> (PWM_CCR0_CRLRI0_Pos + u32ChannelNum * 16));
000002  010a              LSLS     r2,r1,#4
000004  2902              CMP      r1,#2                 ;522
000006  d204              BCS      |L23.18|
000008  6d00              LDR      r0,[r0,#0x50]
00000a  4093              LSLS     r3,r3,r2
00000c  4018              ANDS     r0,r0,r3
00000e  1d92              ADDS     r2,r2,#6
000010  e005              B        |L23.30|
                  |L23.18|
;;;525        }
;;;526        else
;;;527        {
;;;528            return (((pwm)->CCR2 & ((PWM_CCR2_CRLRI2_Msk | PWM_CCR2_CFLRI2_Msk) << ((u32ChannelNum - 2) * 16))) >> (PWM_CCR2_CRLRI2_Pos + (u32ChannelNum - 2) * 16));
000012  4611              MOV      r1,r2
000014  3920              SUBS     r1,r1,#0x20
000016  6d40              LDR      r0,[r0,#0x54]
000018  408b              LSLS     r3,r3,r1
00001a  4018              ANDS     r0,r0,r3
00001c  3a1a              SUBS     r2,r2,#0x1a
                  |L23.30|
00001e  40d0              LSRS     r0,r0,r2
;;;529        }
;;;530    
;;;531    }
000020  4770              BX       lr
;;;532    /**
                          ENDP


                          AREA ||i.PWM_GetDutyIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetDutyIntFlag PROC
;;;585     */
;;;586    uint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6c40              LDR      r0,[r0,#0x44]
;;;587    {
;;;588        return (((pwm)->PIIR & (PWM_PIIR_PWMDIF0_Msk << u32ChannelNum)) ? 1 : 0);
000002  22ff              MOVS     r2,#0xff
000004  3201              ADDS     r2,#1
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L24.14|
00000c  2001              MOVS     r0,#1
                  |L24.14|
;;;589    }
00000e  4770              BX       lr
;;;590    
                          ENDP


                          AREA ||i.PWM_GetPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetPeriodIntFlag PROC
;;;640     */
;;;641    uint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6c40              LDR      r0,[r0,#0x44]
;;;642    {
;;;643        return (((pwm)->PIIR & (PWM_PIIR_PWMIF0_Msk << (u32ChannelNum))) ? 1 : 0);
000002  2201              MOVS     r2,#1
000004  408a              LSLS     r2,r2,r1
000006  4010              ANDS     r0,r0,r2
000008  d000              BEQ      |L25.12|
00000a  2001              MOVS     r0,#1
                  |L25.12|
;;;644    }
00000c  4770              BX       lr
;;;645    
                          ENDP


                          AREA ||i.PWM_Start||, CODE, READONLY, ALIGN=1

                  PWM_Start PROC
;;;203     */
;;;204    void PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b470              PUSH     {r4-r6}
;;;205    {
;;;206        uint32_t u32Mask = 0, i;
000002  2300              MOVS     r3,#0
;;;207        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000004  461a              MOV      r2,r3
;;;208        {
;;;209            if(u32ChannelMask & (1 << i))
000006  2601              MOVS     r6,#1
                  |L26.8|
000008  4635              MOV      r5,r6
00000a  4095              LSLS     r5,r5,r2
00000c  4634              MOV      r4,r6
00000e  420d              TST      r5,r1
000010  d002              BEQ      |L26.24|
;;;210            {
;;;211                u32Mask |= (PWM_PCR_CH0EN_Msk << (i * 8));
000012  00d5              LSLS     r5,r2,#3
000014  40ac              LSLS     r4,r4,r5
000016  4323              ORRS     r3,r3,r4
                  |L26.24|
000018  1c52              ADDS     r2,r2,#1
00001a  2a04              CMP      r2,#4                 ;207
00001c  d3f4              BCC      |L26.8|
;;;212            }
;;;213        }
;;;214    
;;;215        (pwm)->PCR |= u32Mask;
00001e  6881              LDR      r1,[r0,#8]
000020  4319              ORRS     r1,r1,r3
000022  6081              STR      r1,[r0,#8]
;;;216    }
000024  bc70              POP      {r4-r6}
000026  4770              BX       lr
;;;217    
                          ENDP


                          AREA ||i.PWM_Stop||, CODE, READONLY, ALIGN=1

                  PWM_Stop PROC
;;;227     */
;;;228    void PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b430              PUSH     {r4,r5}
;;;229    {
;;;230        uint32_t i;
;;;231        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;232        {
;;;233            if(u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
000006  4614              MOV      r4,r2
                  |L27.8|
000008  462b              MOV      r3,r5
00000a  4093              LSLS     r3,r3,r2
00000c  420b              TST      r3,r1
00000e  d003              BEQ      |L27.24|
;;;234            {
;;;235                *((__IO uint32_t *)((((uint32_t) & ((pwm)->CNR0)) + i * 12))) = 0;
000010  230c              MOVS     r3,#0xc
000012  4353              MULS     r3,r2,r3
000014  181b              ADDS     r3,r3,r0
000016  60dc              STR      r4,[r3,#0xc]
                  |L27.24|
000018  1c52              ADDS     r2,r2,#1
00001a  2a04              CMP      r2,#4                 ;231
00001c  d3f4              BCC      |L27.8|
;;;236            }
;;;237        }
;;;238    }
00001e  bc30              POP      {r4,r5}
000020  4770              BX       lr
;;;239    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00002710
                          DCD      0x00000000
                          DCD      0x01518000
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00b71b00
                          DCD      0x00002710
                          DCD      0x00000000
                          DCD      0x01518000
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000003

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REV16|
#line 118 "..\\..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_pwm_c_c4896a9e____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REVSH|
#line 132
|__asm___5_pwm_c_c4896a9e____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
